# 四庫全書（庫函數）

## 出入流

### iostream  匚艹輸入輸出流函數庫

- 英文全稱：`input output stream`
- 注意：所有變量名前面都要統一加`std::`  除非函數中加了`using namespace std`;

```c++
cin>>a;  // 輸入
cout<<a; // 輸出
```

### iomanip  匚艹輸出輸入操縱器函數庫

| 功能                      | 寫法                                       | 效果                           |
|-------------------------|------------------------------------------|------------------------------|
| 保留n位數字輸出                | `cout << setpricition(n) << a;`          | `123.456789 n=5 → 123.45`    |
| 保留n位小數輸出                | `cout << fixed << setpricition(n) << a;` | `123.456789 n=5 → 123.45678` |
| 取消整数的科学计数法              | `cout << fixed << setpricition(n) << a;` |                              |
| 把十進制x轉換為N（8、10、16）進制並輸出 | `cout<<setbase(N)<<x;`                   |                              |

## 繼承函數庫

### cstdio  匚艹標準輸入輸出庫（stdio.h）

- 英文全稱：`standard input/output`

```c++
scanf   // 輸入
printf  // 輸出
```

- 占位符：類型

| 類型          | 寫法                 | 來源  |
|-------------|--------------------|-----|
| 雙精度`double` | 輸入`%lf`、輸出`%f`不是%d |     |
| 十進制整數       | %d                 | dec |
| 十六進制整數      | `%x`               | hex |
| 八進制整數       | `%o`               | oct |
|             |                    |     |
|             |                    |     |
|             |                    |     |
|             |                    |     |
|             |                    |     |
|             |                    |     |

占位符：
%d是整數

縮寫 %f：浮點數 %c：字符 %s：字符串 %p：指針地址 %u：無符號整數
%ld長整型 %lld超長整型 %lf雙精度浮點型 %lu無符號長整型
%e：用于以指數形式輸出浮點數。
%g：根據值的大小，自動選擇%f或%e格式輸出浮點數。
%i：與%d相同，十進制整數。

- 占位符：類型

| 類型           | 寫法       |
|--------------|----------|
| 設置總寬度        | `%___d`  |
| 設置保留小數       | `%.___d` |
| 同時設置，點左右各自設置 | `%__._d` |
| 設置左對齊（默認右對齊） | `%-__d`  |

---

- #### 大量輸入輸出辦法

1. 因為`cin`/`cout`速度較慢，建議使用`scanf`和`printf`
2. 如何「騙過」VS：在文件第一句加上
   ```c++
   #define _CRT_SECURE_NO_WARNINGS 1
   ```
3. 不想放棄`cin`/`cout`，加上這一段代碼，不過就不能使用`scanf` `printf` `getchar`了
   ```c++
   std::ios::sync_with_stdio(false); // 關閉同步
   std::cin.tie(0);                  // 解綁
   ```

4. 使用比`scanf`還快的快讀
   ```c++
   int read() // 快讀
   {
       char c = getchar();
       int x = 0, f = 1;
       while (c < '0' || c > '9')
       {
           if (c == '-') f = -1;
           c = getchar();
       }
       while (c >= '0' && c <= '9')
       {
           x = x * 10 + c - '0';
           c = getchar();
       }
       return x * f;
   }
   ```

5.如果明確說了已經解綁出入流，那麼可以放心用`cin` `cout`

### cstdlib  匚艹標準庫（stdlib.h）

- 英文全稱 standard library
- 字符串轉化為數字

| 寫法			         | 返回值				              |
|---------------|----------------------|
| `stoi(str)`   | `int`				            |
| `stol(str)`   | `long`			            |
| `stoll(str)`  | `long long`		        |
| `stoul(str)`  | `unsigned long`	     |
| `stoull(str)` | `unsigned long long` |
| `stof(str)`   | `float`			           |
| `stod(str)`   | `double`			          |
| `stold(str)`  | `long double`		      |

整數 浮點數
atoi 整數 int
atol 長整數 long
strtol 長整數 long
atoll 超長整數 llong
strtoll 超長整數 llong		
strtoul 無符長 us.long		
strtoull 無符超長 us.ll

strtof 單精度 float
atof 雙精度 double
strtod 雙精度 double
strtold 長浮點 l.double
動態內存分配
為類型為type，大小為size的動態數組Arr分配內存   
type* Arr = (type *)malloc(size * sizeof(type))
動態數組記憶體釋放
free(Arr)

實際使用:伸屈陣列
int* Arr = (int*)malloc(size * sizeof(int)); // 大小為size
free(Arr); // 動態內存清空

二向伸屈陣列
// 使用之前
int** Arr; // 二級指針動態申請二維數組
Arr = (int**)malloc(sizeof(int*) * m); // m行n列
for (int i = 0; i < m; i++)
Arr[i] = (int*)malloc(sizeof(int) * n);
// 使用之後清空內存時
for (int i = 0; i < m; i++)
free(Arr[i]);// 先釋放內部的一維數組
free(Arr); // 最後釋放外層的二維指針

現在有很多取代的方法，以下是其一

一維動態數組

```c++
// 創建的時候  
int* array = new int[size];
// 使用完了
delete[] array;


```

二向動態數組

```c++
// 創建的時候
int** array2D = new int* [rows];
for (int i = 0; i < rows; ++i)  array2D[i] = new int[cols];
// 使用完了
for (int i = 0; i < rows; ++i)  delete[] array2D[i];
delete[] array2D;
```

cstring 匚艹字符數組函數庫（string.h）
這裡只列出不能使用string代替的，用來操作C風格的字符串（使用\0結尾的）的

預先填充 memset(Arr, 0, sizeof(Arr));
計算長度 strlen(Arr)   不包括末尾的空字符 \0
複製a到b strcpy(b,a)  複製操作會覆蓋目標字符串原有的內容
添加到末尾 strcat()：

### cctype 匚艹字符類型函數庫（ctype.h）

- #### 判斷函數，接收字符值，返回正誤值

註：十六進制數字字符指的是`0~9` `A~F` `a~f`

| 功能	      | 寫法		         |
|----------|--------------|
| 字母或數字	   | `isalnum()`  |
| 字母	      | `isalpha()`  |
| 小寫字母	    | `islower()`  |
| 大寫字母	    | `isupper()`  |
| 空格	      | `isblank()`  |
| 數字	      | `isdigit()`  |
| 十六進制數字字符 | `isxdigit()` |

- #### 轉換函數

這兩個函數是不用管接受的數是不是已經是目標格式了，可以無差別輸進去。

| 功能  | 寫法		        |
|-----|-------------|
| 轉大寫 | `toupper()` |
| 轉小寫 | `tolower()` |

- #### 大小寫轉換擴展

| 方法	   | 轉大寫		        | 轉小寫		        | 說明			          |
|-------|--------------|--------------|----------------|
| 使用偏移  | `a -= 32`	   | `a += 32`	   | 如果已經符合大小寫了會偏掉的 |
| 使用位運算 | `a &= ~0x20` | `a \|= 0x20` | 使用交換碼的特性	      |

### cmath  匚艹數學函數庫（math.h）

說明：

1. 所有整數，想要計算結果是浮點數，必須加.0後綴！
    - 例子：`pow(8, 1.0 /3.0)`  即`8^1/3` =`2`
    - 反例：`pow(8, 1 / 3)`  `1/3`取整為`0` 即`8^0 = 1`
2. 需要自行定義常數
    - `π`需要自行定義`const double Pi = acos(-1.0)`
    - `e`需要自行定義`const double e = exp(1)`

| 模塊   | 功能	    | 寫法			           | 說明						                  |
|------|--------|-----------------|---------------------------|
| 絕對值  | 整數絕對值  | `abs(a)`		      | 						                    |
| └──  | 浮點絕對值  | `fabs(a)`		     | 						                    |
| 餘數   | 浮點餘a%b | `fmod(a,b)`	    | 在浮點數除法裡面使用%取餘數是不合法的	      |
| 取整   | 向上取整   | `ceil(a)`	      | 						                    |
| ├──  | 向下取整   | `floor(a)`	     | 						                    |
| ├──  | 四捨五入   | `round(a)`	     | 						                    |
| └──  | 向零取整   | `trunc()`	      | 可以理解為無論正負，去尾取整			         |
| 合成數字 | 兩個數字合併 | `copysign(a,b)` | 取第一個數的數值，和第二個數的正負號		      |
| 分解數字 | 一個數字分拆 | `modf(a,&b)`	   | 取浮點數的小數作為返回值，通過引用返回整數部分   |
| 對數   | 自然對數   | `log(a)`		      | 						                    |
| └──  | 常用對數   | `log10(a)`	     | 						                    |
| 指數   | 自然冪e^a | `exp(a)`		      | 						                    |
| ├──  | 普通冪a^b | `pow(a,b)`	     | 						                    |
| └──  | 二進冪2^a | `exp2(a)`	      | 						                    |
| 根數   | 平方根	   | `sqrt(a)`	      | 						                    |
| └──  | 立方根	   | `cbrt(a)`	      | 						                    |
| 勾股定理 | 勾股求弦   | `hypot(a,b)`	   | 即求sqrt(a2+b2)			          |
| 三角函數 | 正弦	    | `sin(a)`		      | 						                    |
| ├──  | 余弦	    | `cos(a)`		      | 						                    |
| ├──  | 正切	    | `tan(a)`		      | 						                    |
| ├──  | 反正弦	   | `asin(a)`	      | 						                    |
| ├──  | 反余弦	   | `acos(a)`	      | 						                    |
| ├──  | 反正切	   | `atan(a)`	      | 給出橫縱座標值(y,x)，返回該點與原點連線的張角 |
| └──  | 角度	    | `atan2(y,x)`	   | 						                    |
| 雙曲三角 | 雙曲正弦   | `sinh(a)`	      | 						                    |
| ├──  | 雙曲餘弦   | `cosh(a)`	      | 						                    |
| ├──  | 雙曲正切   | `tanh(a)`	      | 						                    |
| ├──  | 雙曲反正弦  | `asinh(a)`	     | 						                    |
| ├──  | 雙曲反餘弦  | `acosh(a)`	     | 						                    |
| └──  | 雙曲反正切  | `atanh(a)`	     | 						                    |
| 誤差函數 | 誤差值	   | `erf()`		       | 						                    |
| └──  | 互補誤差值  | `erfc()`		      | 						                    |
| ㄍㄇ函數 | ㄍㄇ值	   | `tgamma()`	     | 						                    |
| └──  | 對數ㄍㄇ值  | `lgamma()`	     | 						                    |

- #### 優化

內建函數會更快

| 功能	   | 寫法					               |
|-------|-----------------------|
| 絕對值   | `__builtin_abs(x)`	   |
| 平方根   | `__builtin_sqrt(x)`   |
| 乘方	   | `__builtin_pow(x, y)` |
| 浮點絕對值 | `__builtin_fabs(x)`   |
| 最大值   | `__builtin_max(x, y)` |
| 最小值   | `__builtin_min(x, y)` |

## 資料構造

### string   匚艹尺牘書簡函數庫

> - 名稱：CN字符串 TW字串
> - 注意：所有變量名前面都要統一加`std::`  除非函數中加了`using namespace std`;

- #### 遍歷
  迭代器：支持八種函數生成隨機訪問迭代器

- #### 長度

| 功能	          | 寫法						                               | 返回值 | 說明	                           |
|--------------|----------------------------------------|-----|-------------------------------|
| 長度	          | `str.size()`/`str.length()`            | 整值  | 		                            |
| 是否為空         | `str.empty()`			                       | 正誤值 | 		                            |
| 目前分配大小       | `str.capacity()`			                    | 整值  | 		                            |
| 最大的大小        | `str.max_size()`			                    | 整值  | 數值根據環境而定                      |
| 更改字符串的長度為`n` | `str.resize(n)`                        | 无   | 多出來空間的用'\0'填充<br/>少掉的空間將字符串截斷 |
| *多出來的用`ch`填充 | `str.resize(n,ch)`/`str.resize(n,'x')` | 无   |                               |


- #### 內容

| 功能			         | 寫法							                        |
|---------------|----------------------------------|
| 訪問第n位機器序號	    | `str[n]`/`str.at(n)`			          |
| 訪問第一位/第0位機器序號 | `str.front()`/`str[0]`		         |
| 訪問最後一位		      | `str.back()`/`str[str.size()-1]` |

- #### 添加

| 功能				            | 寫法									                              |
|-------------------|------------------------------------------|
| 在a末尾添加字符串b		      | `a+=b`/`a.append(b)`					                |
| 在a末尾添加指定字符		      | `a+="xxx"`/`a.append("xxx")`			          |
| 字符串連接函數，連接字符串 a,b | `a.append(b)`							                     |
| 在字符串str末尾添加一個字符   | `str.push_back('!')`/`str.push_back(ch)` |

- #### 插入

在a的第n位人類序號之後（或者解釋為第n為機器序號之前）插入字符串  
a.insert(n,b)  或 a.insert(n, "xxx")   
例：
"HELL Y"  str.insert(4, "o")  →  "HELLO Y"
註：不能以字符的形式插入，如'#',就算是字符也要改成字符串形式，如"#"

- #### 刪除

| 功能				             | 寫法			          | 說明										                              |
|--------------------|----------------|-------------------------------------------|
| 字符串末尾刪除一個字符		      | str.pop_back() | 										                                |
| 清空字符串的內容		         | str.clear	     |
| 在第n位（人類序號）之後刪除x個字符 | str.erase(n,x) | "Hello World"  str.erase(5, 6); → "Hello" |

- #### 替換

在str的第n位（人類序號）之後刪除x個字符，并在這中間插入特定字符串或字符串b
str.replace(n,x,b)  或 str.replace(n,x,"xxx")
例："Hello World!"     str.replace(6, 5, "Yau"); →   "Hello Yau!"
註：這裡的第二個數的值不需要和第三個字符串長度相等如果不相等，編譯器會自動調整後面的部分的存貯位置，使其中間沒有空位

- #### 截取

以str的第n位索引為第一個字符，總共截取x個字符，作為它的子串傳回
str.substr(n,x)
例："Hello World"  string a=str.substr(5, 6); → a="World"

實際操作：
〡 去除結尾n位 s = s.substr(0, s.size() - n);
〢 就要結尾n位 s = s.substr(s.size() - n, n);
〣 取得索引m n之間的部分[m n] s.substr(n, m - n + 1)
〤 取得索引m n之間的部分[m n) s.substr(n, m - n)
比較
比較字符串a和b的字典序列 a.compare(b)  返回整數值
如果a的字典序列小於b 結果為負數，值不一定
如果a的字典序列大於b 結果為正數，值不一定
如果兩個的字典序列相等，即兩個字符串完全相同，結果為0
請想像字典中的排列……

- #### 尋找

尋找字符串str中第一次出現特定字符串第一位是哪個索引 返回索引型size_t
str.find(b)  或 str.find("xxx")
例："Hello World"  size_t p=str.find("World")  p=6
註：沒有找到返回string::npos

指針
使用指針把str轉換成以\0為結尾的C語言形態字符數組 返回靜態字符數組const char*
str.c_str()  或 str.data()
例："Hello World"  const char *data = str.data()  data="Hello World\0"

- #### 輸入

> 一般的cin輸入在碰到空格就停止了，這個是為了完整讀取一行而產生的

帶空格輸入字符串函數，輸入字符串s，遇到回車停止 getline(cin,s)

註：使用cin讀取會留下換行符。如果緊接著使用getline()讀取字符串，那麼getline()只會讀取從cin到換行符的內容，而不是任何其他內容，因此會得到一個空字符串。
改進方法：
①基礎方法 cin.ignore()    用來忽略這輸入流中的下一個字符
②萬全之策 <limits> + cin.ignore(numeric_limits<streamsize>::max(), '\n')
③亡羊補牢 if (!str.size())  { getline(cin, str); }

- #### 賦值

和replace()不同，這個是字符串的所有內容都不要，整體重新賦值，有多個重載函數
〡 str被字符數組ch賦值 str.assign(ch)
常量字符數組（const char* ch1）和普通字符數組（char ch2[]）都可以  
〢 str被字符數組的前n個字符賦值 str.assign(ch，n)
〣 str被字符數組的從第k個字符之後開始的n個字符賦值str.assign(ch,k,n)
例："HHH"  "HelloYau"  str.assign(ch,3,3)  "loY"

〤 str被字符串str1賦值 str.assign(str1)
〥 str被字符串str1的從第k個字符之後開始的n個字符賦值str.assign(str1,k,n)

〦 str被字符串str1使用迭代器賦值 str.assign(str1.it1, str1.it2)
如s.assign(vec.begin(), vec.end())

〧 str被字符ch重複賦值n次 str.assign(n, 'a');
上面例子獲得"aaaaa"

- #### 轉換

字符串轉整數

| 寫法			         | 返回值				              |
|---------------|----------------------|
| `stoi(str)`   | `int`				            |
| `stol(str)`   | `long`			            |
| `stoll(str)`  | `long long`		        |
| `stoul(str)`  | `unsigned long`	     |
| `stoull(str)` | `unsigned long long` |
| `stof(str)`   | `float`			           |
| `stod(str)`   | `double`			          |
| `stold(str)`  | `long double`		      |

*重載函數：更改N進制字符串為十進制 stoi(str,0,N)  
中間的參數為一個指向 size_t 的指針，默認值為0，可不變
後面的參數如果填0，那麼編譯器自動檢測進制。0X或0x開頭判斷為十六進制，0開頭判斷為八進制，其他認為是十進制
N在2~36之間，字符串的進制可以大於十六進制，最高為36進制（十個數字+二十六個字母），其中大小寫均可

整數a轉字符串
string str = to_string(a)     轉化為普通字符串，保留符號及小數點
wstring wstr = to_wstring(a)  轉化為「寬字符字符串」，和文字編碼有關

### array   匚艹陣列函數庫

> 所有變量名前面都要統一加std::  除非函數中加了using namespace std;

容器：array<type,n> A，其中type是裡面存貯的數據類型，n為陣列的大小

- #### 遍歷

迭代器：支持八種函數生成隨機訪問迭代器

- #### 大小

字符串a的長度 a.size()    因為是靜態的，所以等價於 a.max_size()  返回整值
字符串a是否為空 a.empty()   返回正誤值

- #### 內容

訪問a的第n位（機器序號） a[n]  或 a.at(n)  
訪問a的第一位（第0位） a.front()  或 a[0]
訪問a的最後一位 a.back()  或 a[a.size()-1]

- #### 指針

返回一個指向數組首個元素的指針 a.data()  
用途：可以像使用傳統的C風格數組那樣訪問和操作array的元素，如訪問某一個的值可以使用* a.data()
當函數的參數列表想要使用「數組退化成的指針」時，可以使用a.data()作為參數傳入

- #### 賦值

為a中所有元素賦相同初始值 a.fill(n)  所有元素賦值為n
支持整個賦值如 a1={1,2,3} array<int, 3> a2 = a1; a2={1,2,3}
這裡必須兩個的類型和大小完全相等，否則不能賦值

- #### 交換  交換兩個陣列/數組的內容 a.swap(b)

### vector  匚艹向量函數庫

> 所有變量名前面都要統一加std::  除非函數中加了using namespace std;

容器：vector<type> XL，其中type是裡面存貯的數據類型

- #### 遍歷

迭代器：支持八種函數生成隨機訪問迭代器

- #### 大小

| 功能	    | 寫法			          | 返回值 | 說明	      |
|--------|----------------|-----|----------|
| 大小	    | `x.size()`	    | 整值  | 		       |
| 是否為空   | `x.empty()`	   | 正誤值 | 		       |
| 目前分配大小 | `x.capacity()` | 整值  | 		       |
| 最大的大小  | `x.max_size()` | 整值  | 數值根據環境而定 |

更改字符串的大小為n x.resize(n)

無返回值，多出來空間的用0填充，少掉的空間將向量截斷
*重載函數：多出來的用指定的數字m填充 x.resize(n, m) 或str.resize(n,16)

預留空間為n x.reserve(n)
不改變向量大小，但是可以避免頻繁地分配內存

- #### 初始化

| 功能			          | 寫法											                                 |
|----------------|-----------------------------------------------|
| 線性向量預設大小	      | `vector<int> XL(n)`						                     |
| 線性向量預填滿		      | `vector<int> XL(n, 0)`						                  |
| 創建平面向量		       | `vector<vector<int>> XL`					                 |
| 平面向量預設大小	      | `vector<vector<int>> XL(n, vector<int>(m))`   |
| 平面向量預填滿		      | `vector<vector<int>> XL(n, vector<int>(m,0))` |
| 讓向量xl1為xl2賦初始值 | `vector<int> xl2(xl1)`						                  |

- #### 內容

| 功能			         | 寫法						                   |
|---------------|----------------------------|
| 訪問第n位機器序號	    | `x[n]`/`x.at(n)`		         |
| 訪問第一位/第0位機器序號 | `x.front()`/`x[0]`		       |
| 訪問最後一位		      | `x.back()`/`x[x.size()-1]` |

- #### 添加/插入/刪除

| 功能		        | 寫法			          |
|-------------|----------------|
| 在向量末尾添加新元素a | x.push_back(a) |
| 插入元素		      | x.insert(it,a) |
| 重複元素插入	     | 				           |
| 範圍插入		      | 				           |
| 使用初始化列表插入   | 				           |
| 刪除單個元素	     | 				           |
| 			         | 				           |
| 			         | 				           |

移除向量末尾的元素 x.pop_back()

刪除
〡 x.erase(it)
刪除x[i] begin()+i 倒數第j個就是end()-j

〢刪除系列元素 x.erase(it1,it2)
開頭保留k個 begin()+k， 結尾
保留l個end()-l

〣清空內容 x.clear()  移除向量中的所有元素

### tuple 匚艹元組函數庫

所有變量名前面都要統一加std::  除非函數中加了using namespace std;
容器：元組 tuple<type1,type2,typeN> YuehBing ，其中type是裡面的類型，可以不一樣，相當於數對的泛化形式，代替實例化的結構體

初始化
使用構造函數 tuple<string,char,int> z("ShuoWen",'Y',13);
使用初始化列表 tuple<string,char,int> x= {"ShuoWen",'Y',13};
使用make_tuple函數 tuple<string,char,int> x= make_tuple("ShuoWen",'Y',13);
使用其他元組初始化 tuple<string,char,int> y(x);

調用元素
get<N>(YB)   索引從0開始

大小
tuple_size<decltype(YB)>::value a為元組的名字返回int值

解綁
tie(a, b, c) = YB 其中a,b,c的類型必須和YB裡面的類型相同，或者可以隱式轉換

### stack  匚艹雲棧堆疊函數庫

- 名稱：CN棧 TW堆疊
- 注意：所有變量名前面都要統一加`std::`  除非函數中加了`using namespace std`;
- 容器：`stack<type> z` 其中`type`是裡面存貯的數據類型，如`int`，也可以是`string` `pair`等非常複雜的數據類型

| 功能	   | 寫法			         | 返回值 | 說明										                              |
|-------|---------------|-----|-------------------------------------------|
| 入棧/壓棧 | `z.push(a)`   | 	   | 使用常量、變量、變量的引用都可以						                    |
| 出棧/彈棧 | `z.pop()`	    | 	   | 										                                |
| 查看棧頂  | `z.top()`	    | 頂端值 | / 註1：出棧並不返回值，查看棧頂也並不會刪除棧頂				             |
| 是否為空  | `z.empty()`   | 正誤值 | \ 註2：在操作之前一定要注意棧是否為空					                 |
| 檢查大小  | `z.size()`	   | 整值  | 										                                |
| 構造入棧  | `z.emplace()` | 	   | `z.emplace(6)` == `int a=6` + `z.push(a)` |
| 交換內容  | `a.swap(b)`   | 	   | 大小不一樣也可以交換								                        |

- #### 使用向量模擬

| 功能	   | 寫法			         |
|-------|---------------|
| 入棧/壓棧 | `push_back()` |
| 出棧/彈棧 | `pop_back()`  |
| 查看棧頂  | `back()`	     |
| 是否為空  | `size()`	     |
| 檢查大小  | `empty()`	    |

- #### 使用數組模擬

```c++
int z[100]; // 很大的時候使用向量，然後在初始化的時候改變大小
int u = 0; // 棧頂指針
void init() { u = 0; }
void push(int x) { z[++u] = x; }
void pop() { z[u--] = 0; } // 是否為空？
int top() { return z[u]; } // 是否為空？
int size() { return u; }
bool empty() { return u <= 0; }
```

### queue 匚艹行伍佇列函數庫

> 所有變量名前面都要統一加std::  除非函數中加了using namespace std;
> 容器：queue<type> d，其中type是裡面存貯的數據類型

| 功能   | 寫法			         | 返回值 | 說明										                              |
|------|---------------|-----|-------------------------------------------|
| 隊尾入隊 | `d.push(a)`   | 	   | 隊首指隊列裡最早添加的元素							                      |
| 隊首出隊 | `d.pop()`	    | 	   | 隊尾指隊列裡最新添加的元素							                      |
| 查看隊首 | `d.front()`   | 	   | 										                                |
| 查看隊尾 | `d.back()`	   | 	   | 										                                |
| 是否為空 | `d.empty()`   | 正誤值 | 										                                |
| 檢查大小 | `d.size()`	   | 整值  | 										                                |
| 構造入隊 | `z.emplace()` | 	   | `d.emplace(6)` == `int a=6` + `d.push(a)` |
| 交換內容 | `a.swap(b)`   | 	   | 大小不一樣也可以交換								                        |

直接構造並入隊列：d.emplace()   裡面的參數就是構造並入隊列中的元素
創建變量和變量入隊二合一 d.emplace(6) int a=6 + d.push(a)
交換兩個隊列的全部內容：a.swap(b)   註：大小不一樣也可以交換

註：堆疊和佇列兩個屬於『半封裝型』數據結構，所以不提供遍歷、清空等操作

- #### 使用數組模擬隊列

```c++
int d[100]; // 很大的時候使用向量，然後在初始化的時候改變大小
int u = 0; // 隊首指針
int w = -1; // 隊尾指針
void init() { u = 0, w = -1; }
void push(int x) { d[++w] = x; }
void pop() { d[u++] = 0; } // 是否為空？
int front() { return d[u]; } // 是否為空？
int back() { return d[w]; } // 是否為空？
int size() { return w - u + 1; }
bool empty() { return u > w; }
```

- #### 限數隊列

在普通隊列的「入隊」操作上加上判斷即可實現，隊列滿是人為的「滿」不是程序的「溢」

```c++
if ( 隊列滿 )  d.pop() 
d.push(x)
```

- #### 循環隊列

和上面那個類似，但是由於是由靜態數組製作的，這個是真的是程序的溢出，

```c++
const int N=100;
int d[N];
int u = 0; int w = -1;

void init() { u = 0; w = -1;}
int size() {
if (w >= u)  return w - u + 1;
else return N - u + w + 1; // 考慮環繞的情况
}
bool empty() { return u == w + 1 || (u == 0 && w == -1); }
void push(int x) {
w = (w + 1) % N; d[w] = x;
if (w == u && size() > 1) u = (u + 1) % N;
}
void pop() { d[u] = 0; u = (u + 1) % N; }
int front() { return d[u]; }
int back() { return d[w]; }
```

優先隊列（堆）
容器：priority_queue<type> d，其中type是裡面存貯的數據類型，元素的出隊順序是根據優先級來決定的，優先級相同時，纔按照入隊順序出隊，這是一個基於堆的數據結構
入隊列 d.push() 元素入隊，並且按照優先級排列；時間複雜度log2n
出隊列 d.pop()  元素出隊，賸餘的重新排列；時間複雜度log2n

檢查 top()   查看優先級最高的元素
不能查看優先級最低的元素，因為實現原理是堆，所以最後一個元素可能並不是優先度最低的，標準庫不提供權限，自己實現的也不應該存取

檢查是否為空 d.empty()    無參數，返回正誤值
檢查大小 d.size()     無參數，返回整值

直接構造並入隊列：d.emplace()   裡面的參數就是構造並入隊列中的元素
交換兩個隊列的全部內容：a.swap(b)

默認情況下，priority_queue 使用std::less<T>排序，隊首是最大的
隊首最小 <functional>  priority_queue<int, vector<int>, greater<int>> d;

求第幾小的數用前面的，求第幾大的數用後面的，因為這個隊列不開放隊尾查詢
使用這個語句更新d.push(i); if (d.size() > dijida)  d.pop();

### deque 匚艹雙相佇列函數庫

- 名稱：CN雙向隊列 TW雙向佇列
- 注意：所有變量名前面都要統一加`std::`  除非函數中加了`using namespace std`;
- 容器：`deque <type> S` 其中`type`是裡面存貯的數據類型，可以存貯複雜的數據類型
- 注意：雙端隊列並不是半封裝數據類型，牠更傾向於向量，衹是提供了更多角度操作

- #### 遍歷

迭代器：支持八種函數生成隨機訪問迭代器

- #### 初始化

隊列預設大小n deque<int> s(n);
預設大小n並填滿值m deque<int> s(n, m);
使用初始化列表 deque<int> s ={1,2,3,4,5};
使用其他隊列 deque<int> ss(s);
使用迭代器範圍 deque<int> s(it1, it2);

- #### 大小

檢查隊列大小 s.size()     返回整值
檢查隊列最大的大小 s.max_size()  返回整值，數值根據環境而定
檢查隊列是否為空 s.empty()    返回正誤值
更改隊列的大小為n s.resize(n)
無返回值，多出來空間的0填充，少掉的空間將字符串截斷
*重載函數：多出來的用指定的元素填充 s.resize(n,a) 或s.resize(n,100)

- #### 內容

訪問第n位（機器序號）s[n]  或 s.at(n)  
訪問第一位（第0位） s.front() 或 s[0]
訪問最後一位 s.back()  或 s[s.size()-1]

- #### 加入/插入

在隊首加入新元素a s.push_front(a)
在隊尾加入新元素a s.push_back(a)

在第n位（機器序號）之前插入元素a s.insert(s.begin()+n,a);
*重載函數：插入y個相同的元素a s.insert(s.begin()+n,y,a);
用迭代器插入一段 s.insert(s.begin()+n,it1,it2);

- #### 構造加入

emplace()  emplace_front()  emplace_back()
自動調用構造函數 s.emplace_back(a, b); s.push_back({a, b});

- #### 刪除/抽出

刪除隊首元素 s.pop_front()
刪除隊尾元素 s.pop_back()

刪除第n位（機器序號）的元素 s.erase(s.begin()+n);
*重載函數：刪除第x位到第y位的元素
清空 s.clear()  移除隊列中的所有元素

- #### 重新賦值

所有的元素都不要，整體更換新的值
重複賦n個相同的值m s.assign(n, m);
使用迭代器賦值 s.assign(it1,it2)  
使用初始化列表 s.assign({1, 2, 3, 4, 5})

- #### 使用數組模擬

- 从開放性上更接近隊列，只開放兩端的權限
- 从實現上沒有辦法在前面加入，否則直接就有這個結構了

```c++
int q[100];	 // 很大的時候使用向量，然後在初始化的時候改變大小
int u = 0;	  // 隊首指針
int w = -1;	 // 隊尾指針
void init() { u = 0, w = -1; }
void push_back(int i) { q[++w] = i; }
void pop_front() { q[u++] = 0; }	   // 操作之前要檢查：是否為空
void pop_back()  { q[w--] = 0; }	   // 操作之前要檢查：是否為空
int front() { return q[u]; }		   // 操作之前要檢查：是否為空
int back()  { return q[w]; }		   // 操作之前要檢查：是否為空
bool empty() { return u > w; }
```

### map / unordered_map  匚艹鍵值對地圖函數庫

變量名稱為map<type1,type2> t  (u)map通用特性 umap無序特有 map有序特有

| 比較	   | map  映射表						                   | unordered_map  無序映射表			         |
|-------|----------------------------------|---------------------------------|
| 底層實現  | 紅黑樹							                       | CN：ㄏㄕ表 TW：散列表				               |
| 時間複雜度 | `O(log n)`  `1e6->20`			         | 平均`O(1)` 最壞 `O(n)`			           |
| 有序性   | 按照鍵的自然順序進行排序<br/>默認情况下按照鍵的升序排列。  | 沒有特定的順序<br/>插入的順序也不會影響鍵值對的存儲順序。 |
| 查找速度  | 當鍵的數量較小或者鍵的比較操作代價較低時較快		         | 大多數情況下較快						                  |
| 選擇	   | 如果需要有序性，或者對元素的順序有要求，需要遍歷的時候衹能用這個 | 无特殊要求，或對插入、删除和查找操作的性能有較高要求	     |

- #### 遍歷

無序：支持四種函數生成隨機訪問迭代器（不支持四種反向迭代器）
有序：支持八種函數生成隨機訪問迭代器
兩種的迭代器不能互相使用，因為底層的實現是不同的

初始化
使用初始化列表  (u)map<string,int> t = {{"ShuoW",613},{"Horng",210}};
使用其他地圖    (u)map<string> tt(t);
使用迭代器範圍  (u)map<int> t(t.begin(), t.end());
註：祇有完全對應才能賦值，vector不能為(u)map賦值，umap和map不能互相賦值
自定義排序規則 map<int, string, decltype(&cmp)> t(cmp);

內容
使用鍵作為索引訪問值，但是不能使用值來查找鍵 t['Yao']  t.at('Yao')
在這裡裡面不存在的鍵也能被找到，但是就是默認元素
這裡的值是可修改的，也就是加入可以直接使用這個方法
使用鍵作為索引直接賦值如果已經有鍵，就修改裡面的值

加入
t.insert({j,z})  把鍵值對{j,z}插入集合，如果鍵已存在，則不會進行任何操作。
如t = {{"s",613},{"h",210}}; t.insert({"s",614}); s的值不會改變
使用數對的構造函數 t.insert(make_pair({j,z}));
直接構造入集合：j.emplace(j,z)
t1.insert(t2.begin(),t2.end()) 可以實現t1 t2合併
刪除
t.erase(i)   刪除值為i的元素，如果沒有找到，則不會進行任何操作。
t.clear()    清空地圖

尋找
t.count(i) 返回 值為i的數的個數，因為不重複，所以有->1，沒有->0
t.find(i)  返回 值為i的數的迭代器，如果沒有找到就返回end()迭代器
一般衹用於找有沒有這個元素，使用如下代碼 if(j.find(i) != j.end()) {/*有*/}

大小
是否為空 t.empty()  返回正誤值
目前大小 t.size()   返回整值
最大大小 t.max_size()  返回整值，值為常數，依照環境而定

交換 交換兩個集合的全部內容：a.swap(b)

不支持使用sort函數排序，因為排序了，如果要排序，可以使用向量接住再排序vector<pair<int,int>> v(t.begin(), t.end())

特有

有序：和比較有關
t.lower_bound(a) t.upper_bound(a) 用法同algorithm庫中的
t.equal_range(a) 返回一個左閉右開的範圍pair<it, it>，表示在這一段裡面鍵為a
key_comp()  比較鍵的前後
value_comp()  實際上還是比較鍵的前後（理論上考慮整個鍵值對）
auto comp = t.key_comp(); comp(key1, key2)
auto comp = t.value_comp()   comp({ }, { })

無序：和桶有關
t.bucket_count()   桶的數量
t.max_bucket_count()  返回最多的數量，依據環境而定
t.bucket_size(i)  返第i號桶裡面的元素個數
t.bucket(Key)   查詢Key的在哪一個桶裡面

set / unordered_set 匚艹數集函數庫
註：set 和 unordered_set 的區別類似于 map 和 unordered_map 的區別

遍歷、刪除、尋找、大小、交換 同上map
初始化
使用初始化列表  (u)set<string> j = { "Yau","Shuo","Wen" };
使用其他集合    (u)set<string> m(j);
使用迭代器範圍  (u)set<int> j(v.begin(), v.end());

加入
j.insert(i)  把i插入集合，如果該元素已存在，則不會進行任何操作。
直接構造 j.emplace()

多重版本：multimap multiset unordered_multimap unordered_multiset
用法幾乎和原來一樣，祇不過存貯的元素是可重複的
單一版本 多重版本
insert 如果元素存在，插入失敗 仍然插入成功
find 找到元素的位置返回迭代器 找到第一個位置就返回
erase 刪除對應的鍵的內容 刪除對應的鍵的所有內容，如果要删除单个内容，find这个元素，用迭代器删除
count 返回值最多為1 返回值最多

## 實用工具

bitset 匚艹逐位操作函數庫
位運算符（這些運算符是計算機編程通用的，而不是這個庫裡面獨有的，但是和這個庫裡面的內容息息相關，所以記錄在這裡）

位與 a & b
a和b的二進制數字里，兩者每一位的0取交集，有0為0
位或 a | b
a和b的二進制數字里，兩者每一位的1取交集，有1為1
位異或 a ^ b
a和b的二進制數字里，兩者每一位相同為1，不同為0
位非  ~ a
a的二進制數字里，每一位取反（取反範圍取決於該數據類型的大小）
註：因为『位非』反转了二进制表示中的每一位，包括符號位，所以结果通常会是一个负数，要避免這個情況就要使用us.char us.int
等無符號類型，這些類型沒有任何一位表示符號，不會被反轉正負。
左移運算符 <<
n << x 把n的二進制所有位向左移指定的位數。右邊空出的位用0填充。
如 5<<2 為00000101→00010100
實際效果是n變為n*2x迭如本例5→5*22=20
在實際位運算的時候2n可以使用1<<n代替
右移運算符 >>
n >> x 把n的二進制所有位向右移指定的位數。左邊空出的位用0填充。
如 20>>2 為 00010100→00000101
實際效果是n變為n÷2x迭如本例20→20/22=5

所有變量和函數名前面都要統一加std::  除非函數中加了using namespace std;
容器：原子串 bitset<n>  大小為n位的位容器，所有位初始為0
可以用以下方法初始化：
〡 bitset<8> b1(42)  通過整數初始化，初始化的值為42的二進制00101010
〢 bitset<8> b2(string("11001010"))  通過字符串初始化
訪問位可以和數組字符串一樣通過訪問索引訪問，如b[2]，但是這裡的索引和數組和字符串的從左至右的索引方式是不同的，對於bitset<8>
來說，最右邊的索引反而是0，最左邊的反而是7，以下的第某為都是索引序號，注意不要混淆

註：C++的特性，下面講把true/false 和 1/0 混為一談，簡化表達
更改
set(i)  設第i位的值為1
*重載函數 set(i,true/false)  設第i位的值為1或0
reset() 設置第i位的值為0
flip()  翻轉第i位的值（1→0 0→1）

檢查
all()  檢查是否所有位都是1，返回正誤值
any()  檢查是否至少一位是1，返回正誤值
none() 檢查是否沒有一位是1，返回正誤值
count() 檢查是1的位的個數，返回整值
size()  檢查位的數量，返回整值
test(n) 檢查第n位（原子串序號）是不是1，返回正誤值

轉換
to_string()  轉化為字符串，用字符串接收
to_ulong()   轉換為無符號長整數型
to_ullong()  轉換為無符號超長整數型

內建函數
__builtin_clz(x): 計算x的二進制表示中，前導的零的個數
__builtin_ctz(x): 計算x的二進制表示中，尾部的零的個數
__builtin_popcount(x): 計算x的二進制表示中，1的個數
__builtin_parity(x): 計算x的二進制表示中，1的個數的奇偶性（0->偶，1->奇）。
__builtin_ia32_ror(x, n): 對x進行循環右移操作
__builtin_ia32_rol(x, n): 對x進行循環左移操作
一些有用的小代碼模板

1.逐一檢查i的二進制的每一位
for (int j = 0; j < n; ++j)
if ((i & (1 << j)) != 0)
{/*一些操作*/}
2.大數壓位
如果題幹這樣說：由于本題數據較大，因此輸出的時候采用特殊的輸出方式：用
0 或 1 代表每個詢問的答案，將每個詢問的答案依次從左到右排列，把得到的串視爲一個二進制數，輸出這個二進制數除以m的餘數。
結果是 hh=1 或者 hh=0
就這樣寫ans = ((ans * 2) + hh) % m;

找到數組里唯一的數字（其他數字成對出現）
把所有的數字全部異或，結果就是答案，（成對出現的都符合a^a=0，剩下的就是答案）
交換兩個數字（不使用臨時變量）
a ^= b; b ^= a; a ^= b;

	int mask = xorResult & (-xorResult); // 找到最低有效位

異或問題
使用常數時間複雜度求出 0⊕1⊕2⊕3⊕…⊕n
// 簡便寫法
ull xor_n(ull n)
{
unsigned t = n & 3;
if (t & 1) return t / 2u ^ 1;
return t / 2u ^ n;
}

algorithm 匚艹通用演算法函數庫
所有變量和函數名前面都要統一加std::  除非函數中加了using namespace std;
比較
● 返回較大值max(a,b)	  
● 返回較小值min(a,b)
最值更新可以使用這樣的方法 maxA=max(maxA,新的比較值) 替代傳統if語句

以下函數可以使用迭代器查詢數組內的最值
● 區域返回最值對minmax( { … } )  
使用初始化列表作為參數，可以返回數對，first是最小值，second是最大值
如果使用兩個迭代器作為參數，那麼返回迭代器/指針，要使用*解引用得到值

排序   
原版：
sort(it1, it2)  從小到大排序123456
註：字符串的是每一位按照十六進制碼排序，數字<-大寫<-小寫  "12Abab"

「重載」函數：穩定排序
stable_sort(it1, it2) （排序且保留相等元素之間的順序關係）
比如114514 排序之後111445

重載函數：關於升序降序
sort(Arr,Arr+6,less<int>())     由小到大，123456
sort(Arr,Arr+6,greater<int>())  由大到小，654321

「重載」函數：部分排序
將序列中的前k個最小元素放在序列的最前面，而其餘元素的順序不確定。
partial_sort(v.begin(),v.begin() + k,v.end());

使用簡化表達式自定義排序規則
sort(開始位置, 結束位置, [](數組中提取出的待比較元素甲乙的引用&){排序規則})
說明：
1.開始位置和結束位置使用的是迭代器如 v.begin()
2.因為要修改數組元素的值，所以必須要引用 const int& a
3.排序規則: 小於號< 升序排序， 大於號> 降序排序
4.使用簡化表達式可以做到比較的對象和排序的元素分離
例如：要對一個vector<pair<int,int>> xl的數對向量按照每個元素數對的後座標升序排序，應該寫成
sort(xl.begin(),xl.end(),[](const pair<int,int>& a, const pair<int,int>& b) {return a.second < b.second;});

按照pair的規則，可以輕鬆地類推到「按照結構體/組 某元素為基準排序」

穩定排序也是可以用簡化表達式的

二分查找
必須先標準排序 題目是單調的也沒什麼損失
● 在it1~it2範圍內第一個不小於c的元素的位置 lower_bound(it1,it2,c)
即c元素第一次出現的位置
● 在it1~it2範圍內第一個大於c的位置 upper_bound(it1,it2,c)
即c元素最後一次出現的位置的後一個位置
● 在it1~it2範圍內是否有c binary_search(it1,it2,c)
返回正誤型變量（實際上是1 0代表的正確與錯誤）

使用簡化表達式重載
不小於-> 不大於 auto it = upper_bound(it1,it2,c)  if (it != it1) --it;
大於->小於 auto it = lower_bound(it1,it2,c)  if (it != it1) --it;
出現的次數就是 upper-lower
迭代器轉索引：減去begin()
不能判斷有無，所以必須在確保有這個元素的情況下才能查找。如果沒有這個元素，這兩個都會指向大於這個元素的第一個元素的位置
不可以使用greater<int> 重載！

批量檢查
批量檢查所有類型為type的元素it1~it2是否滿足condition條件並且對結果……
〡 『與』計算 all_of (it1, it2,[](type x) {return condition;})
〢 『或』計算 any_of (it1, it2,[](type x) {return condition;})
〣 『與非』計算 none_of(it1, it2,[](type x) {return condition;})
返回正誤型變量（實際上是1 0代表的正確與錯誤）
1.這個不是二分查找，所以不用擔心順序的問題，比如『或』計算就可以尋找是否存在某一個元素（但是效率會低一些，時間複雜度為n）
2.如果想要使用定義在簡化表達式外部的局部變量，必須在捕獲列表（擷取清單）中明確指定它。 [=] 表示通過值捕獲的方式，捕獲所有外部作用域中的變量，
比如要和外部變量WayBuh做比較，必須這樣寫
all_of (s.begin(),s.end(),[=](char x){return x==WayBuh;})

批量操作
1.在it1~it2範圍內調轉字符串/數組方向 reverse(a,b)
2.在a~b範圍內把所有字符/數字c轉換為d replace(a,b,'c','d')
3.在a~b範圍內計數字符c/數字c出現的次數 count(a,b,'c')  返回值為整數類型
4.批量對所有元素it1~it2套用Fx函數 for_each(it1,it2,Fx)

例如每一個元素乘以2
for_each(a.begin(), a.end(), [](int& x) {x = x * 2; });

字典序
● 字典序小於 lexicographical_compare(a.it1, a.it2, b.it3, b.it4)
比較的是a在it1~it2範圍內和b在it3~it4範圍內的詞典序大小，如果a的更小，返回true，如果相等或者b的更小，返回false；
如果應用在字符串比較上，可以比較兩個字符串形式的數的大小，字典序等價於大小
● 全排列的下一位 next_permutation(it1,it2)  只在it1~it2中重新排列
如果排到了排列終點，那麼會將數組恢復到排列起點，并返回false
● 全排列的上一位 prev_permutation(it1,it2)  只在it1~it2中重新排列
如果排到了排列起點，那麼會將數組恢復到排列終點，并返回false

註：
〡全排列函數裏提到的排列起點指升序隊列如{1,2,3}，這是字典序最小的排列方式，排列終點指降序隊列如{3,2,1}，這是字典序最大的排序方式
〢返回的false是當函數用在循環條件的時候用來退出循環的
〣如果序列中有重複元素，全排列函數會去重
刪除重複元素
lengths.erase(unique(lengths.begin(), lengths.end()), lengths.end());

堆
堆可以使用向量來表示，這是維持堆排序的函數，默認是最大堆，也就是堆頂是最大的

● 構建堆 make_heap(it1,it2)  O(n)
把無序數組轉化為堆
● 插入元素 push_heap(it1,it2)  O(log n)
將數組末尾元素安排到正確位置，在這個函數之前配合push_back()加入到末尾
● 删除根節點 pop_heap(it1,it2)    O(log2n)
把根節點元素放在數組最後，其他的重新排列，在這個函數之後配合pop_back删除
● 堆排序 sort_heap(it1,it2)   O(nlog n)
比快速排序穩定
● 是否是堆 is_heap(it1,it2)     O(m)
返回正誤型變量
● 從哪個起不是堆的排序 is_heap_until(it1,it2)  本身滿足會返回end()

所有函數都支持使用greater<int>()重載，重載之後變成最小堆，堆頂最小

utility 匚艹效用元件函數庫
所有變量和函數名前面都要統一加std::  除非函數中加了using namespace std;
容器：數對 pair<type1,type2> D ，其中兩個type是裡面的類型，可以不一樣

初始化
使用構造函數 pair<string,int> z(" ",114514);
使用初始化列表 pair<string,int> x= {" ",114514};
使用make_pair函數 pair<string,int> x= make_pair(" ",114514);
使用其他數對初始化 pair<string,int> y(x);

調用元素
D.first D.second 類似於結構體，祇不過元素名稱固定為這兩個
get<0>(D) get<1>(D)  調用出來的東西既可以操作又可以改變

註：不.first或.second也能使用比較運算符，它會首先比較第一個元素，如果第一個元素相等，則再比較第二個元素。
<br><br><br><br><br>

# 千里之行（基礎算法）

## 王師北定 - 二分法

### 左查詢

尋找滿足某特定條件的最左側元素的常用手段，特別是想要找的是"第一個"滿足條件的元素時。

```c++
int ZuoChar(int l, int r /*要代入的條件*/)
{
	while (l < r)
	{
		int mid = l + r >> 1;
		if (tiaojian(mid))   r = mid; // check()判斷mid是否滿足性質
		else   l = mid + 1;
	}
	return l;
}
```

### 右查詢

適用于尋找滿足某特定條件的最右側元素，特別是當我們想要找的是"最後一個"滿足條件的元素時。

```c++
int YowChar(int l, int r /*要代入的條件*/)
{
	while (l < r)
	{
		int mid = l + r + 1 >> 1;
		if (tiaojian(mid))   l = mid;
		else   r = mid - 1;
	}
	return l;
}

```

### 浮點數二分

```c++
double FD(double l, double r, /*要代入的條件*/)
{
	const double eps = 1e-10;   // eps 表示精度，取决于题目对精度的要求
	while (r - l > eps)
	{
		double mid = (l + r) / 2;
		if (check(mid)) r = mid;
		else l = mid;
	}
	return l;
}
```

## 行伍序齒 - 排序

### 鄰域置換

冒泡算法，時間複雜度`O(n^2)`，不推薦使用

```c++
void PX(int Arr[], int size)
{
	for (int i = 0; i < size - 1; i++)
	{
		for (int j = 0; j < size - 1 - i; j++)
		{
			if (Arr[j] > Arr[j + 1]) swap(Arr[j], Arr[j + 1]);
		}
	}
}
```

### 斷杼擇鄰

選擇排序，時間複雜度`O(n^2)`，不推薦使用

```c++
void PX(int Arr[], int size)
{
	for (int i = 0; i < size - 1; i++)
	{
		int min = i;
		for (int j = i + 1; j < size; j++)
			if (Arr[j] < Arr[min]) min = j;
		if (min != i) 
			swap(Arr[min], Arr[i]);
	}
}
```

### 同舟共濟

// 『插入排序』，應用場景為幾乎已經排好序的情況下，在整齊的條件下複雜度為n，但在混亂的條件下複雜度為n2

```c++
void PX(int Arr[], int size)
{
	for (int i = 1; i < size; i++)
	{
		int temp = Arr[i];
		for (int j = i; j > 0 && Arr[j - 1] > temp; j--)
		{
			Arr[j] = Arr[j - 1];
			Arr[j] = temp;
		}
	}
}
```

### 平分秋色

// 俗稱『快速排序』，平均時間複雜度為 nlog n，最壞情況下為n2

```c++
void PX (int q[], int l, int r)
{
	if (l >= r) return;

	int i = l - 1, j = r + 1, x = q[l + r >> 1];
	while (i < j)
	{
		do i++; while (q[i] < x);
		do j--; while (q[j] > x);
		if (i < j) swap(q[i], q[j]);
	}
	PX (q, l, j), PX (q, j + 1, r);
}
```

### 應機立斷

```c++

// 快速选择算法，找0出數組裏第k小的數（k從1開始）
int HF(vector<int>& arr, int l, int r) // 公用函數：區間劃分函數
{
	int jz = arr[r]; 
	int i = l - 1;  
	for (int j = l; j < r; j++)
		if (arr[j] < jz)  { i++; swap(arr[i], arr[j]); }
	swap(arr[i + 1], arr[r]); 
	return i + 1;  
}
// 找第k小的數的代碼
int KX(vector<int>& arr, int l, int r, int k)
{
	if (l == r) return arr[l]; 
	int p = HF(arr, l, r); 
	int len = p - l + 1; 
	if (k == len) return arr[p];
	else if (k < len)  return KX(arr, l, p - 1, k);
	else return KX(arr, p + 1, r, k - len); 
}
// 找第k大的數的代碼
int KX(vector<int>& arr, int l, int r, int k)
{
	if (l == r) return arr[l];
	int p = HF(arr, l, r);
	int len = p - l + 1;
	int lr = r - p + 1;
	if (k == lr) return arr[p];
	else if (k < lr) return KX(arr, p + 1, r, k);
	else return KX(arr, l, p - 1, k - lr);
}
```

### 殊途同歸

// 『歸併排序』，時間複雜度為 nlog n，需要額外的內存支持

```c++
void PX(vector<int>& q, vector<int>& t, int l, int r)
{
	if (l >= r) return;
	int mid = (l + r) / 2;
	PX(q, t, l, mid);
	PX(q, t, mid + 1, r);
	int i = l, j = mid + 1, k = 0;
	while (i <= mid && j <= r)
	{
		if (q[i] <= q[j]) t[k++] = q[i++];
		else			  t[k++] = q[j++];
	}
	while (i <= mid) t[k++] = q[i++];
	while (j <= r)   t[k++] = q[j++];
	for (int p = 0; p < k; p++) q[l + p] = t[p]; // 將tmp中的元素複製回原數組q中相應的位置
}
```

### 天地無用

// 基於歸併排序求逆序對數量，逆序對的數量就是冒泡排序中交換的次數

```c++
long long PX(vector<int>& q, vector<int>& t, int l, int r)
{
	if (l >= r) return 0;
	long long g = 0;
	int mid = (l + r) / 2;
	g += PX(q, t, l, mid);	// 對左半邊進行遞歸
	g += PX(q, t, mid + 1, r); // 對右半邊進行遞歸

	// 合並左右兩邊，並計算逆序對數量
	int i = l, j = mid + 1, k = l;
	while (i <= mid && j <= r)
	{
		if (q[i] <= q[j])   t[k++] = q[i++];
		else
		{
			t[k++] = q[j++];
			g += (mid - i + 1); // 統計逆序對數量
		}
	}
	while (i <= mid)  t[k++] = q[i++];
	while (j <= r)	t[k++] = q[j++];
	for (i = l; i <= r; i++)  q[i] = t[i]; // 將臨時數組中的元素複製回原數組
	return g;
}
```

## 朝三暮四 - 進制轉換

支持十進制轉為2~無窮進制，只要設置合適的映射參數

```c++
string K = "0123456789ABCDEF"; // 大於16進制還可以往後加GHI……
string JZ(int n, int j) // 整數-待轉換數字   整數-目標進制
{
	if (n == 0) return "0";
	if (n / j == 0) return string(1, K[n % j]);
	else return JZ(n / j, j) + K[n % j];
}
```

// 高精度進制轉換程序

```c++
string JZ(int a, int b, string Y) // 整數-原來進制 整數-目標進制  字符串-待轉換數字
{
	vector<int> n;
	for (auto c: Y)
	{
		if (c >= '0' && c <= '9') n.push_back(c - '0');
		else if (c >= 'A' && c <= 'Z') n.push_back(c - 'A' + 10);
		else if (c >= 'a' && c <= 'z') n.push_back(c - 'a' + 36);
	}
	reverse(n.begin(), n.end());
	vector<int> res;
	while (!n.empty())
	{
		int r = 0;
		for (int i = n.size() - 1; i >= 0; i--)
		{
			n[i] += r * a;
			r = n[i] % b;
			n[i] /= b;
		}
		res.push_back(r);
		while (!n.empty() && n.back() == 0) n.pop_back();
	}
	reverse(res.begin(), res.end());
	string Z;
	/* 按照原來的映射轉換回去即可 */
	return Z;
}
```

## 精於律己 - 高精度計算

### 以和為貴 - 加法

```c++
string Jia(const string &a, const string &b)
{
	int i = a.size() - 1, j = b.size() - 1, jw = 0;
	string c = "";

	while (i >= 0 || j >= 0 || jw)
	{
		int sum = jw;
		if (i >= 0) sum += a[i--] - '0';
		if (j >= 0) sum += b[j--] - '0';
		jw = sum / 10;
		c += to_string(sum % 10);
	}
	reverse(c.begin(), c.end());
	return c;
}
```

### 勤減養德 - 減法

```c++
string Jean(const string &a, const string &b)
{
	bool z = true;
	string l = a, s = b;
	if (a.size() < b.size() || (a.size() == b.size() && a < b))
		l = b, s = a, z = false;
	string c;
	int t = 0, i = l.size() - 1, j = s.size() - 1;
	while (i >= 0 || j >= 0 || t)
	{
		int li = i >= 0 ? l[i--] - '0' : 0;
		int si = j >= 0 ? s[j--] - '0' : 0;
		t = li - si - t;
		if (t < 0)
		{
			t += 10;
			c.push_back(t + '0');
			t = 1;
		}
		else
		{
			c.push_back(t + '0');
			t = 0;
		}
	}
	while (c.size() > 1 && c.back() == '0') c.pop_back();
	reverse(c.begin(), c.end());
	if (!z) c = "-" + c;

	return c;
}
```

### 乘實立身 - 乘法

- #### 掃屋企（字符串 × 整數 = 字符串）

```c++
string Cherng(string a, int b)
{
	if (b == 0) return "0"; 
	int n = a.size();
	string c(n, '0'); 
	int jw = 0; 
	for (int i = n - 1; i >= 0; --i)
	{
		int w = (a[i] - '0') * b + jw; 
		c[i] = (w % 10) + '0'; 
		jw = w / 10;
	}
	if (jw > 0)  c = to_string(jw) + c;
	int qdl = c.find_first_not_of('0');
	if (qdl != string::npos) 
		return c.substr(qdl);

	return "0"; 
}
```

- #### 觀天下（字符串 × 字符串 = 字符串）

```c++
string Cherng(string a, string b) 
{
	if (a == "0" || b == "0") return "0"; 

	vector<int> A(a.rbegin(), a.rend()), B(b.rbegin(), b.rend());
	for (auto& S : A) S -= '0'; 
	for (auto& S : B) S -= '0';

	vector<int> C(A.size() + B.size(), 0);

	for (size_t i = 0; i < A.size(); ++i) 
	{
		for (size_t j = 0; j < B.size(); ++j)
		{
			C[i + j] += A[i] * B[j];
			C[i + j + 1] += C[i + j] / 10; 
			C[i + j] %= 10;
		}
	}
	while (C.size() > 1 && C.back() == 0) C.pop_back();

	string CC(C.size(), '0');
	transform(C.rbegin(), C.rend(), CC.begin(), [](int d) { return d + '0'; });

	return CC;
}
```

### 差之毫釐 - 除法

- #### 左右開弓（字符串 ÷ 整數 = 字符串）

```c++
pair<string, int> Chwu(string a, int b)
{
	vector<int> C;
	int r = 0;
	for (char num: a)
	{
		r = r * 10 + (num - '0');
		C.push_back(r / b);
		r %= b;
	}
	string ans;
	bool lz = true;
	for (int num: C)
	{
		if (num != 0 || !lz)
		{
			ans.push_back('0' + num);
			lz = false;
		}
	}
	if (ans.empty()) ans = "0";
	return make_pair(ans, r);
}
```

魚和熊掌（雙串轉串）

```c++
// 無負數的高精度減法程序
string Jean(const string &a, const string &b)
{
	string C = a;
	int Jie = 0;
	for (int i = 0; i < C.size(); i++)
	{
		int A = C[C.size() - 1 - i] - '0';
		int B = (i < b.size()) ? (b[b.size() - 1 - i] - '0') : 0;
		A -= B + Jie;
		if (A < 0)
		{
			A += 10;
			Jie = 1;
		}
		else Jie = 0;
		C[C.size() - 1 - i] = A + '0';
	}
	size_t it = C.find_first_not_of('0');
	if (it != string::npos) return C.substr(it);

	return "0";
}

pair<string, string> Chwu(const string &a, const string &b)
{
	string c = "";
	string d = "0";
	for (char Shuh: a)
	{
		d = (d == "0") ? string(1, Shuh) : (d + Shuh);
		int jw = 0;

		while (d.size() > b.size() || (d.size() == b.size() && d >= b))
		{
			d = Jean(d, b);
			jw++;
		}
		c += (jw + '0');
	}

	c = c.find_first_not_of('0') == string::npos ? "0" : c.substr(c.find_first_not_of('0'));
	return {c, d};
}
```

```c++


```

### 雪中送炭 - 茶語外掛

| 功能   | 寫法						                  | 說明				              |
|------|---------------------------|---------------------|
| 加法   | `a.add(b)`				            | 					               |
| 減法   | `a.subtract(b)`		         | 					               |
| 乘法   | `a.multiply(b)`		         | 					               |
| 除法   | `a.divide(b)`			          | 					               |
| 取餘   | `a.remainder(b)/a.mod(b)` | 					               |
| 捆綁商餘 | `a.divideAndRemainder(b)` | 返回大整數數組，第0位是商，第1位是餘 |
| 絕對值  | `a.abs()`				             | 					               |
| 相反數  | `a.negate()`			           | 					               |
| 求冪   | `a.pow(b)`				            | `b`是整數			           |
| 快速冪  | `a.modPow(b,m)`		         | 					               |
| 較大值  | 						                    | 					               |
| 較大值  | 						                    | 					               |
| 較小值  | 						                    | 					               |
| 比較   | 						                    | 					               |
| 相等   | 						                    | 					               |
| 正負   | 						                    | 					               |
| 	    | 						                    | 					               |

導包：import java.math.BigInteger;
默認參數和返回值類型為大整數，需要特殊注意的數據類型使用->指出

基礎運算

a.max(b) 較小值a.min(b)   比較a.compareTo(b)   -1: a<b 0: a=b 1: a>1
相等 a.equals(b)   返回正誤值 正負 a.signum()   -1:負數 0:零 1:正數

位運算和二進制
左移 a.shiftLeft(n->int)  左移動n位（乘法）
右移 a.shiftRight(n->int) 右移動n位（除法）
按位與 a.and(b)     按位或 a.or(b)     按位异或a.xor(b)
按位與非a.andNot(b)   按位取反 a.not()
指定位清零 a.clearBit(n->int)   指定位設一 a.setBit(n->int)    指定位翻轉 a.flipBit(n->int)
檢查這一位是否為一 a.testBit(n->int) 返回正誤值
二進制補碼 a.toByteArray()  返回字節數組byte[]
補碼中不包括符號位的位數 a.bitLength()   補碼中和符號位不同的位數 a.bitCount()
第一個不為零的索引 a.getLowestSetBit()     散列碼 a.hashCode()

轉換
數字轉大整數 a.valueOf(n->long)  int等的會隱式轉換，所以一個就夠了
轉整數int a.intValue() / a.intValueExact()
轉長整數long a.longValue() / a.longValueExact()
轉短整數short a.shortValueExact()
轉超短整數byte a.byteValueExact()
轉單精度浮點數float a.floatValue()
轉雙精度浮點數double a.doubleValue()
轉字符串數a.toString()  重載函數：a.toString(n->int) 這個字符串數的進制為n（2<=n<=36）

數學知識
最大公因數 a.gcd(b)
質數 a.isProbablePrime(n)  true：可能是質數，false：肯定是合數，參數n為可信度，可以取為100
下一個可能的質數 a.nextProbablePrime()
一個二進制長度為n的可能的質數 probablePrime(n->int , Random rnd)
乘法逆元 a.modInverse(b)     (a * x) % m = 1 返回x

```
差之毫釐
（串整轉串）
pair<string, int> Chwu(string a, int b)
{
	vector<int> C;
	int r = 0;
	for (char num : a)
	{
		r = r * 10 + (num - '0');
		C.push_back(r / b);
		r %= b;
	}
	string ans;
	bool lz = true;
	for (int num : C)
	{
		if (num != 0 || !lz)
		{
			ans.push_back('0' + num);
			lz = false;
		}
	}
	if (ans.empty()) ans = "0";
	return make_pair(ans, r);
}





階桺庭花
string JieCheng(int n) 
{
	if (n == 1)   return "1";
	vector<int> res(1, 1); 
	for (int i = 2; i <= n; ++i) 
	{
		int jw = 0;
		for (auto& d: res)
		{
			int p = d * i + jw;
			d = p % 10;
			jw = p / 10;
		}
		while (jw) 
		{ 
			res.push_back(jw % 10);
			jw /= 10;
		}
	} return vtostr(res); // 將結果從向量轉換為字符串，過程略
}

各有千秋
// 比較兩個『字符串』形式的的數的大小
int bi(string a, string b)
{
	if (a.size() != b.size())   return a.size() > b.size() ? 1 : -1;
	for (size_t i = 0; i < a.size(); i++)
		if (a[i] != b[i])   return a[i] > b[i] ? 1 : -1;
	return 0;
}// a<b  -1   a>b 1   a=b 0

雪中送炭


```

<br><br><br><br><br>

# 端尺區穴（幾何）

## 精打細算 - 常量和浮點數

定義常量

```c++
const double jd = 1e-8;// 比較精度
const double pi = acos(-1.0);// 圓周率
const double inf = 1e20;
```

浮點數的近似比較大小

```c++
#include <cmath>
int cmp(double x, double y)
{
	if (fabs(x - y) < jd) return 0;
	else return x < y ? -1 : 1;// x<y -1 x>y  1
}
```

浮點數的近似正負零

```c++
#include <cmath>
int cmp(double x)
{
	if (fabs(x) < jd) return 0;
	else return x < 0 ? -1 : 1;// x<0 -1 x>0  1
}
```

浮點數切割

```c++
double cut(double x, int n) // n為保留的小數點後的位數
{
	double m = pow(10.0, n);
	return round(x * m) / m;// 這裡的取整方式可以改變
}
```

## 端 - 點/向量

```c++
struct pnt  // 點和向量共用，因為向量也可以用(x,y)表示
{
	double x, y;
	pnt() {}
	pnt(double x, double y) : x(x), y(y) {}
	// 以下是用點定義的向量的運算，代碼量比較大，用哪些寫哪些
	pnt operator+(pnt b) { return pnt(x + b.x, y + b.y); }
	pnt operator-(pnt b) { return pnt(x - b.x, y - b.y); }
	pnt operator*(double k) { return pnt(x * k, y * k); }
	pnt operator/(double k) { return pnt(x / k, y / k); }
	bool operator==(pnt b) { return cmp(x, b.x) == 0 && cmp(y, b.y) == 0; }
	bool operator<(const pnt& b){return cmp(x, b.x)<0||(cmp(x,b.x)==0 && cmp(y, b.y) < 0);}
};
// 這兩個和上面的<重載用於對點排序，以下兩個不常用，平時不用寫
bool cmpy(pnt a, pnt b) { return cmp(a.y - b.y) < 0; } // 只對 y 座標排序
bool cmpx(pnt a, pnt b) { return cmp(a.x - b.x) < 0; } // 只對 x 座標排序
```

```

端



兩點之間的距離
// 直線距離（勾股定理距離）
double p2pdis(pnt a, pnt b) { return hypot(a.x - b.x, a.y - b.y); }
// 座標軸距离（曼哈頓出租車距離）
double p2pdism(pnt a, pnt b) { return fabs(a.x - b.x) + fabs(a.y - b.y); }
// 單位向量
pnt normal(pnt a) { return pnt(-a.y / len(a), a.x / len(a)); }

向量點積
double dot(pnt a, pnt b) { return a.x * b.x + a.y * b.y; }
// 向量長度
double len(pnt a) { return sqrt(dot(a, a)); }
// 向量長度的平方（减少浮點運算）
double len2(pnt a) { return dot(a, a); }
// 向量A B的夾角
double angle(pnt a, pnt b) { return acos(dot(a, b) / len(a) / len(b)); }

向量叉積
double cross(pnt a, pnt b) { return a.x * b.y - a.y * b.x; }
// ABC和另一個點構成的平行四邊形的面積
double area(pnt a, pnt b, pnt c) 
{ return cross(b - a, c - a); }// abc三點求三角形面積就是/2
// 平行/重合
bool paralel(pnt a, pnt b) { return cmp(cross(a, b)) == 0; 
// 向量A B的夹角(另一種寫法)
double angle_(pnt a, pnt b)
{ return abs(atan2(abs(cross(a, b)), a.x * b.x + a.y * b.y)); }

旋轉
// 向量逆時針旋轉rad
pnt rotate(pnt a, double rad) 
{
	return  pnt(a.x * cos(rad) - a.y * sin(rad), 
a.x * sin(rad) + a.y * cos(rad)); 
}
// a繞b逆时针旋转rad
pnt rotate(pnt a, pnt b, double rad)
{
	return { (a.x - b.x) * cos(rad) - (a.y - b.y) * sin(rad) + b.x,
			(a.x - b.x) * sin(rad) + (a.y - b.y) * cos(rad) + b.y };
}

最近點對
pnt p[N], t[N];
double p2pclose(int l, int r)
{
	double dis = inf;
	if (l == r) return dis;
	if (l + 1 == r) return p2pdis(p[l], p[r]);
	int mid = (l + r) / 2;
	double d1 = p2pclose(l, mid);
	double d2 = p2pclose(mid + 1, r);
	dis = min(d1, d2);
	int k = 0;
	for (int i = l; i <= r; i++) if (fabs(p[mid].x - p[i].x) <= dis)  t[k++] = p[i];
	sort(t, t + k, cmpy);
	for (int i = 0; i < k; i++)
		for (int j = i + 1; j < k; j++)
		{
			if (t[j].y - t[i].y >= dis)  break;
			dis = min(dis, p2pdis(t[i], t[j]));
		}
	return dis;
}
調用前  sort(p, p + n);// 這裡是正常排序：先對x再對y，所以沒有比較函數
調用	p2pclose(0, n - 1)
 
尺
struct line  // 直線和線段公用，在直線中p1p2為兩個普通的點，在線段上為端點
{
public:
	pnt p1, p2;
	line() {}
	line(pnt p1, pnt p2) :p1(p1), p2(p2) {}// 兩點式
	line(pnt p, double angle)// 點斜式
	{
		p1 = p;
		if (cmp(angle, pi / 2) == 0)  p2 = p1 + pnt(0, 1);
		else p2 = p1 + pnt(1, tan(angle));
	}
	line(double a, double b, double c)// 標準式ax+by+c=0
	{
		if (cmp(a) == 0)
		{
			p1 = pnt(0, -c / b); p2 = pnt(1, -c / b);
		}
		else if (cmp(b) == 0)
		{
			p1 = pnt(-c / a, 0); p2 = pnt(-c / a, 1);
		}
		else
		{
			p1 = pnt(0, -c / b); p2 = pnt(1, (-c - a) / b);
		}
	}
};

三點是否共線|點在直線上
bool ppp(pnt a, pnt b, pnt c)
{
	return cmp((a.y - b.y) * (b.x - c.x), (a.x - b.x) * (b.y - c.y)) == 0;
}

點和直線的位置關係
int p2lrea(pnt p, line v)
{
	int c = cmp(cross(p - v.p1, v.p2 - v.p1));
	if (c < 0) return 1;// p在v左側
	if (c > 0) return 2;// p在v右側
	return 0;// p在v上
}

點到直線的距離
double p2ldis(pnt p, line v) 
{ return fabs(cross(p - v.p1, v.p2 - v.p1)) / p2pdis(v.p1, v.p2); }

點在直線上的投影點
pnt p2lpro(pnt p, line v)
{
	double k = dot(v.p2 - v.p1, p - v.p1) / len2(v.p2 - v.p1);;
	return v.p1 + (v.p2 - v.p1) * k;
}

點關於直線的對稱點
pnt plp(pnt p, line v)
{
	pnt q = p2lpro(p, v);
	return pnt(2 * q.x - p.x, 2 * q.y - p.y);
}

兩條直線的位置關係
int llrea(line v1, line v2)
{
	if (cmp(cross(v1.p2 - v1.p1, v2.p2 - v2.p1)) == 0)
		if (p2lrea(v1.p1, v2) == 0) return 1;// 重合
		else return 0;// 平行
	return 2;// 相交
}

兩直線交點
pnt lpl(pnt a, pnt b, pnt c, pnt d) // 前提要保證要相交
{
	double s1 = cross(b - a, c - a);
	double s2 = cross(b - a, d - a);
	return pnt(c.x * s2 - d.x * s1, c.y * s2 - d.y * s1) / (s2 - s1);
}

點和線段的位置關係
int p2srea(pnt p, line v)
{
	return cmp(cross(p - v.p1, v.p2 - v.p1)) == 0 && cmp(dot(p - v.p1, p - v.p2)) <= 0;
}// 0不在線段上  1在線段上

點到線段的距離
// 投影在線段上，就是圖中的直邊框，求點線距離就可以（p2ldis）
// 不在線段上，就是圖中的圓邊框，最短距離就是更靠近的那個端點的距離（p2pdis）
double p2sdis(pnt p, line v) 
{
	if (cmp(dot(p - v.p1, v.p2 - v.p1)) < 0 || cmp(dot(p - v.p2, v.p1 - v.p2)) < 0)
		return min(p2pdis(p, v.p1), p2pdis(p, v.p2));
	return p2ldis(p, v);
}

兩條線段是否相交
bool ssrea(pnt a, pnt b, pnt c, pnt d)
{
	double c1 = cross(b - a, c - a), c2 = cross(b - a, d - a);
	double d1 = cross(d - c, a - c), d2 = cross(d - c, b - c);
	return cmp(c1) * cmp(c2) < 0 && cmp(d1) * cmp(d2) < 0;
}// 1 相交  0不相交

兩條線段的交點
pnt sps(pnt a, pnt b, pnt c, pnt d) // 前提要保證要相交，直接轉化為直線的交點
{  return lpl(a, b, c, d);  }

線段的中垂線
line spl(pnt p1, pnt p2) 
{  pnt h = (p1 + p2) / 2;   return { h, h + rotate(p2 - p1, pi / 2) };  }
 
區
楔
// 三角形重心：三條中線的交點
pnt corcen(pnt p1, pnt p2, pnt p3)
{
	return (p1 + p2 + p3) / 3.0;
}

// 三角形內心：三條角平分線交點，內切圓圓心
pnt incen(pnt p1, pnt p2, pnt p3)
{
	double d1 = len(p2 - p3);
	double d2 = len(p1 - p3);
	double d3 = len(p1 - p2);
	return (p1 * d1 + p2 * d2 + p3 * d3) / (d1 + d2 + d3);
}

// 三角形垂心：三條高的交點
pnt ortcen(pnt p1, pnt p2, pnt p3)// 模擬，通過旋轉找出兩條高，求交點
{
	pnt u = p1 + rotate(p2 - p3, pi / 2);
	pnt v = p2 + rotate(p1 - p3, pi / 2);
	return lpl(p1, u, p2, v);
}

// 外心：三邊垂直平分線交點，外接圓圓心
pnt circen(pnt p1, pnt p2, pnt p3)
{
	pnt h = (p1 + p2) / 2;// 中點
	pnt m = (p2 + p3) / 2;
	pnt u = h + rotate(p2 - p1, pi / 2);// 旋轉得到垂平線
	pnt v = m + rotate(p3 - p2, pi / 2);
	return lpl(h, u, m, v);
}

形
使用切割法求多邊形面積
double poS(vector<pnt> p, int n)
{
	double S = 0;
	for (int i = 0; i < n; i++)
		S += cross(p[i], p[(i + 1) % n]);
	return fabs(S / 2);
}

使用射線法判斷點和多邊形的位置關係
int p2porea(pnt pt, vector<pnt> p, int n)
{
	for (int i = 0; i < n; i++)
		if (p[i] == pt)  return 3;// 3 在頂點上
	for (int i = 0; i < n; i++)
	{
		line v = line(p[i], p[(i + 1) % n]);
		if (p2srea(pt, v)) return 2;// 2 在邊上
	} 
	int num = 0;
	for (int i = 0; i < n; i++)
	{
		int j = (i + 1) % n;
		int c = cmp(cross(pt - p[j], p[i] - p[j]));
		int u = cmp(p[i].y - pt.y);
		int v = cmp(p[j].y - pt.y);
		if (c > 0 && u < 0 && v >= 0) num++;
		if (c < 0 && u >= 0 && v < 0) num--;
	}
	return num != 0;// 1 內部 0外部
}

拓展：判斷線段是否在任意多邊形內部，就判斷線段和多邊形的邊界不相交 ssrea()，並且兩端點都在多邊形內部




// 使用切割法求多邊形重心
pnt pocen(vector<pnt> p, int n)
{
	pnt ans(0, 0);
	double S = poS(p, n);
	if (cmp(S) == 0) return ans;
	for (int i = 0; i < n; i++) 
	{
		ans=ans+(p[i] + p[(i + 1) % n])*cross(p[i], p[(i + 1) % n]);
	}
	return ans / S / 6;
}


判斷四個點能否組成矩形/正方形


// 旋轉卡殼


 
格
格紙定理（Pick定理）：
整點：橫縱座標都是整數的點
當一個多邊形所有的頂點都是整點，
n是多邊形內部的整點數（不包括），s表示多邊形邊界上的整點數（包括頂點） 面積公式：S=n+s/2-1
當一條線段的兩個端點是整點，在線段上的點數為gcd(|x1-x2|,|y1-y2|)+1

int onpo(vector<pnt> p) // 多邊形上點的個數
{ 
	int n = p.size(), ans = 0;
	for (int i = 0; i < n; i++)
	{
		auto a = p[i], b = p[(i + 1) % n];
		ans += gys(fabs(a.x - b.x), fabs(a.y - b.y));
	}
	return ans;
}

int inpo(vector<pnt> p) // 多邊形內點的個數
{ 
	int n = p.size(), ans = 0;
	for (int i = 0; i < n; i++)
	{
		auto a = p[i], b = p[(i + 1) % n], c = p[(i + 2) % n];
		ans += b.y * (a.x - c.x);
	}
	return (abs(ans)- onpo(p)) / 2 + 1;
}
 
圜
struct circle
{
	pnt c;
	double r;
	circle();
	circle(pnt c, double r) :c(c), r(r) {}
	circle(double x, double y, double r) { this->r = r; c = pnt(x, y); }
};

// 點和圓的位置關係
int p2crea(pnt p, circle C)
{
	double dis = p2pdis(p, C.c);
	if (cmp(dis, C.r) == -1) return 0;// 圓內
	if (cmp(dis, C.r) == 0) return 1;// 圓上
	return 2;// 圓外
}

// 直線和圓的位置關係
int l2crea(line l, circle C)
{
	double dis = p2ldis(C.c, l);
	if (cmp(dis, C.r) == -1) return 0;// 相交
	if (cmp(dis, C.r) == 0) return 1;// 相切
	return 2;// 相離
}

// 線段和圓的位置關係
int s2crea(line s,circle C)
{
	double dis = p2sdis(C.c, s);
	if (cmp(dis, C.r) == -1) return 0;// 部分或全部在圓內
	if (cmp(dis, C.r) == 0) return 1;// 相切
	return 2;// 圓外
}

// 直線和圓的交點，交點用引用傳參，返回值為個數
int lpc(line v, circle C, pnt& a, pnt& b)
{
	if (l2crea(v, C) == 2) return 0;// 相離 0
	pnt q = p2lpro(C.c, v);
	double d = p2ldis(C.c, v);
	double k = sqrt(C.r * C.r - d * d);
	if (cmp(k) == 0) { a = q, b = q; return 1; }// 相切 1，返回的兩個點相同
	pnt n = (v.p2 - v.p1) / len(v.p2 - v.p1);
	a = q + n * k, b = q - n * k;
	return 2;// 相交 2
}

// 三點確定的圓心
pnt pppc(pnt a, pnt b, pnt c)
{
	pnt cen;
	double a1 = b.x - a.x, b1 = b.y - a.y, c1 = (a1 * a1 + b1 * b1) / 2;
	double a2 = c.x - a.x, b2 = c.y - a.y, c2 = (a2 * a2 + b2 * b2) / 2;
	double d = a1 * b2 - a2 * b1;
	cen.x = a.x + (c1 * b2 - c2 * b1) / d;
	cen.y = a.y + (a1 * c2 - a2 * c1) / d;
	return cen;
}

拓展：
1.點到圓的最近點，及最短距離
	當他和圓心重合的時候有無數多解；其他情況下，和圓心連線的直線和圓的交點lpc()，計算兩點到點的距離，更小的那一個就是最近點，計算出的答案就是最短距離



// 最小圓覆蓋（基礎款）
#include <algorithm>
#include <random>  // 打亂函數，越亂越快
circle minc(vector<pnt>& p, int n)
{
	pnt c;  double r;
	random_device rd;
	mt19937 g(rd());
	shuffle(p.begin(), p.end(), g);
	c = p[0];  r = 0;
	for (int i = 1; i < n; i++)
	{
		if (cmp(p2pdis(p[i], c), r) == 1)
		{
			c = p[i];  r = 0;
			for (int j = 0; j < i; ++j)
			{
				if (cmp(p2pdis(p[j], c), r) == 1)
				{
					c.x = (p[i].x + p[j].x) / 2;
					c.y = (p[i].y + p[j].y) / 2;
					r = p2pdis(p[j], c);
					for (int k = 0; k < j; ++k)
					{
						if (cmp(p2pdis(p[k], c), r) == 1)
						{
							c = pppc(p[i], p[j], p[k]);
							r = p2pdis(p[i], c);
						}
					}
				}
			}
		}
	}
	return { c, r };
}
```

<br><br><br><br><br>

# 海納百川（數論）

### 通用代碼

```c++
//我一個信奧賽的同學把這句話掛在嘴邊上，并用了他大半個生涯對付卡常數
#define ll long long
#define int long long
```

## 步步為營 - 大數運算

### 避免溢出的乘法

1. 外掛法
   ```c++
   int cheng(int a, int b, int m) { return (__int128) a * b % m; }
   ```
2. 循環法
   ```c++
   int cheng(int a, int b, int m)
   {
       int c = 0;
       a %= m, b %= m;
       while (b > 0)
       {
           if (b % 2 == 1) c = (c + a) % m;
           a = (a * 2) % m;
           b >>= 1;
       }
       return c;
   }
   ```
3. 遞歸法
   ```c++
   int cheng(int a, int b, int m)
   {
       int r = a * b - m * (int) (1.L / m * a * b);
       return r - m * (r >= m) + m * (r < 0);
   }
   ```

### 快速冪

1. 當循環
   ```c++
   int KSM(int d, int j, int c)
   {
       int y = 1;// 餘數
       d %= c;
       while (j)
       {
           if (j & 1) y = y * d % c;
           d = d * d % c;
           j >>= 1;
       }
       return y;
   }
   ```
2. 次循環
   ```c++
   int KSM(int d, int j, int c)
   {
       int y = 1;
       for (; j; j >>= 1, d = d * d % c)
       {
           if (j & 1) y = y * d % c;
       }
       return y;
   }
   ```

## 黨同伐異 - 公因數和公倍數

### 最大公因數(Greatest Common Divisor, GCD)

#### 1. 輾轉相除法（循環）

    - 優點：時間複雜度低
    - 缺點：在高精度運算取餘數費時間

   ```c++
   int gys(int a, int b)
   {
       while (b) int t = b, b = a % b, a = t;
       return a;
   }
   ```

#### 2. 輾轉相除法（遞歸）

    - 優點：寫起來極其簡單
    - 缺點：可能會爆棧

   ```c++
   int gys(int a, int b)
   {
       return b ? gys(b, a % b) : a;
   }
   ```

#### 3. 更相減損術

    - 優點：不需要取餘數
    - 缺點：循環次數比前者多很多

   ```c++
   int gys(int a, int b)
   {
       while (a != b)  a > b ? a -= b : b -= a;
       return a;
   }
   ```

#### 4. 內置函數`<algorithm>` 裡的 `__gcd()`

### 最小公倍數(Lowest Common Multiple, LCM)

> 計算公式
> - 最小公倍數 = 兩數乘積 / 最大公因數
> - `LCM(a, b) = a * b / GCD(a, b)`

```c++
int gbs(int a, int b)
{
    return (a / gys(a, b)) * b;
}
```

### 擴展結論

1. 多個數的公因數和公倍數可以逐對計算
    - `GCD(a,b,c,d,e,…)=GCD(GCD(GCD(GCD(a,b),c),d),e,…)`
    - `LCM(a,b,c,d,e,…)=LCM(LCM(LCM(LCM(a,b),c),d),e,…)`

2. 已知公因數和公倍數，求兩個數的各種組合
    - 首先要判斷這個所謂的公因數和公倍數合不合法，如果公倍數無法被公因數整除，說明這組數據不合法
    - 設兩個數為a,b， a=gcd*① b=gcd*② 根據公因數的性質，①*②互質，公倍數gcd*①*②
    - 根據等式`a*b=lcm*gcd;`   加上上面的代換，得到等式`①*②=lcm/gcd`
    - 所以衹要嘗試所有滿足這兩個條件的數字：①*②=lcm/gcd ① ②互質，乘以gcd就得到原數

3. 배촉定理
   對於兩數a b，要求兩整數x y滿足條件a*x+b*y最小，則最小值為GCD(|a|,|b|)
   對於一系列數字Ai，要求要求一系列數字Xi滿足∑ Ai*Xi最小，則最小值為Ai多個數的GCD
   绝对值！代码中要取绝对值！

### 通分/約分

分數通分小程序，`z1/m1`和`z2/m2`

```c++
int lcm = gbs(m1, m2);
z1 *= lcm / m1;
z2 *= lcm / m2;
m1 = m2 = lcm;
```

分數約分小程序，`z/m`

```c++
int te = gys(z, m);
z /= te; m /= te;
```

## 數根萬物 - 質數

### 多謀善斷 - 判斷質數

#### 簡單判斷

```c++
bool Zhyh(int n)  // false 合 , true 質
{
	if (n <= 1) return false;
	for (int i = 2; i * i <= n; ++i)
		if (n % i == 0) return false;
	return true;
}
```

#### 經過常數優化的試除法

複雜度係數降為上面的1/3

```c++
bool Zhyh(int n)
{
	if (n < 2) return false;
	if (n == 2 || n == 3) return true;
	if (n % 6 != 1 && n % 6 != 5) return false;
	for (int i = 5, j = n / i; i <= j; i += 6)
		if (n % i == 0 || n % (i + 2) == 0)  return false;
	return true;
}
```

### 差強人意

- 利用素性判斷算法判斷質數（`Miinter-Rabin` 素性测试）  [（例題）](https://www.luogu.com.cn/problem/P10404)
- 時間複雜度為`O(4*log^3(n))`

```c++
int cheng(int a, int b, int m)  大數取餘乘法函數
int KSM(int d, int j, int c)   快速冪

bool MR(int n)
{
	if (n < 3 || n % 2 == 0) return n == 2;// 特判
	int u = n - 1, t = 0;
	while (u % 2 == 0) u /= 2, ++t;
	int ud[] = { 28178, 9780504 };
	for (auto i : ud)
	{
		int v = KSM(i, u, n);
		if (v == 1 || v == n - 1 || v == 0) continue;
		for (int j = 1; j <= t; j++)
		{
			v = cheng(v, v, n);
			if (v == n - 1 && j != t)
			{
				v = 1;
				break;
			}// 出現一個n-1，後面都是1，直接跳出
			if (v == 1) return 0;// 這裏代表前面沒有出現n-1這個解，二次檢驗失敗
		}
		if (v != 1) return 0;// Fermat檢驗
	}
	return 1;
}

// 加上下面這一段，并使用isprime來調用，這樣可以剪枝優化
int Zhyh[28] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107 };
bool isprime(int n)
{
	for (int i = 0; i < 28 && Zhyh[i] * Zhyh[i] <= n; ++i)
		if (n % Zhyh[i] == 0) return false;
	if (!MR(n)) return false;
	return true;
}
```

## 吹盡狂沙 - 質數篩選

- 公共部分如下：兩個表記得充分利用，找的時候用數組，查的時候用散列

```c++
#define N 10000000  
int Zhyh[N];   // Zhyh[]存儲所有素數
int Geh;       // Geh為質數個數
bool st[N];    // st[x]存儲x是否被篩掉
```

### 平平無奇

| 算法名稱 | 時間複雜度       | 原理                   |
|------|-------------|----------------------|
| 樸素篩法 | `n*sqrt(n)` | 檢查每一個數是否能被他平方根以下的數整除 |

```c++
void SZS(int n)
{
    for (int i = 2; i <= n; i++)
    {
        bool is = true;
        for (int j = 2; j * j <= i; j++)
            if (i % j == 0)
            {
                is = false;
                break;
            }
        if (is) Zhyh[Geh++] = i;
        else st[i] = true;
    }
    st[0] = true;
    st[1] = true;
}
```

### 有則改之

| 算法名稱 | 時間複雜度         | 原理                 |
|------|---------------|--------------------|
| ㄞ氏篩  | `n*ln(ln(n))` | 在遍歷的時候把每一個數的所有倍數刪除 |

```c++
void SZS(int n)
{
    for (int i = 2; i <= n; i++)
    {
        if (!st[i])
        {
            Zhyh[Geh++] = i;
            for (int j = i + i; j <= n; j += i) st[j] = true;
        }
    }
    st[0] = true;
    st[1] = true;
}
```

### 千絲萬縷

| 算法名稱 | 時間複雜度 | 原理 |
|------|-------|----|
| ㄛㄌ篩  | `n`   |    |

```c++
void SZS(int n)
{
    for (int i = 2; i <= n; i++)
    {
        if (!st[i]) Zhyh[Geh++] = i;
        for (int j = 0; Zhyh[j] <= n / i; j++)
        {
            st[Zhyh[j] * i] = true;
            if (i % Zhyh[j] == 0) break;
        }
    }
    st[0] = true;
    st[1] = true;
}
```

### 乘奔禦風

// l和r較大，但是l和r相差不大的情況下，使用sqrt(r)以下的數字篩選，如要求[1000w,1100w]之間的質數個數

```c++
int qj(int l, int r)
{
    SZS(sqrt(r) + 10); // 多次查詢的話一次篩選就可以了
    vector<bool> s(r - l + 10, false); // s[idx]的位置實際上裝的是idx+l的真值

    for (int i = 0; i < Geh; ++i)
    {
        int now = Zhyh[i];
        if (now * now > r) break;
        int start = ceil((double) l / double(now)) * now;
        for (int j = start; j <= r; j += now)
            if (j != now && j != 1) s[j - l] = true;
    }
    int ans = 0;
    for (int i = 0; i <= r - l; i++)
        if (!s[i] && i - l != 1) ans++;
    return ans;
}
```

## 求同存異 - 因數

```c++
因數和和因數有關的問題
// 求一個數的所有因數，時間複雜度為sqrt(n)*log(n)
void yueshu(ll n)
{
	vector<int> x;
	for (int i = 1; i * i <= n; ++i)
		if (n % i == 0)
		{
			if (i * i != n)  x.push_back(i);
			x.push_back(n / i);
		}
	sort(x.begin(), x.end());  // 到此，向量x即為所求
}
```

```c++
// 求1~n之間的所有因數，複雜度為nlogn
const int N = 1e5 + 7;
vector<int> f[N]; // 這裡不是vector<int> f(N)
void dvd(int n)
{
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n / i; ++j)
            f[i * j].push_back(i);
}// f[x]存貯了x的所有因數
```

## 庖丁解牛 - 質因數

// 分解質因數

```c++
void FJ(ll n)
{
    for (ll i = 2; i * i <= n; i++)
    {
        if (n % i == 0)
        {
            int e = 0;
            while (n % i == 0)
            {
                n /= i;
                e++;
            }
            // 存或者輸出 這一部分是 i^e
        }
    }
    if (n > 1)
    {
    } // 存或者輸出 這一部分是 n^1
}
```

以下的代碼在分解質因數時，把c,p存如數對 pair<c,p> 的情況下

// 求因數個數（取餘數）

```c++
ll sum = 1;
for (auto i : t)
{
    sum *= i.second + 1;
    sum %= m;// m為取餘數
}// 得到的sum就是因數的個數
```

```c++

// 求因數的和（取餘數）
ll sum = 1;
for (auto i : t)// <i,e>
{
    ll mi = 1;  ll he = 0;
    for (int j = 0; j <= i.second; ++j)
    {
        he = (he + mi) % m;
        mi = (mi * i.first) % m;
    } sum = (sum * he) % m;
}// 得到的sum就是因數的和
```

```c++
// 利用素性判斷算法分解質因數（Miller-Rabin 素性测试 + Pollard-Rho因式分解）
// 時間複雜度O(mlogn)，n為數字大小，m為質因數個數
ll gys(ll a, ll b) 最大公因數
ll cheng(ll a, ll b, ll m) 大數取餘乘法函數
ll KSM(ll d, ll j, ll c) 快速冪
bool MR(ll n)   素性判斷
ll Zhyh[28]    質數列表

int PR(int n)
{
	for (int p : Zhyh)  if (n % p == 0) return p;
	auto f = [&](int x) -> int { x = cheng(x, x, n) + 1; return x >= n ? x - n : x; };
	int x = 0, y = 0, tot = 0, p = 1, q, g;
	for (int i = 0; (i & 255) || (g = gys(p, n)) == 1; i++, x = f(x), y = f(f(y)))
	{
		if (x == y) { x = tot++; y = f(x); }
		q = cheng(p, abs(x - y), n);
		if (q) p = q;
	} return g;
}
vector<int> fac(int n)
{
	if (n == 1) return {};
	if (MR(n)) return { n };
	int d = PR(n);
	auto v1 = fac(d), v2 = fac(n / d);
	auto i1 = v1.begin(), i2 = v2.begin();
	vector<int> ans;
	while (i1 != v1.end() || i2 != v2.end())
	{
		if (i1 == v1.end())  ans.emplace_back(*i2++);
		else if (i2 == v2.end())   ans.emplace_back(*i1++);
		else
			if (*i1 < *i2) ans.emplace_back(*i1++);
			else ans.emplace_back(*i2++);
	} return ans;
}

```

## 三省吾身 - ㄛㄌ函數

```c++
歐拉函數phi(n)的值為1~n中與n互質的數的個數
單點計算
int phi(int x)
{
	int res = x;
	for (int i = 2; i <= x / i; i++)
		if (x % i == 0)
		{
			res = res / i * (i - 1);
			while (x % i == 0) x /= i;
		}
	if (x > 1) res = res / x * (x - 1);
	return res;
}
```

```c++
遞推法求1~n的函數值
for (int i = 1; i <= n; ++i)   x[i] = i;
for (int p = 2; p <= n; ++p)
	if (x[p] == p)// 如果當前數 p 是質數
		for (int k = p; k <= n; k += p)
			x[k] -= x[k] / p; // 更新 p 的倍數的歐拉函數值
```

## 假到真時

```c++
// 使用容斥定理篩選出1~n中可以被至少一個質數整除的個數
vector<int> p;// 存貯質數的
int rcdl(int n)
{
    int res = 0, m = p.size();
    for (int i = 1; i < 1 << m; i++)
    {
        int t = 1, s = 0;
        for (int j = 0; j < m; j++)
        {
            if (i >> j & 1)
            {
                if ((ll)t * p[j] > n) { t = -1; break; }
                t *= p[j]; s++;
            }
        }
        if (t != -1)
            if (s % 2) res += n / t;
            else res -= n / t;
    }
    return res;
}
```

<br><br><br><br><br>

# 殊方絕域（區間問題）

## 牽髮動身 - 前綴和

註：在這種題目裡面，數組/陣列多開一位，次循環從1開始n結束

### 一維前綴和

前綴和數組的初始化（可在讀數組時同時進行）

```c++
qzh[i] = qzh[i - 1] + x[i];
```

求區間`[a b]`之間的和（座標值從1開始）

```c++
qzh[b] - qzh[a - 1]
```

### 二維前綴和

前綴和數組的初始化（可在讀數組時同時進行）

```c++
qzh[i][j] = qzh[i - 1][j] + qzh[i][j - 1] - qzh[i - 1][j - 1] + x[i][j];
```

求左上角x1 y1座標到右下角x2 y2座標之間（閉區間）的矩陣的和（座標值從1開始）

```c++
qzh[x2][y2] - qzh[x2][y1 - 1] - qzh[x1 - 1][y2] + qzh[x1 - 1][y1 - 1]
```

### 一維差分

差分數組的初始化（可在讀數組時同時進行）

```c++
cf[i] = x[i] - x[i - 1];
```

同時改變`[l,r]`之間的值，加上c

```c++
cf[l] += c;
cf[r + 1] -= c;
```

求原數組

```


x[i] = x[i - 1] + cf[i];

變式：初始化的時候可以借用插入的代碼
void insert(int l, int r, int c){}  // 先封裝
insert(i, i, x[i]); // 調用的時候這樣寫

二維差分
二維差分矩陣必須要多開兩位，因為之後會涉及到+1
vector<vector<int>> cf(n + 2, vector<int>(m + 2, 0));

差分數組的初始化（可在讀數組時同時進行）
cf[i][j] = x[i][j] - x[i - 1][j] - x[i][j - 1] + x[i - 1][j - 1];

同時改變[x1 y1  x2 y2]之間的值，加上c
cf[x1][y1] += c;
cf[x2 + 1][y2 + 1] += c;
cf[x2 + 1][y1] -= c;
cf[x1][y2 + 1] -= c;

求原矩陣
x[i][j] = cf[i][j] + x[i - 1][j] + x[i][j - 1] - x[i - 1][j - 1];

變式1：初始化的時候可以借用插入的代碼
void insert(int x1, int y1, int x2, int y2, int c){}  // 先封裝
insert(i, j, i, j, x[i][j]);   // 調用的時候這樣寫

變式2：不初始化也可以做，這個時候差分矩陣衹記錄的變化，在求原矩陣的時候實際上是把變化加進去，其他不變，求原矩陣的時候這樣寫，這樣操作以後差分矩陣作廢
cf[i][j] += cf[i - 1][j] + cf[i][j - 1] - cf[i - 1][j - 1];
x[i][j] += cf[i][j];


```

## 水光接天 - 區間合併

```c++
#define dui pair<int,int>
vector<dui> x,ans; // x分別存貯了每一個區間的左右端點，ans存貯了合併之後所有的閉區間
void solve()
{
    sort(x.begin(), x.end());
    int start = x[0].first, end = x[0].second;
    for (dui i : x)
    {
        if (i.first <= end)  end = max(i.second, end);
        else
        {
            ans.emplace_back(start, end);
            start = i.first;  end = i.second;
        }
    } ans.emplace_back(start, end);
}
```

## 天涯咫尺 - 區間離散化

## 積土成山 - 堆

```c++
const int N = 100010;
class MinHeap
{
public:
    vector<int> h; int s;// h[]->heap  s->size
// 底層實現：下濾、上浮操作
    void down(int u)
    {
        int t = u;
        if (u * 2 <= s && h[u * 2] < h[t]) t = u * 2;
        if (u * 2 + 1 <= s && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
        if (u != t) { swap(h[u], h[t]);  down(t); }
    }
    void up(int u)
    {
        while (u / 2 && h[u] < h[u / 2])
        { swap(h[u], h[u / 2]); u >>= 1; }
    }
    MinHeap() { h.resize(N); s = 0; } // 無參數，空堆
    MinHeap(vector<int> x) // 使用一個陣列初始化
    {
        h.resize(N); s = x.size();
        for (int i = 0; i < x.size(); i++)  h[i + 1] = x[i];
        for (int i = s / 2; i; i--) down(i); // 這一行是建造堆，也可以封裝起來
    }
// 基礎三功能 insert top pop
    void insert(int x) { s++;  h[s] = x;  up(s); }
    int top()  { return h[1]; }
    void pop() { swap(h[1], h[s]); s--; down(1);  }
// 刪除一個值為k的元素并重構堆
    void delete(int k)
    {   for (int i = 1; i <= s; ++i)
            if (h[i] == k) { swap(h[i], h[s]);  s--;   down(i); up(i);   break;  }
    }
};
```

#### 有特殊功能的堆

```c++
vector<int> h, ph, hp;
int s, m;// h[]->heap  s->size
    // 加入新函數：基於雙映射的堆交換
    void heap_swap(int a, int b)
    {
        swap(ph[hp[a]], ph[hp[b]]);
        swap(hp[a], hp[b]);
        swap(h[a], h[b]);
    }

下濾:  swap(h[u], h[t]);       heap_swap(u, t);
上浮:  swap(h[u], h[u / 2]);   heap_swap(u, u / 2);
無參數構造函數： 加上 ph.resize(N), hp.resize(N);
參數構造函數不能用了

插入：  s++; m++; ph[m] = s, hp[s] = m;   h[s] = x;  up(s);

刪除：    swap(h[1], h[s]);      heap_swap(1, s);
刪除元素：swap(h[i], h[s]);      heap_swap(i, s);

void erase(int k)// 刪除第k個插入的數
{
    k = ph[k];
    heap_swap(k, s);
    s--;
    up(k); down(k);
}
void change(int k, int x)// 改變第k個插入的數字為x
{
    k = ph[k];
    h[k] = x;
    up(k); down(k);
}
```

### 懸絲診脈 - 樹狀數組

- 名稱：CN 樹狀數組 TW 二進位索引樹
- 特性：單點修改，區間查詢

```c++
struct Tree
{
public:
    vector<int> t;
    Tree(vector<int>& x)// 用索引為1的數組初始化，樹的索引同樣從1開始
    {
        int n = x.size(); t.resize(n);
        for (int i = 1; i < n; ++i)  update(i, x[i]);
    }
    inline int lowbit(int x) { return (x) & (-x); }
    void update(int x, int d)
    {
        while (x < t.size()) { t[x] += d; x += lowbit(x); }
    }
    int sum(int x)
    {
        int a = 0;
        while (x > 0) { a += t[x]; x -= lowbit(x); }
        return a;
    }
    int query(int l, int r) { return sum(r) - sum(l - 1); }
};
```

```c++
struct Tree
{
public:
    vector<int> t;
    Tree(int n) { t.resize(n + 1, 0); } // 索引從1開始，為差分數組，不需要原數組了，只需要元素個數
    // lowbit update sum 函數完全相同，沒有query函數了
    void section(int l, int r, int d) // 對[l,r]加上d
    {
        update(l, d);
        update(r + 1, -d);
    }
};
單點查詢（x索引從1開始）：x[i] + tree.sum(i)
```

```

// 樹狀數組：區間查詢，區間修改
struct Tree
{
public:
    vector<int> t1, t2;
    Tree(vector<int> x)
    {
        int n = x.size() - 1;
        t1.resize(n + 1, 0);
        t2.resize(n + 1, 0);
        int old = 0;
        for (int i = 1; i <= n; i++)
        {
            ud(t1, i, x[i] - old);
            ud(t2, i, (i - 1) * (x[i] - old));
            old = x[i];
        }
    }
    inline int lowbit(int x) { return (x) & (-x); }
    void ud(vector<int>& tree, int x, int d)
    {
        while (x < tree.size()) { tree[x] += d; x += lowbit(x); }
    }
    int sum(vector<int>& tree, int x)
    {
        int a = 0;
        while (x > 0) { a += tree[x]; x -= lowbit(x); }
        return a;
    }
    void update(int l, int r, int d)
    {
        ud(t1, l, d);  ud(t1, r + 1, -d);
        ud(t2, l, d * (l - 1)); ud(t2, r + 1, -d * r);
    }
    int query(int l, int r)
    { return r*sum(t1,r)-sum(t2,r)-(l-1)*sum(t1,l-1)+sum(t2,l-1); }
};
 
日取其半
// 綫段樹
// 有需要的話再加一句#define int long long ，全篇都是ll打字打起來太怪了
class XDS
{
private:
    vector<int> xl, ans, tag;// 原數組 樹 延遲標記
    int n;

    inline int ls(int x) { return x << 1; }      // x*2
    inline int rs(int x) { return x << 1 | 1; }  // x*2+1
    inline void up(int p) { ans[p] = ans[ls(p)] + ans[rs(p)]; } // 上傳答案
    void build(int p, int l, int r)// 建樹
    {
        tag[p] = 0;
        if (l == r) { ans[p] = xl[l - 1]; return; }// 數組索引不一樣，所以角標差1
        int m = (l + r) >> 1;
        build(ls(p), l, m);
        build(rs(p), m + 1, r);
        up(p);
    }

    void f(int p, int l, int r, int k)// 加延遲標記
    {
        tag[p] += k;
        ans[p] += k * (r - l + 1);
    }

    void down(int p, int l, int r)// 延遲標記下放函數
    {
        if (tag[p] == 0) return;
        int m = (l + r) >> 1;
        f(ls(p), l, m, tag[p]);
        f(rs(p), m + 1, r, tag[p]);
        tag[p] = 0;
    }

public:
    // update(x, y, 1, n, 1, k);   對於[x,y]加上k
    void update(int nl, int nr, int l, int r, int p, int k)
    {
        if (nl <= l && r <= nr) { f(p, l, r, k); return; }
        down(p, l, r);
        int m = (l + r) >> 1;
        if (nl <= m) update(nl, nr, l, m, ls(p), k);
        if (nr > m) update(nl, nr, m + 1, r, rs(p), k);
        up(p);
    }
    // query(x, y, 1, n, 1);   查詢[x,y]的和
    int query(int x, int y, int l, int r, int p)
    {
        int res = 0;
        if (x <= l && r <= y) return ans[p];  //  完全覆蓋，直接返回
        int m = (l + r) >> 1;
        down(p, l, r);
        if (x <= m) res += query(x, y, l, m, ls(p));
        if (y > m) res += query(x, y, m + 1, r, rs(p));
        return res;
    }

    XDS(const vector<int> &in) : xl(in)
    {
        n = xl.size();
        ans.resize(n * 4);
        tag.resize(n * 4);
        build(1, 1, n);
    }
}; 
class XDS
{
private:
    vector<int> xl, ans, add_tag, mul_tag; // 原數組 樹 延遲加標記 延遲乘標記
    int n, mod;
    inline int ls(int x) { return x << 1; }
    inline int rs(int x) { return x << 1 | 1; }
    void up(int p) { ans[p] = (ans[ls(p)] + ans[rs(p)]) % mod; }
    void build(int p, int l, int r)
    {
        if (l == r)
        {
            ans[p] = xl[l - 1] % mod; // 原數組索引從0開始
            add_tag[p] = 0; mul_tag[p] = 1;
            return;
        }
        int mid = (l + r) >> 1;
        build(ls(p), l, mid);  build(rs(p), mid + 1, r);
        up(p);
    }
    void f(int p, int l, int r, int k, bool is_mul)
    {
        if (is_mul)
        {
            mul_tag[p] = (mul_tag[p] * k) % mod;
            add_tag[p] = (add_tag[p] * k) % mod;
            ans[p] = (ans[p] * k) % mod;
        }
        else
        {
            add_tag[p] = (add_tag[p] + k) % mod;
            ans[p] = (ans[p] + k * (r - l + 1)) % mod;
        }
    }
    void down(int p, int l, int r)
    {
        int mid = (l + r) >> 1;
        f(ls(p), l, mid, mul_tag[p], true);
        f(rs(p), mid + 1, r, mul_tag[p], true);
        f(ls(p), l, mid, add_tag[p], false);
        f(rs(p), mid + 1, r, add_tag[p], false);
        add_tag[p] = 0; mul_tag[p] = 1;
    }
public:
    XDS(const vector<int>& in, int mod) : xl(in), mod(mod)
    {
        n = xl.size();
        ans.resize(n * 4); add_tag.resize(n * 4);
        mul_tag.resize(n * 4, 1); build(1, 1, n);
    }
    void ChangeMul(int x, int y, int l, int r, int p, int k)
    {
        if (x <= l && r <= y) { f(p, l, r, k, true); return; }
        down(p, l, r); int mid = (l + r) >> 1;
        if (x <= mid) ChangeMul(x, y, l, mid, ls(p), k);
        if (y > mid) ChangeMul(x, y, mid + 1, r, rs(p), k);
        up(p);
    }
    void ChangeAdd(int x, int y, int l, int r, int p, int k)
    {
        if (x <= l && r <= y)  { f(p, l, r, k, false);  return; }
        down(p, l, r); int mid = (l + r) >> 1;
        if (x <= mid) ChangeAdd(x, y, l, mid, ls(p), k);
        if (y > mid) ChangeAdd(x, y, mid + 1, r, rs(p), k);
        up(p);
    }
    int query(int x, int y, int l, int r, int p)
    {
        if (x <= l && r <= y) return ans[p];
        down(p, l, r); int mid = (l + r) >> 1;
        long long val = 0;
        if (x <= mid) val = (val + query(x, y, l, mid, ls(p))) % mod;
        if (y > mid) val = (val + query(x, y, mid + 1, r, rs(p))) % mod;
        return val;
    }
}; 
門可羅雀
// 稀疏表
class ST
{
public:
    int n, logn = 21;// 2^21是一個較大的數字
    vector<vector<int>> f;
    vector<int> Logn;
    ST(const vector<int>& x)
    {
        n = x.size();
        f.resize(n + 1, vector<int>(logn + 1, 0));
        for (int i = 1; i <= n; i++) f[i][0] = x[i - 1];
        Logn.resize(n + 1, 0);
        Logn[1] = 0, Logn[2] = 1;
        for (int i = 3; i <= n; i++) Logn[i] = Logn[i / 2] + 1;
        for (int j = 1; j <= logn; j++)
            for (int i = 1; i + (1 << j) - 1 <= n; i++)
                f[i][j] = min(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);// 修改
    }
    int query(int l, int r)// 索引從1開始
    {
        int s = Logn[r - l + 1];
        return min(f[l][s], f[r - (1 << s) + 1][s]);// 修改
    }
};

明修棧道
// 基於單調棧的求「每個數左邊第一個比它小的數」方法模板
for (int i = 0; i < n; i++)
{
    while (!z.empty() && z.top() >= arr[i]) z.pop();// >=小  <=大值
    if (!z.empty()) printf("%d ", z.top());
    else printf("-1 ");
    z.push(arr[i]);
}


井然有序
// 基於單調隊列的解決滑動窗口最值問題
// a[]為原數組、k為窗口大小、q為隊列
for (int i = 0; i < n; ++i)
{
    if (!q.empty() && i - k + 1 > q.front()) q.pop_front();
    while (!q.empty() && a[i] <= a[q.back()]) q.pop_back();
    q.push_back(i);
        if (i + 1 >= k) printf("%d ", a[q.front()]);
}



除了前綴和差分、離散化、區間合併等，你還可以將線段樹、樹狀數組、RMQ（最小範圍查詢）、區間樹等相關算法加入其中。


```

<br><br><br><br><br>

# 罄竹難書（字符串）

## 書簡轉譯 - 字符串散列

為了防止碰撞，可以使用不同的質數多重計算，只需要不把`m`設置為固定值，而是可以在構造里被設置即可

| 質數列表       |
|------------|
| 131        |
| 13331      |
| 1111111121 |
| 1211111123 |
| 1311111119 |

### 基礎版：輸入字符串，獲得散列值

```c++
unsigned long long sl(string s)
{
    unsigned long long r = 0;
    int m = 13331;
    for (char i: s) r = r * m + i;
    return r;
}
```

### 附帶前綴和的進制散列

```c++
class strSL
{
public:
    vector<unsigned long long> q, j; // 前綴散列值 指數
    int m = 13331;

    strSL(string str)
    {
        int n = str.size();
        q.resize(n + 1);
        j.resize(n + 1);
        j[0] = 1;
        for (int i = 1; i <= n; i++)
        {
            q[i] = q[i - 1] * m + str[i - 1];
            j[i] = j[i - 1] * m;
        }
    }

    unsigned long long code(int l, int r) // 從1開始，到 str.size()，人類序號
    {
        return q[r] - q[l - 1] * j[r - l + 1];
    }
};
```

## 鑒鏡回文 - 字符串迴文

| 屬性    | 內容         |
|-------|------------|
| 英文名   | `Manacher` |
| 中文音譯  | 馬拉車算法      |
| 中文意譯  | 回文鏡像擴展法    |
| 時間複雜度 |            |

| 測試數據      | 結果                                |
|-----------|-----------------------------------|
| `"abcba"` | `p = [0 1 2 1 2 1 6 1 2 1 2 1 0]` |

PAM回文自動機5496

```c++
int HW(const string& str)
{
	vector<int> p(2 * str.size() + 3, 0);
	string s = "$#";
	for (char c : str) s += c, s += '#';
	s += '&';

	int r = 0, m = 0;
	for (int i = 1; i < s.size() - 1; ++i)
	{
		if (i < r) p[i] = min(p[2 * m - i], r - i);
		else p[i] = 1;
		while (s[i + p[i]] == s[i - p[i]]) p[i]++;
		if (p[i] + i > r)
		{
			r = p[i] + i;
			m = i;
		}
	}
	int l = 0;
	for (int i = 0; i < s.size(); ++i) l = max(l, p[i]);
	return l - 1;
}
```

## 懸崖勒馬 - 字符串匹配

### 算法本體

| 屬性    | 內容                   |
|-------|----------------------|
| 英文名   | `KMP`                |
| 英文全稱  | `Knuth Morris Pratt` |
| 中文音譯  | 快谋配算法                |
| 中文意譯  | 快速模式匹配               |
| 時間複雜度 |                      |

```c++
vector<int> getnxt(const string &p) // 前綴數組
{
    vector<int> nxt(p.size() + 1, 0);
    for (int i = 1; i < p.size(); i++)
    {
        int j = nxt[i];
        while (j > 0 && p[i] != p[j]) j = nxt[j];
        if (p[i] == p[j]) nxt[i + 1] = j + 1;
    }
    return nxt;
}

void kmp(const string &s, const string &p)
{
    auto nxt = getnxt(p);
    int j = 0;
    for (int i = 0; i < s.size(); i++)
    {
        while (j > 0 && s[i] != p[j]) j = nxt[j];
        if (s[i] == p[j]) j++;
        if (j == p.size())
        {
            // 匹配到了的不同操作
        }
    }
}
```

匹配到了

1. 輸出匹配位置：
    - 索引从0開始：`i - p.size() + 1`
    - 索引從1開始：`i - p.size() + 2`
2. 記錄匹配個數：`ans++;`
3. 跳轉下個位置：
    - 立即退出 `return;`
    - 獨立匹配（123456789->123 456 789）：`j = 0`
    - 連續匹配（123456789->123 234 456）：`j = nxt[j]`

### 前綴數組和跳轉指針的應用

- #### 前後綴

[例題](https://vjudge.net/contest/615161#problem/D)

| 屬性  | 內容                                           |
|-----|----------------------------------------------|
| 描述  | 找出**一類**字符串，同時是`s`的前後綴                       |
| 例子  |                                              |
| 複雜度 | 線性                                           |
| 原理  | 指針回退不斷找前綴的前綴                                 |
| 結果  | `res`數組倒序存貯了這種字符串的長度，<br/>（包括`0`和`s.size()`） |

```c++
auto nxt = getnxt(s);
int k = s.size();
vector<int> res = {k};
while (k > 0) res.push_back(nxt[k]), k = nxt[k];
```

- #### 新字符串里原字符串出現`n`次

| 屬性  | 內容                              |
|-----|---------------------------------|
| 描述  | 已知字符串，求構造一個新字符串，使得新字符串里原字符串出現n次 |
| 例子  |                                 |
| 複雜度 | 線性                              |

按照文字描述

> 1. 先用前綴數組計算`nxt[p.size()]`也就是字符串的前後綴長度
> 2. 如果用`○`表示前後綴，`□`表示中間部分，那麼原來的字符串表示做`○ □ ○`
> 3. 構造 `○ □ ○ □ ○ □ ○` 構造出現`n`次的，需要`n+1`个`○`，n个`□`
> 4. 這時候不論是需要長度還是需要字符串都可以得到結果了

- #### 最短循環節


- #### 祖瑪消除

| 屬性  | 內容                           |
|-----|------------------------------|
| 描述  | `s`被`p`刪除，刪除之後拼在一起，直到完全沒有`p` |
| 例子  | `ababccy -> abcy - >y`       |
| 複雜度 | 線性                           |
| 原理  | 指針回退不斷找前綴的前綴                 |
| 結果  | `z[]`數組存貯了刪除之後剩下的字符的下標       |

編碼技巧：除了加上了註釋的五行，其他和算法本體一樣

```c++
void kmp(const string &s, const string &p)
{
    auto nxt = getnxt(p);
    int j = 0;
    vector<int> xp(s.size()), z;      // xp存貯配對點，z模擬棧
    for (int i = 0; i < s.size(); i++)
    {
        while (j > 0 && s[i] != p[j]) j = nxt[j];
        if (s[i] == p[j]) j++;
        xp[i] = j;                    // 記錄這一個位置匹配的點是哪一個，這樣指針不用回退到0
        z.push_back(i);               // 入棧
        if (j == p.size())
        {
            for (int k = 0; k < p.size(); ++k) z.pop_back(); // 刪除的數據在棧中彈出
            j = (z.empty()) ? 0 : xp[z.back()];              // 0是為了防止棧空
        }
    }
}
```

```
// 找出一個字符串的最短循環節（長度），例如：  （例題）
p.size() - nxt[p.size()];

// 最短均分子串（長度），例如：ababab=3*ab ->ab （例題）
int xhj = p.size() - x[p.size()];
if (p.size() % xhj == 0)  cout << p.size() / xhj; // 循環節完整，長度/週期
else  cout << 1;// 循環節不完整，沒有均分子串，祇有自己




字符串連接問題，最短公共超串（Shortest Common Superstring, SCS）
// 多個字符串生成一個最短的字符串str，使得全部為str的子串，求最短的str（例題）
string kmp(string s, string p) // 這個的函數的意義是：就算沒有完成任務，跳轉指針仍然保留最後匹配信息
{
    auto nxt = getnxt(p);
    int j = 0;
    for (int i = 0; i < s.size(); i++)
    {
        while (j > 0 && s[i] != p[j]) j = nxt[j];
        if (s[i] == p[j]) j++;
        if (j == p.size())
        {
            return s;
        }
    }
    return s.substr(0, s.size() - j) + p;
}
// 通用情況
如果n個字符串，則要合併n-1次，形如kmp(s1,kmp(s2,kmp(s3, …kmp(n-1,n)… ))) 全排列暴力枚舉即可
// 當個數為2的時候
特殊的，全排列(2)=2，答案必在kmp(a, b) kmp(b, a)之間

```

## 動如脫兔 - 字符串變化

### 見縫插針

字符串/數組的匹配，兩個串之間的最長公共子序列(Longest Common Subsequence, LCS)

- ### 動態規劃法

| 屬性     | 內容                    |
|--------|-----------------------|
| 算法     | 動態規劃                  |
| 複雜度    | `O(n*m)` `len < 5000` |
| 優點     | 可以處理重複的字符，現實應用        |
| 缺點     | 效率不高                  |
| 結果：長度  | 運行到一半：`f[n][m]`       |
| 結果：字符串 | 運行到結尾：`ans + 1`       |

```c++
const int N = 5000;
char a[N], b[N], ans[N];
int n, m, f[N][N];

void lcs()
{
    cin >> n >> m >> a + 1 >> b + 1; // 動態規劃需要从1開始，所以先便宜地址
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            f[i][j] = max(f[i - 1][j], f[i][j - 1]);
            if (a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1);
        }
    }
    // 求長度到此為止
    int i = n, j = m;
    while (f[i][j] > 0)
    {
        if (a[i] == b[j])
        {
            ans[f[i][j]] = a[i];
            i--, j--;
        }
        else
        {
            if (f[i][j] == f[i - 1][j]) i--;
            else j--;
        }
    }
}
```

- ### 最長上昇子序列

| 屬性     | 內容                                        |
|--------|-------------------------------------------|
| 算法     | 最長上昇子序列                                   |
| 複雜度    | `O(m*logn)`                               |
| 優點     | 效率高                                       |
| 缺點     | 不能處理相同的元素，但是字符串很難達到<br/>所以一般不處理字符串，而是處理數組 |
| 結果：長度  | `f.size()-1` （f初始有一個0占位置，不然back()會異常）     |
| 結果：字符串 | 循環出`1~f.size()-1` 的`a[f[i]]`，             |

```c++
void lcs()
{
    int n, m;
    cin >> n >> m;
    vector<int> a(n + 1), b(m + 1), f{0}, p(n + 1);
    // p的大小取決於a的元素的大小，這裡開 n+1 假定 a 中的元素值從0~n，即 p 矩陣的索引值是有效的
    for (int i = 1; i <= n; ++i)
    {
        cin >> a[i];
        p[a[i]] = i;
    }
    for (int i = 1; i <= m; ++i) { cin >> b[i]; }

    for (int i = 1; i <= m; ++i)
        if (p[b[i]] > f.back()) f.push_back(p[b[i]]);
        else
        {
            int l = 0, r = f.size() - 1;
            while (l < r)
            {
                int mid = (l + r) >> 1;
                if (f[mid] >= p[b[i]]) r = mid;
                else l = mid + 1;
            }
            f[l] = min(f[l], p[b[i]]);
        }
}
```

### 考定校勘

```c++
int n, m; string a, b;
cin >> n >> a >> m >> b;
vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));

for (int i = 0; i <= n; ++i)
{
    for (int j = 0; j <= m; ++j)
    {
        if (i == 0) dp[0][j] = j;
        else if (j == 0) dp[i][0] = i;
        else if (a[i - 1] == b[j - 1]) dp[i][j] = dp[i - 1][j - 1];
        else dp[i][j] = min(dp[i - 1][j] + 1, min(dp[i][j - 1] + 1, dp[i - 1][j - 1] + (a[i - 1] != b[j - 1])));
    }
}
cout << dp[n][m];
```

## 寒窗松柏

```c++
struct Trie// 字典樹
{
    static const int N = 1000;// 容易超空，一定要認真計算
    map<char, int> mp;
    int ch[N][63]{}, cnt[N]{}, e[N]{}, idx = 0;// idx表示用了幾個節點，清空的時候可用（例題）
// 空間實在不夠：cnt->前綴 e->單詞，這兩個都是額外維護的信息，單獨刪除不影響
    Trie()
    {
        int id = 0;
        for (char c = 'a'; c <= 'z'; c++) mp[c] = ++id;
        for (char c = 'A'; c <= 'Z'; c++) mp[c] = ++id;
        for (char c = '0'; c <= '9'; c++) mp[c] = ++id;
    }
    void insert(string s)
    {
        int u = 0;
        for (int i = 0; i < s.size(); i++)
        {
            int v = mp[s[i]];
            if (!ch[u][v]) ch[u][v] = ++idx;
            u = ch[u][v];
            cnt[u]++;
        } e[u]++; // 標記該節點爲字符串結尾
    }
    int query(string s, int op)
    {
        int u = 0, geh = 0;
        for (int i = 0; i < s.size(); i++)
        {
            int v = mp[s[i]];
            if (!ch[u][v]) 
               { if (op == 3) break; else return 0; }// 本身作為前綴就無解  求他的前綴退出循環
            u = ch[u][v];
            geh += e[u];
        }
        if (op == 1) return cnt[u];// op為1，返回以這個串爲前綴的個數
        else if (op == 2) return e[u];// op為2，返回完整的字符串的個數
        else return geh;// op為3，返回是這個字符串的前綴的字符串的個數
    }
};
```

```c++
字典樹 配 深度搜索
// 帶通配符的字符串匹配，單符匹配'?' 多符匹配'*' （例題）
string p; int l;
Trie(string str) { p = str; l = str.size(); }
bitset<1010> vis[N]; // 壓縮位以字節位單位的真值數組

void dfs(int b, int now) // 當前在模式串上的索引 在字典樹上的位置爲
{ 
	if (b == l) { ans += e[now]; e[now] = 0; return; } 
// 因為可能會有不同方式搜到的同樣字符串，所以計數完了要清零
	if (vis[now][b]) return;

	char x = p[b]; vis[now][b] = true;

	if (x >= 'A' && x <= 'Z') // 如果是確定字符，如果字典樹裡面有這一條路，就順著往下走
		if (ch[now][mp[x]])
			dfs(b + 1, ch[now][mp[x]]);
	if (x == '?') // 如果是單符通配符，遍歷所有可能的往下走，這裡的4衹是例題的ACGT四種核酸
		for (int i = 1; i <= 4; i++)
			if (ch[now][i]) dfs(b + 1, ch[now][i]);
	if (x == '*')
	{
		dfs(b + 1, now); //  多符通配符對應的，什麼也不是的情況
		for (int i = 1; i <= 4; i++)
			if (ch[now][i]) { dfs(b + 1, ch[now][i]);  dfs(b, ch[now][i]); }
	}
}
```

```c++
二進制字典樹
struct trie01
{
    static const int N = 31 * 1e5;
    int c[N][2]{}, idx = 0;
    void insert(int x)
    {
        int p = 0;
        for (int i = 30; i >= 0; --i)
        {
            int& s = c[p][x >> i & 1];
            if (!s) s = ++idx;
            p = s;
        }
    }
    int serach(int x)// 輸入原先已經加入的數字x，得到x能匹配到的最大的異或結果
    {
        int p = 0, res = 0;
        for (int i = 30; i >= 0; --i)
        {
            int s = x >> i & 1;
            if (c[p][!s]) { res += 1 << i; p = c[p][!s]; } 
            else p = c[p][s];
        } return res;
    }
} t;
```

```
清風翻書
給出一個序列，輸出他是全排列中按照字典序第多少位(lexicographical order)
// 使用階乘法計算，時間複雜度O(n^2)
// 優點：可以處理跳躍的情況，比如 [1 2 3 4 114514] ->1
int f[N];// 12超過int，20超過ll，之後的數據都需要取餘數
void init() { f[0] = f[1] = 1; for (int i = 2; i < N; i++) f[i] = f[i - 1] * i; }
int lex(vector<int> str)
{
    int ans = 1, l = str.size();
    for (int i = 0; i < l; i++)
    {
        int tmp = 0;
        for (int j = i + 1; j < l; j++) if (str[i] > str[j]) tmp++;
        ans += tmp * f[l - i - 1];
    }
    return ans;
}



// 使用樹狀數組解，複雜度O(logn*n)，範圍一百萬
// 缺點：序列中的數據範圍[1,n+1]（x-1作為a的索引，a的大小是n+1）
const int m = 998244353, N = 1e6 + 10;
struct lex
{
	ll n, res; vector<ll> a, f;
	// 原sum、add、query函數，簡寫：和(h)、plus(p)、query(q)
	ll h(ll x)
	{
		ll res = 0;
		for (; x; x -= x & -x) res += a[x];
		return res;
	}
	void p(ll x, ll k) { for (; x <= n; x += x & -x)  a[x] += k; }
	ll q(ll x, ll y) { return h(y) - h(x - 1); }
	
	lex(ll n) : n(n), a(n + 1), f(N)
	{
		f[0] = 1;
		for (int i = 1; i <= n; i++) { f[i] = f[i - 1] * i % m; p(i, 1); }// 階乘
		ll ans = 0;
		for (int i = 1; i <= n; i++)
		{
			ll x; cin >> x;
			ans = (ans + q(1, x - 1) * f[n - i] % m) % m;
			p(x, -1);
		}
		res = (ans + 1) % m;// 直接調用.res
	}
};


 
三心二用
// 岔路傳送門算法（Aho-Corasick automato，AC自動機）
class AC
{
	static const int N = 1e5 + 5; // 模式串總長度上限
	int ch[N][26] = {}, fail[N] = {}, idx = 0, num = 0, e[N] = {}, sum[N] = {};
	vector<int> G[N];
	void insert(const string& s)
	{
		int u = 0;
		for (char c : s) {	 int v = c - 'a'; if (!ch[u][v]) ch[u][v] = ++idx; u = ch[u][v];}
		e[num++] = u;
	}
	void dfs(int u) { for (int v : G[u])	{ dfs(v); sum[u] += sum[v]; } }
	void bfs()    // 建立 fail 指針
	{
		queue<int> q;
		for (int c = 0; c < 26; ++c)  if (ch[0][c]) q.push(ch[0][c]);
		while (!q.empty())
		{
			int u = q.front();	 q.pop();
			for (int c = 0; c < 26; ++c) {
				if (ch[u][c]) { fail[ch[u][c]] = ch[fail[u]][c]; q.push(ch[u][c]); }
				else { ch[u][c] = ch[fail[u]][c]; }
			}
		}
		for (int u = 1; u <= idx; ++u) G[fail[u]].push_back(u);
	}
	void build(string t) 	// 匹配主字串 t
	{
		bfs(); int u = 0;
		for (char c : t) { int v = c - 'a'; u = ch[u][v]; sum[u]++; }
		dfs(0);
	}
	int query(int i) { return sum[e[i]]; }
};
```

### 神龍擺尾

- #### 後綴數組

```c++
struct HZ
{
    int n;
    vector<int> h, r, l;// 後綴數組sa，排名rank，LCP

    HZ(const string& s)
    {
        n = s.length();
        h.resize(n, 0);
        l.resize(n - 1);
        r.resize(n);
        sort(h.begin(), h.end(), [&](int a, int b) { return s[a] < s[b]; });
        r[h[0]] = 0;
        for (int i = 1; i < n; ++i) r[h[i]] = r[h[i - 1]] + (s[h[i]] != s[h[i - 1]]);

        int k = 1;
        vector<int> t, c(n);// temp cnt
        t.reserve(n);
        while (r[h[n - 1]] < n - 1)
        {
            t.clear();
            for (int i = 0; i < k; ++i) t.push_back(n - k + i);
            for (auto i : h) if (i >= k) t.push_back(i - k);
            fill(c.begin(), c.end(), 0);
            for (int i = 0; i < n; ++i) ++c[r[i]];
            for (int i = 1; i < n; ++i) c[i] += c[i - 1];
            for (int i = n - 1; i >= 0; --i) h[--c[r[t[i]]]] = t[i];

            swap(r, t);
            r[h[0]] = 0;
            for (int i = 1; i < n; ++i)
            {
                r[h[i]] = r[h[i - 1]] + (t[h[i - 1]] < t[h[i]]
                    || h[i - 1] + k == n || t[h[i - 1] + k] < t[h[i] + k]);
            }
            k *= 2;
        }
        for (int i = 0, j = 0; i < n; ++i)
        {
            if (r[i] == 0) { j = 0; continue; }
            for (j -= j > 0; i + j < n && h[r[i] - 1] + j < n &&
                     s[i + j] == s[h[r[i] - 1] + j];)   ++j;
            l[r[i] - 1] = j;
        }
    }
};

```

- #### 後綴自動機

```
按圖索驥
千里江山
二向箔  鄰接矩陣
// 存稠密圖的好辦法，但是不能存貯重邊
vector<vector<int>> x(N, vector<int>(N, 0));
void add(int a, int b)
{
    x[a][b] = 1;// 要存權重的話，把裡面存的內容使用權重代替
    x[b][a] = 1;// 要存單向圖的話，不用後面這個
}

結繩記事   鄰接表
vector<vector<int>> x(N); // 1.要存權重的話，裡面的數據結構使用數對 2.防止重邊用set 3.好删除用mset
void add(int a, int b)
{
    x[a].push_back(b); 
    x[b].push_back(a); // 要存單向圖的話，不用後面這個
}

蜻蜓點水   鏈式前向星（星鏈）
int h[N], e[N], w[N], ne[N], idx; 
// h和點數有關，e w ne和邊數有關，所以動態規劃內存的時候，h初始化n+1  w,e,ne初始化為m+1（雙向圖2m+2）
void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}

// 遍歷以u為起點的所有邊
for (int i = h[u]; i != -1; i = ne[i])
// 此時e[i]就是當前邊的各個終點，w[i]就是各個邊的權值

通用搜索方式
vector<vector<int>> ljb;  int n, m;
// 深搜
void ss()	
{
	vector<bool> vis(n + 1, false);
	stack<int> z;
	z.push(1);
	while (!z.empty())
	{
		int now = z.top();
		z.pop();
		if (vis[now]) continue;// 在不聯通圖中的檢查
		vis[now] = true;
		for (auto it = ljb[now].rbegin(); it != ljb[now].rend(); ++it)// 倒序遍歷
			if (!vis[*it]) z.push(*it);
	}
}
// 廣搜
void gs()
{
	vector<bool> vis(n + 1, false);
	queue<int> d;
	d.push(1);
	while (!d.empty())
	{
		int now = d.front();
		d.pop();
		if (vis[now]) continue; 
		vis[now] = true;
		for (int i : ljb[now])
			if (!vis[i]) d.push(i);
	}
}

 
認祖歸宗
對一個有向無環圖進行「位相排序」，時間複雜度為 O(點+邊)
要點：在加邊的時候要保證 
1.起點終點是不相同的，如果相同直接退出，因為有自環 
2.邊衹能加一次，因為有向圖才能排序，無向圖相當於每兩個點之間都是一個環
vector<vector<int>> ljb;
vector<int> ans;

bool topo(int n)
{
    vector<int> r(n + 1);// 入度
    queue<int> d;
    for (int i = 1; i <= n; ++i) for (int j : ljb[i])  r[j]++;
    for (int i = 1; i <= n; ++i) if (r[i] == 0) d.push(i);

    while (!d.empty())
    {
        int u = d.front(); d.pop();
        ans.push_back(u);

        for (int i : ljb[u])
        {
            r[i]--;
            if (r[i] == 0) d.push(i);
        }
    }
    return ans.size() == n;// 最後不是所有點都進入了結果，說明有環，無解
}

變式：
判斷是不是唯一解：在while循環開頭增加判斷，衹要有一次 d.size()>1 說明結果不唯一
  通過真值改整數值來處理多個返回值，注意返回值優先級：如果優先返回「有沒有解」或者需要生成一個可行解，那需要用一個真值變量來傳遞這個信息，如果優先且只需要返回「唯不唯一」，則可以直接在判斷的時候掐斷。
 
終南捷徑
本人比較喜歡動態規劃內存，但是效率較低，所以這裡給一些靜態內存的方法
1.以下數組尺寸 N 為題目給的最多點數 +10， M 為題目給的最多邊數 +10
2.memset函數需要使用<cstring>庫，它是一個字節一個字節初始化的
	初始化為-1：memset(a, -1, sizeof a);
	初始化為0x3f3f3f3f：memset(a, 0x3f, sizeof a);
3.星鏈的靜態
全局變量這樣寫：int h[N], w[M], e[M], ne[M], idx;
init函數：h數組和idx的初始化 memset(h, -1, sizeof h) idx=0;   其他的不需要初始化
4.鄰接表的靜態  vector<int> ljb[N];
5.算法中使用到的數組靜態（半靜態）
使用new創建數組，像這樣：   int *l=new int[n+1];    bool *r=new bool[n+1];
對於這樣的數組，初始化應該寫成 memset(l, 0x3f, 4*(n+1));  memset(r, 0x3f, (n+1));
因為l r本身衹是一個指針，所以大小祇有一個元素那麼大，必須要手動初始化

正權單源最短路：短快速查演算法
Dÿkstra算法，複雜度為 O(點^2)，適用於稠密圖，所以只用鄰接矩陣存圖，矩陣要長寬多開一位，初始化為inf
讀入的時候如果有重邊，使用這句話取最短的邊  g[a][b] = min(g[a][b], c) 
int dk(int n, const vector<vector<int>>& g)
{
    vector<int> l(n + 1, inf); // 距離
    vector<bool> r(n + 1, false); 
    l[1] = 0;
    for (int i = 1; i <= n; ++i)
    {
        int t = -1;
        for (int j = 1; j <= n; ++j)
            if (!r[j] && (t == -1 || l[t] > l[j]))   t = j;
        r[t] = true;
        for (int j = 1; j <= n; ++j)    l[j] = min(l[j], l[t] + g[t][j]);
    }
    if (l[n] == inf) return -1; // 返回值為-1，說明無解
    return l[n]; 
}

堆優化版
複雜度 O(邊*log點)，適用於稀疏圖，可以使用鄰接表或者鏈式前向星存圖
typedef pair<int, int> dui;
int dk(int n)
{
    vector<int> l(n + 1, inf);
    vector<bool> r(n + 1, false);
    l[1] = 0;
    priority_queue<dui, vector<dui>, greater<dui>> d;
    d.emplace(0, 1);
    while (!d.empty())
    {
        int p = d.top().second; d.pop();
        if (r[p]) continue; 
        r[p] = true;
        for (int i = 0; i < ljb[p].size(); i++) 
        {
            int j = ljb[p][i].first;
            if (l[j] > l[p] + ljb[p][i].second) 
            {
                l[j] = l[p] + ljb[p][i].second;
                d.emplace(l[j], j);
            }
        }
    }
    if (l[n] == inf) return -1; // 返回值為-1，說明無解
    return l[n]; 
}

負權單源最短路：鬆弛備份演算法
遍歷所有的的點和邊，複雜度為 O(點*邊) ，用於解答有步數限制的負權最短路
這個演算法因為有下面的優化版本，所以用處很窄，但是在解「有步數限制的最短路」是必須選擇的
int n, m, k;// n個點m條邊的有向圖，最多經過k條邊
struct Edge { int a, b, c; };
vector<Edge> x; 

int BF()
{
    vector<int> l(n + 1, inf), bf;
    l[1] = 0;
    for (int i = 0; i < k; i++)
    {
        bf = l;
        for (int j = 0; j < m; j++)
        {
            auto e = x[j];
            l[e.b] = min(l[e.b], bf[e.a] + e.c);
        }
    }
// 計算時會有較小數字加減，所以不是嚴格等於inf，因為引入了負權邊，不能再使用-1作為無解的標誌了
    if (l[n] > inf / 2) return inf;  
    else return l[n];
}

效率最高算法：快速短路演算法
複雜度最好 O(邊)，最壞 O(點*邊)，所以在負權邊的大部分場景都優於鬆弛備份，有的時候會被故意卡常數，所以在無負權邊的時候用短快速查
int spfa(int n)
{
    vector<int> l(n + 1, inf);
    vector<bool> r(n + 1, false);
    l[1] = 0;
    queue<int> q;
    q.push(1);  r[1] = true;
    while (!q.empty())
    {
        int t = q.front(); q.pop();
        r[t] = false;
       for (int i = 0; i < ljb[t].size(); ++i)
       {
           int j = ljb[t][i].first;
           if (l[j] > l[t] + ljb[t][i].second)
           {
               l[j] = l[t] + ljb[t][i].second;
               if (!r[j])  q.push(j), r[j] = true;
           }
       }
    }
    return l[n];  // 返回值為inf，說明無解
}

快速短路演算法判斷負環
原理：當發現一個點已經取到最小值之後還可以減小，說明有負權環，複雜度同上
bool spfa(int n)
{
    vector<int> l(n + 1), c(n + 1);
    vector<bool> r(n + 1, false);
    queue<int> q;
    for (int i = 1; i <= n; i++)  r[i] = true, q.push(i);

    while (!q.empty())
    {
        int t = q.front();
        q.pop();
        r[t] = false;
        for (int i = 0; i < ljb[t].size(); ++i)
        {
            int j = ljb[t][i].first;
            if (l[j] > l[t] + ljb[t][i].second)
            {
                l[j] = l[t] + ljb[t][i].second;
                c[j] = c[t] + 1;
                if (c[j] >= n) return true;
                if (!r[j])  q.push(j),  r[j] = true;
            }
        }
    }
    return false; // true 表示有負環路 false 沒有
}

多源匯最短路：覆網演算法
Floyd-Warshall演算法，複雜度為 O(點^3)，用了滾動數組，所以空間複雜度祇有O(n^2)
const int N = 210, inf = 0x3f3f3f3f;
int d[N][N]; 
void init(int n)
{
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            if (i == j) d[i][j] = 0;
            else d[i][j] = inf;
}
void fl(int n)
{
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}
1.讀邊的時候取最短  d[a][b] = min(d[a][b], c);
2.查找的時候a->b的最短路就是d[a][b]  如果結果 >inf/2，無解（負數邊可能會拉低一些inf的數值）
判斷負環：算法中出現任何 d[i][i]<0 就說明有


1.計算頂點到其他每個點的最短路有幾條
創建大小為n+1數組ans，在dik和spfa算法中，加上這一段
if (l[j] > l[p] + w[i])  ans[j] = ans[p];
else if (l[j] == l[p] + w[i])  ans[j] += ans[p], ans[j] %= mod;
最後ans數組的1~n就是結果

2.計算節點a~b的最短路而不是1~n
算法函數體的普遍結構  創建數組–>初始化->循環->返回
在初始化的時候把和1有關的改成a，在返回的時候把和n有關的改成b
實際上，他們算出來起點到所有點的距離存在l里面，所以可以一對多

3.在2的前提下反查
所有的算法都是可逆的，只需要在主函數傳參數的時候起點終點交換就行了
 
非此即彼
// 二分圖
染色算法，複雜度（點+邊）
vector<int> seh;
for (int i = 1; i <= n; i++) // 這一部分是防止不聯通圖
    if (seh[i] == 0)  if (/*  */) { cout << "No"; return 0; }
cout << "Yes";

bool ss(int now, int s) /* !ss(i, 1) */
{
    seh[now] = s;
    for (int i : ljb[now])
        if (seh[i] == 0) { if (!ss(i, 3 - s)) return false; }
        else if (seh[i] == s) return false;
    return true;
}

bool gs(int now) /* !ss(i) */
{
    queue<int> d; d.emplace(now);
    seh[now] = 1;
    while (!d.empty())
    {
        int now = d.front(); d.pop();
        for (int i : ljb[now])
        {
            if (seh[i] != 0)  if (seh[i] == seh[now]) return false;
            else  { seh[i] = 3 - seh[now]; d.emplace(i); }
        }
    }
    return true;
}

 
過河拆橋
七橋路徑(Euler Route)，一次走完所有的邊，不回頭，不重複
下面的程式碼：判斷這個圖是否有七橋路徑、返回其中那兩個奇數點、並按照字典序最小打印
在這之前一定要判斷這是不是一個聯通圖，可以使用並查集或搜索，不是聯通圖根本不用檢查

無向圖（例題|例題）
注意：希望不要「在無向圖建立的時候加兩次邊」給人錯誤的感覺以為「一條無向邊就是兩條有向邊」，這個在其他地方是無關的，但是在七橋路徑中是錯誤的，因為一條無向邊只會走一次，所以補償性的，要一次刪除兩條邊
vector<multiset<int>> ljb;//  既可以存貯重邊，刪起來也很快，還是按照字典序排列
vector<int> ans;

void gs(int x)
{
    while (!ljb[x].empty())
    {
        int net = *ljb[x].begin();
        ljb[x].erase(ljb[x].find(net));
        ljb[net].erase(ljb[net].find(x));
        gs(net);
    } ans.push_back(x); //  如果在循環中加入答案，ans的順序是正的，但是處理不了自環
}
void ol(int n)
{
    vector<int> d(n + 1), s;  //  每一個點的度數  奇數點
    for (int i = 1; i <= n; ++i)
    {
        d[i] = ljb[i].size();
        if (d[i] % 2 != 0) s.push_back(i);
    }
    if (!(s.size() == 2 || s.empty())) { return; } // 奇數點數不是 0 或 2 ，無解
    int start = (s.empty()) ? 1 : s[0]; //  有奇數點就最小的奇數點，沒有就一號點
    gs(start);
    reverse(ans.begin(), ans.end());//  倒轉之後的ans即為所求
}

這裡常常出的題目裡面是按照實際情況出題，輸入的並不是圖論的規範的1~n節點，所以使用以下辦法做離散化
需要字典序的時候：①暫存數據、集合去重，②遍歷集合，建立雙映射③根據映射轉化為鄰接表
暫存數據超空間而不需要字典序的時，實時處理輸入數據：
map<string, int> mp;   map<int, string> pm; // 正映射和反映射，有需要打印原稿要求的時候建立反映射
string a, b;  set<string> ji;
ljb.resize(2); int idx = 1;  // 之後按照idx+1來重置其他數組的大小
while (cin >> a >> b)
{
    if (ji.count(a) == 0) { ji.insert(a); mp[a] = idx; idx++; ljb.resize(ljb.size() + 1); }
    if (ji.count(b) == 0) { ji.insert(b); mp[b] = idx; idx++; ljb.resize(ljb.size() + 1); }
    int u = mp[a], v = mp[b]; ljb[u].insert(v); ljb[v].insert(u);
}

有向圖
vector<multiset<int>> ljb; vector<int> ans;
void ss(int x)
{
	while (!ljb[x].empty())
	{
		int net = *ljb[x].begin(); 
		ljb[x].erase(ljb[x].begin());
		ss(net);
	} ans.push_back(x);
}
void ol(int n)
{
	vector<int> in(n + 1), out(n + 1);
	for (int i = 1; i <= n; ++i)  for (int j : ljb[i])  in[j]++, out[i]++;
	pair<int, int> s = { -1,-1 }; int cnt = 0;  //  有向圖的起點終點是唯一的，所以要判斷來存
	for (int i = 1; i <= n; i++)
		if (in[i] == out[i]) cnt++;
		else (in[i] < out[i]) ? s.first = i : s.second = i; // 入<出 起點 入>出 終點
	if (cnt != n - 2 && cnt != n) { return; }
	int start = (cnt == n) ? 1 : s.first;
	ss(start);
	reverse(ans.begin(), ans.end());
} 
無向圖的連通性
割點/割邊：刪除某一個點/邊，整個圖出現不連通的兩個部分，這樣的 點/邊 就是 割點/割邊
算法：深搜回退算法
定理1：對於根節點，有多於一個的枝，那麼就是割點
定理2：對於任意節點，它的枝上衹要有一個節點，無法回退到他的幹，那麼就是割點
int l[N], c[N], cut[N], t;// 最低可退回節點 層次標號 是否是割點 標記層次時間戳
void dfs(int u, int fa)// 初始调用dfs(1,1)
{
    l[u] = c[u] = ++t;  int z = 0; // 子樹數量
    for (int i = 0; i < ljb[u].size(); i++)
    {
        int v = ljb[u][i];
        if (!c[v])
        {
            z++; dfs(v, u);
            l[u] = min(l[v], l[u]);
            if (l[v] >= c[u] && u != 1) cut[u] = true;
        }
        else if (c[v] < c[u] && v != fa) l[u] = min(l[u], c[v]);
    }
    if (u == 1 && z >= 2) cut[1] = true;
}
求割邊：割邊至少要兩點，所以省略根節點的特判，把劃綫那句話的>=換成>即可。需要換一種方式存貯割邊。

點/邊 雙連通分量
定義：圖中任選兩個點，使得他們，使他們至少有兩條 點/邊 不相同的路徑連接，這就是雙聯通圖，一個圖中的一部分點滿足這個規則、並且是儘可能大的，就是一個雙聯通分量，雙聯通分量中沒有割邊
邊算法：縮點算法（Tarjan），同分量的low[]是相同的，由此縮點，由下面的代碼構建一個新的圖的度數
int tar(int n)
{
    map<int, int> d;  // <low,度數>
    for (int i = 1; i <= n; i++)
        for (int j : ljb[i]) if (l[i] != l[j]) d[l[i]]++;
    /*得到d.size()是多少，說明有多少個縮點，即多少個雙連通分量*/
}
求加上多少個邊，他可以變成完全雙聯通圖：實際為⌈奇數點/2⌉，編程可以寫作（奇數點+1）/2
有向圖的連通性
弱連通：看成無向圖之後是聯通的
強連通：兩點互相可達為強連通；圖中所有點都這樣，為強連通圖
強連通分量：子圖是強連通圖，且儘可能大，這個子圖就是分量(Strong Connected Component,SCC)

算法：反圖演算法(Kosaraju)，時間複雜度（點+邊）
定理：對於強連通分量，邊的交換不影響任意到達；對於兩個不強聯通的分量來說，如果原邊可以從一個走過去，則改變邊的方向一定到不了，否則他們屬於同一個聯通分量

注意：建立圖的時候不要下意識建成無向圖了，這裡的代碼很具有迷惑性
ljb[a].push_back(b); ljb[b].push_back(a)    ljb[a].push_back(b); bjl[b].push_back(a)  

vector<vector<int>> ljb, bjl; //  存正圖和反圖的鄰接表
vector<int> t;      //  存儲節點的位相排序結果
int vis[N], scc[N]; //是否訪問  屬於第幾個SCC（標成數組是因為和圖規模有關，實際還是vector）
int cnt;    //  强連通分量的個數

void dfs1(int u) //  正圖深搜
{
    if (vis[u]) return;
    vis[u] = 1;
    for (int i = 0; i < ljb[u].size(); i++) dfs1(ljb[u][i]);
    t.push_back(u);           // 記錄點的先後順序，標記大的放在後面
}
void dfs2(int u) //  反圖深搜
{
    if (scc[u]) return;
    scc[u] = cnt;
    for (int i = 0; i < bjl[u].size(); i++) dfs2(bjl[u][i]);
}
void K(int n)
{
    for (int i = 1; i <= n; i++) dfs1(i);  // 點的編號：1~n。遞歸所有點
    for (int i = n - 1; i >= 0; i--)
        if (!scc[t[i]]) { cnt++; dfs2(t[i]);  }
}

算法：深搜回退演算法(Tarjan)，時間複雜度（點+邊）
定理：一個強連通分量，從其中任意一點除法，都至少有一條路徑能繞回自己

vector<vector<int>> ljb;
int l[N], c[N], t; //  同無向圖
int scc[N], cnt;   //  同上算法
stack<int> z;

void dfs(int u)
{
    z.push(u);
    l[u] = c[u] = ++t;
    for (int i = 0; i < ljb[u].size(); ++i)
    {
        int v = ljb[u][i];
        if (!c[v])
        {
            dfs(v);
            l[u] = min(l[v], l[u]);
        }
        else if (!scc[v])  l[u] = min(l[u], c[v]);
    }
    if (l[u] == c[u])// 栈底的点是SCC的祖先，它的low = c
    {
        cnt++;
        while (true)
        {
            int v = z.top(); z.pop();
            scc[v] = cnt;
            if (u == v) break;          // 栈底的点是SCC的祖先
        }
    }
}
void Tarjan(int n)
{
    for (int i = 1; i <= n; i++) if (!c[i])  dfs(i);
}
 
物以類聚
基礎並查集  最新版本2025/3/24
geh：還剩下geh個集合       f[x]：節點x的所屬的根節點編號
size[x]：節點x所在的集合有多大（祇有頭節點的數字有意義，應該調用find_size()）
class BCJ
{ public: int geh = 0; vector<int> f; vector<int> size; 
	BCJ(int n) : f(n + 1), size(n + 1, 1) 
	{ for (int i = 1; i <= n; ++i) f[i] = i;  geh = n; }
	int zhao(int x) { return f[x] == x ? x : f[x] = zhao(f[x]); }// 查找並路徑壓縮
	bool hebing(int x, int y) //合併兩個集合 要指定父子的話，父為y子為x
	{
		int fx = zhao(x), fy = zhao(y);  // 先找到根節點編號
		if (fx == fy) return false;      // 防止重複，重複返回false備用
		size[fy] += size[fx]; geh--;     // 更新集合大小和集合數量
		f[fx] = fy; return true;
	}
	int find_size(int x) { return size[zhao(x)]; }// 找節點x所在的集合的大小
};
萬用並查集  最新版本2025/3/24
當不能實現確定集合元素大小、或者集合元素編號不連續的時候使用，兼容泛型（例題）
template <typename T>
class BCJ
{  public: int geh = 0; map<T, T> f; map<T, int> size;// 使用地圖存貯
	  void cj(T s) { if (f.count(s) == 0) { f[s] = s; geh++; size[s] = 1; } }
	  T zhao(T x) { return f[x] == x ? x : f[x] = zhao(f[x]); }
	  bool hebing(T x, T y) {
		  cj(x), cj(y); T fx = zhao(x), fy = zhao(y);
		  if (fx == fy) return false;
		  size[fy] += size[fx]; geh--;
		  f[fx] = fy; return true;
	  }
	  int find_size(T x) { return size[zhao(x)]; }
	  int size_(int sum) { return sum - f.size() + geh; } //沒關係的點沒有被加入，sum為全部點數
};

4.有向圖的連通性檢查
註：特別的，如果題目保證將有向邊視爲無向邊後圖連通，則不需要這個
調用並查集的改版2，加邊的時候就合幷，最後隨便查一個點所在的集合的大小，是n就連通

class BCJ
{ public:
	vector<int> f;
	BCJ(int n) : f(n + 1)
	{ for (int i = 1; i <= n; ++i) f[i] = i; }
	// 查找元素所屬的集合，並進行路徑壓縮
	int zhao(int x) { return f[x] == x ? x : f[x] = zhao(f[x]); }
	// 合併兩個集合
	void hebing(int x, int y) // 要指定父子，父為y子為x，因為子的父節點設置為了父的父節點
	{
		int fx = zhao(x), fy = zhao(y);
		if (fx == fy) return;// 防止重複
		f[fx] = fy;
	}
};

帶權並查集



 
林海茫茫
無嚮圖判是否是樹   （例題：0 0是一組合法的數據）
把邊集在並查集合併一輪，如果因為已經是同一個集合而合併失敗了，不是樹（有環）
遍歷一輪之後看集合個數，如果不是1，不是樹（不聯通）

有嚮圖判是否是樹  （例題）
在無向圖的基礎上判斷，每一個點的入度是否不大於1

修葺枝繁
最小生成樹(Minimum Spanning Tree, MST)
定義：一張無權圖，保留所有點，刪除部分邊使之成為樹（無環），現求一種最優解，使得樹的邊權值之和最小
並查集優化版
複雜度 O(邊*log邊)，適用於稀疏圖
使用貪心原理，按照邊權從小到大遍歷邊集組，如果新的一條邊連接了之外的點就加入
struct Edge
{
    int a, b, w;
    bool operator<(const Edge& W) const { return w < W.w; }
};
vector<Edge> e;  // 不用加兩回邊，在並查集裡面正反都一樣
vector<int> p;  // 用于並查集
int find (int x) 
{ return p[x] == x ? x : p[x] = find(p[x]); }

int kr(int n)
{
    sort(e.begin(), e.end());  // 將邊按權值排序
    p.resize(n + 1);
    for (int i = 1; i <= n; i++) p[i] = i;
    int res = 0, cnt = 0;
    for (auto& edge : e)
    {
        int a = find(edge.a), b = find(edge.b);
        if (a != b)
        {
            p[a] = b; res += edge.w; cnt++;
        }
    }
    if (cnt < n - 1) return inf;  // 返回值為inf，無解
    return res;
}
1.只需合併到某個數量的連通塊為止（例題）
cnt表示加邊的個數，容易得到n-cnt是賸餘連通塊的個數
所以當需要留下k個連通塊的時候，衹要每一次檢查n-cnt和目標的大小得到得到后立即退出
循環結束情況不用判斷，直接返回「不可能」

2.只需要某些點在同一個連通塊為止（例題）
每一次循環檢查目標幾個點是否已經在同一個連通塊那（並查集的find函數），得到后立即退出
循環結束情況不用判斷，直接返回「不可能」

鋪鄰思謀
複雜度 O(點*點)，適用於稠密圖
思路和短快速查非常類似，所以理論上也可以使用堆優化，但是堆優化適用於稀疏圖，而稀疏圖用上一種方法
int prim(int n, vector<vector<int>>& g)
{
    vector<int> l(n + 1, inf);
    vector<bool> r(n + 1, false);

    int ans = 0;
    for (int i = 0; i < n; i++)
    {
        int t = -1;
        for (int j = 1; j <= n; j++)
            if (!r[j] && (t == -1 || l[t] > l[j])) 
                t = j;

        if (i && l[t] == inf) return inf;
        if (i) ans += l[t];
        r[t] = true;
        for (int j = 1; j <= n; j++) l[j] = min(l[j], g[t][j]);
    }
    return ans;// 返回inf無解
}

 
亭亭如蓋
// 求樹的直徑，無向圖最遠的兩點的距離
vector<vector<int>> ljb;
vector<bool> r;
int pnt, l;// 最遠節點標號 最遠距離

void dfs(int p, int d)// 當前節點編號  當前最長距離
{
	r[p] = true;
	if (d > l) l = d, pnt = p;
	for (int i : ljb[p]) if (!r[i])  dfs(i, d + 1);
}

int ZJ(int n)
{
	r.assign(n + 1, false);  l = -1;  dfs(1, 0);
	r.assign(n + 1, false);  l = -1;  dfs(pnt, 0);
	return l;
}

獨樹一幟
// 求樹的重心
// 定義：如果將它從樹中删除，剩下的每個子樹的節點數都不會超過總節點數的一半。
// 效果：重心節點的選擇確保了在删除它之後，每個子樹的節點數都盡可能均衡
int n;
vector<vector<int>> ljb;
vector<bool> r;
int ans = 0x3f3f3f3f;

int dfs(int p)
{
    r[p] = true;

    int size = 0, sum = 0;
    for (int i = 0; i < ljb[p].size(); i++)
    {
        int j = ljb[p][i];
        if (r[j]) continue;
        int s = dfs(j);
        size = max(size, s);
        sum += s;
    }
    size = max(size, n - sum - 1);
    ans = min(ans, size);
    return sum + 1;
}
/*初始化：ljb.resize(n+1)  r.resize(n+1)
调用：dfs(1);
结果：ans*/

 
```
