# 四庫全書（庫函數）

## 出入流

### iostream  匚艹輸入輸出流函數庫

- 英文全稱：input output stream
- 注意：所有變量名前面都要統一加`std::`  除非函數中加了`using namespace std`;

```c++
cin>>a;  // 輸入
cout<<a; // 輸出
```

### iomanip  匚艹輸出輸入操縱器函數庫

●設置浮點數的有效數位n setpricition(n)
保留n位數字輸出 cout << setpricition(n) << a;
123.456789 n=5→ 123.45
保留n位小數輸出 cout << fixed << setpricition(n) << a;
123.456789 n=5→ 123.45678
**也可以用來取消整數的科學計數法cout <<  fixed << setprecision(0) << a;
●更改整數的進制setbase(n)
把十進制x轉換為N進制並輸出（僅支持8、10、16） cout<<setbase(N)<<x;

## 繼承函數庫

### cstdio  匚艹標準輸入輸出庫（stdio.h）

### 英文全稱  standard input/output

printf標準輸出 scanf 標準輸出
占位符：
double 輸入是使用%lf 輸出時用%f 不是%d %d是整數
進制 %d：十進制整數 dec %x：十六進制整數 hex %o：八進制整數 oct
縮寫 %f：浮點數 %c：字符 %s：字符串 %p：指針地址 %u：無符號整數
%ld長整型 %lld超長整型 %lf雙精度浮點型 %lu無符號長整型
%e：用于以指數形式輸出浮點數。
%g：根據值的大小，自動選擇%f或%e格式輸出浮點數。
%i：與%d相同，十進制整數。

格式占位符：
在百分號和字母之間添加符號
1 %___d 輸出總寬度為指定數字的格式并右對齊 %-__d 左對齊
2 %.___d，保留指定數字位的小數
3 %__._d 點左邊的同1，點右邊的同2；

- #### 大量輸入輸出辦法

1. 因為`cin`/`cout`速度較慢，建議使用`scanf`和`printf`
2. 如何騙過VS 在文件第一句加上
   ```c++
   #define _CRT_SECURE_NO_WARNINGS 1
   ```
3. 不想放棄`cin`/`cout`，加上這一段代碼，不過就不能使用`scanf` `printf` `getchar`了
   ```c++
   std::ios::sync_with_stdio(false);
   std::cin.tie(0);
   ```

4. 使用比`scanf`還快的快讀
   ```c++
   int read() // 快讀
   {
       char c = getchar();
       int x = 0, f = 1;
       while (c < '0' || c > '9')
       {
           if (c == '-') f = -1;
           c = getchar();
       }
       while (c >= '0' && c <= '9')
       {
           x = x * 10 + c - '0';
           c = getchar();
       }
       return x * f;
   }
   ```

5.如果明確說了解綁出入流，那麼可以放心用cin cout

### cstdlib  匚艹標準庫（stdlib.h）

英文全稱 standard library
字符串轉化為數字

整數 浮點數
atoi 整數 int strtof 單精度 float
atol 長整數 long atof 雙精度 double
strtol 長整數 long strtod 雙精度 double
atoll 超長整數 llong strtold 長浮點 l.double
strtoll 超長整數 llong		
strtoul 無符長 us.long		
strtoull 無符超長 us.ll		
動態內存分配
為類型為type，大小為size的動態數組Arr分配內存   
type* Arr = (type *)malloc(size * sizeof(type))
動態數組記憶體釋放
free(Arr)

實際使用:伸屈陣列
int* Arr = (int*)malloc(size * sizeof(int)); // 大小為size
free(Arr); // 動態內存清空

二向伸屈陣列
// 使用之前
int** Arr; // 二級指針動態申請二維數組
Arr = (int**)malloc(sizeof(int*) * m); // m行n列
for (int i = 0; i < m; i++)
Arr[i] = (int*)malloc(sizeof(int) * n);
// 使用之後清空內存時
for (int i = 0; i < m; i++)
free(Arr[i]);// 先釋放內部的一維數組
free(Arr); // 最後釋放外層的二維指針

現在有很多取代的方法，以下是其一

一維動態數組

```c++
// 創建的時候  
int* array = new int[size];
// 使用完了
delete[] array;


```

二向動態數組

```c++
// 創建的時候
int** array2D = new int* [rows];
for (int i = 0; i < rows; ++i)  array2D[i] = new int[cols];
// 使用完了
for (int i = 0; i < rows; ++i)  delete[] array2D[i];
delete[] array2D;
```

cstring 匚艹字符數組函數庫（string.h）
這裡只列出不能使用string代替的，用來操作C風格的字符串（使用\0結尾的）的

預先填充 memset(Arr, 0, sizeof(Arr));
計算長度 strlen(Arr)   不包括末尾的空字符 \0
複製a到b strcpy(b,a)  複製操作會覆蓋目標字符串原有的內容
添加到末尾 strcat()：

### cctype 匚艹字符類型函數庫（ctype.h）

- #### 判斷函數，接收字符值，返回正誤值

註：十六進制數字字符指的是`0~9` `A~F` `a~f`

| 功能	      | 寫法		         |
|----------|--------------|
| 字母或數字	   | `isalnum()`  |
| 字母	      | `isalpha()`  |
| 小寫字母	    | `islower()`  |
| 大寫字母	    | `isupper()`  |
| 空格	      | `isblank()`  |
| 數字	      | `isdigit()`  |
| 十六進制數字字符 | `isxdigit()` |

- #### 轉換函數

這兩個函數是不用管接受的數是不是已經是目標格式了，可以無差別輸進去。

| 功能  | 寫法		        | 說明 |
|-----|-------------|----|
| 轉大寫 | `toupper()` | 	  |
| 轉小寫 | `tolower()` | 	  |

- #### 大小寫轉換擴展

| 方法	   | 轉大寫		      | 轉小寫		      | 說明			          |
|-------|------------|------------|----------------|
| 使用偏移  | `a-=32`	   | `a+=32`	   | 如果已經符合大小寫了會偏掉的 |
| 使用位運算 | `a&=~0x20` | `a\|=0x20` | 使用交換碼的特性	      |

### cmath  匚艹數學函數庫（math.h）

說明：

1. 所有整數，想要計算結果是浮點數，必須加.0後綴！
    - 例子：`pow(8, 1.0 /3.0)`  即`8^1/3` =`2`
    - 反例：`pow(8, 1 / 3)`  `1/3`取整為`0` 即`8^0 = 1`
2. 需要自行定義常數
    - `π`需要自行定義`const double Pi = acos(-1.0)`
    - `e`需要自行定義`const double e = exp(1)`

| 模塊   | 功能	    | 寫法			           | 說明						                  |
|------|--------|-----------------|---------------------------|
| 絕對值  | 整數絕對值  | `abs(a)`		      | 						                    |
| └──  | 浮點絕對值  | `fabs(a)`		     | 						                    |
| 餘數   | 浮點餘a%b | `fmod(a,b)`	    | 在浮點數除法裡面使用%取餘數是不合法的	      |
| 取整   | 向上取整   | `ceil(a)`	      | 						                    |
| ├──  | 向下取整   | `floor(a)`	     | 						                    |
| ├──  | 四捨五入   | `round(a)`	     | 						                    |
| └──  | 向零取整   | `trunc()`	      | 可以理解為無論正負，去尾取整			         |
| 合成數字 | 兩個數字合併 | `copysign(a,b)` | 取第一個數的數值，和第二個數的正負號		      |
| 分解數字 | 一個數字分拆 | `modf(a,&b)`	   | 取浮點數的小數作為返回值，通過引用返回整數部分   |
| 對數   | 自然對數   | `log(a)`		      | 						                    |
| └──  | 常用對數   | `log10(a)`	     | 						                    |
| 指數   | 自然冪e^a | `exp(a)`		      | 						                    |
| ├──  | 普通冪a^b | `pow(a,b)`	     | 						                    |
| └──  | 二進冪2^a | `exp2(a)`	      | 						                    |
| 根數   | 平方根	   | `sqrt(a)`	      | 						                    |
| └──  | 立方根	   | `cbrt(a)`	      | 						                    |
| 勾股定理 | 勾股求弦   | `hypot(a,b)`	   | 即求sqrt(a2+b2)			          |
| 三角函數 | 正弦	    | `sin(a)`		      | 						                    |
| ├──  | 余弦	    | `cos(a)`		      | 						                    |
| ├──  | 正切	    | `tan(a)`		      | 						                    |
| ├──  | 反正弦	   | `asin(a)`	      | 						                    |
| ├──  | 反余弦	   | `acos(a)`	      | 						                    |
| ├──  | 反正切	   | `atan(a)`	      | 給出橫縱座標值(y,x)，返回該點與原點連線的張角 |
| └──  | 角度	    | `atan2(y,x)`	   | 						                    |
| 雙曲三角 | 雙曲正弦   | `sinh(a)`	      | 						                    |
| ├──  | 雙曲餘弦   | `cosh(a)`	      | 						                    |
| ├──  | 雙曲正切   | `tanh(a)`	      | 						                    |
| ├──  | 雙曲反正弦  | `asinh(a)`	     | 						                    |
| ├──  | 雙曲反餘弦  | `acosh(a)`	     | 						                    |
| └──  | 雙曲反正切  | `atanh(a)`	     | 						                    |
| 誤差函數 | 誤差值	   | `erf()`		       | 						                    |
| └──  | 互補誤差值  | `erfc()`		      | 						                    |
| ㄍㄇ函數 | ㄍㄇ值	   | `tgamma()`	     | 						                    |
| └──  | 對數ㄍㄇ值  | `lgamma()`	     | 						                    |

- #### 優化

內建函數會更快

| 功能	   | 寫法					               |
|-------|-----------------------|
| 絕對值   | `__builtin_abs(x)`	   |
| 平方根   | `__builtin_sqrt(x)`   |
| 乘方	   | `__builtin_pow(x, y)` |
| 浮點絕對值 | `__builtin_fabs(x)`   |
| 最大值   | `__builtin_max(x, y)` |
| 最小值   | `__builtin_min(x, y)` |

## 資料構造

### string   匚艹尺牘書簡函數庫

> - 名稱：CN字符串 TW字串
> - 注意：所有變量名前面都要統一加`std::`  除非函數中加了`using namespace std`;

- #### 遍歷
  迭代器：支持八種函數生成隨機訪問迭代器

- #### 長度

| 功能	    | 寫法						                    | 返回值 | 說明	      |
|--------|-----------------------------|-----|----------|
| 長度	    | `str.size()`/`str.length()` | 整值  | 		       |
| 是否為空   | `str.empty()`			            | 正誤值 | 		       |
| 目前分配大小 | `str.capacity()`			         | 整值  | 		       |
| 最大的大小  | `str.max_size()`			         | 整值  | 數值根據環境而定 |

更改字符串的長度為n str.resize(n)
無返回值，多出來空間的用'\0'填充，少掉的空間將字符串截斷
*重載函數：多出來的用指定的字符ch填充 str.resize(n,ch) 或str.resize(n,'x')

- #### 內容

| 功能			         | 寫法							                        |
|---------------|----------------------------------|
| 訪問第n位機器序號	    | `str[n]`/`str.at(n)`			          |
| 訪問第一位/第0位機器序號 | `str.front()`/`str[0]`		         |
| 訪問最後一位		      | `str.back()`/`str[str.size()-1]` |

- #### 添加

| 功能				            | 寫法									                              |
|-------------------|------------------------------------------|
| 在a末尾添加字符串b		      | `a+=b`/`a.append(b)`					                |
| 在a末尾添加指定字符		      | `a+="xxx"`/`a.append("xxx")`			          |
| 字符串連接函數，連接字符串 a,b | `a.append(b)`							                     |
| 在字符串str末尾添加一個字符   | `str.push_back('!')`/`str.push_back(ch)` |

- #### 插入

在a的第n位人類序號之後（或者解釋為第n為機器序號之前）插入字符串  
a.insert(n,b)  或 a.insert(n, "xxx")   
例：
"HELL Y"  str.insert(4, "o")  →  "HELLO Y"
註：不能以字符的形式插入，如'#',就算是字符也要改成字符串形式，如"#"

- #### 刪除

| 功能				             | 寫法			          | 說明										                              |
|--------------------|----------------|-------------------------------------------|
| 字符串末尾刪除一個字符		      | str.pop_back() | 										                                |
| 清空字符串的內容		         | str.clear	     |
| 在第n位（人類序號）之後刪除x個字符 | str.erase(n,x) | "Hello World"  str.erase(5, 6); → "Hello" |

- #### 替換

在str的第n位（人類序號）之後刪除x個字符，并在這中間插入特定字符串或字符串b
str.replace(n,x,b)  或 str.replace(n,x,"xxx")
例："Hello World!"     str.replace(6, 5, "Yau"); →   "Hello Yau!"
註：這裡的第二個數的值不需要和第三個字符串長度相等如果不相等，編譯器會自動調整後面的部分的存貯位置，使其中間沒有空位

- #### 截取

以str的第n位索引為第一個字符，總共截取x個字符，作為它的子串傳回
str.substr(n,x)
例："Hello World"  string a=str.substr(5, 6); → a="World"

實際操作：
〡 去除結尾n位 s = s.substr(0, s.size() - n);
〢 就要結尾n位 s = s.substr(s.size() - n, n);
〣 取得索引m n之間的部分[m n] s.substr(n, m - n + 1)
〤 取得索引m n之間的部分[m n) s.substr(n, m - n)
比較
比較字符串a和b的字典序列 a.compare(b)  返回整數值
如果a的字典序列小於b 結果為負數，值不一定
如果a的字典序列大於b 結果為正數，值不一定
如果兩個的字典序列相等，即兩個字符串完全相同，結果為0
請想像字典中的排列……

- #### 尋找

尋找字符串str中第一次出現特定字符串第一位是哪個索引 返回索引型size_t
str.find(b)  或 str.find("xxx")
例："Hello World"  size_t p=str.find("World")  p=6
註：沒有找到返回string::npos

指針
使用指針把str轉換成以\0為結尾的C語言形態字符數組 返回靜態字符數組const char*
str.c_str()  或 str.data()
例："Hello World"  const char *data = str.data()  data="Hello World\0"

- #### 輸入

> 一般的cin輸入在碰到空格就停止了，這個是為了完整讀取一行而產生的

帶空格輸入字符串函數，輸入字符串s，遇到回車停止 getline(cin,s)

註：使用cin讀取會留下換行符。如果緊接著使用getline()讀取字符串，那麼getline()只會讀取從cin到換行符的內容，而不是任何其他內容，因此會得到一個空字符串。
改進方法：
①基礎方法 cin.ignore()    用來忽略這輸入流中的下一個字符
②萬全之策 <limits> + cin.ignore(numeric_limits<streamsize>::max(), '\n')
③亡羊補牢 if (!str.size())  { getline(cin, str); }

- #### 賦值

和replace()不同，這個是字符串的所有內容都不要，整體重新賦值，有多個重載函數
〡 str被字符數組ch賦值 str.assign(ch)
常量字符數組（const char* ch1）和普通字符數組（char ch2[]）都可以  
〢 str被字符數組的前n個字符賦值 str.assign(ch，n)
〣 str被字符數組的從第k個字符之後開始的n個字符賦值str.assign(ch,k,n)
例："HHH"  "HelloYau"  str.assign(ch,3,3)  "loY"

〤 str被字符串str1賦值 str.assign(str1)
〥 str被字符串str1的從第k個字符之後開始的n個字符賦值str.assign(str1,k,n)

〦 str被字符串str1使用迭代器賦值 str.assign(str1.it1, str1.it2)
如s.assign(vec.begin(), vec.end())

〧 str被字符ch重複賦值n次 str.assign(n, 'a');
上面例子獲得"aaaaa"

- #### 轉換

字符串轉整數

| 寫法			         | 返回值				              |
|---------------|----------------------|
| `stoi(str)`   | `int`				            |
| `stol(str)`   | `long`			            |
| `stoll(str)`  | `long long`		        |
| `stoul(str)`  | `unsigned long`	     |
| `stoull(str)` | `unsigned long long` |
| `stof(str)`   | `float`			           |
| `stod(str)`   | `double`			          |
| `stold(str)`  | `long double`		      |

*重載函數：更改N進制字符串為十進制 stoi(str,0,N)  
中間的參數為一個指向 size_t 的指針，默認值為0，可不變
後面的參數如果填0，那麼編譯器自動檢測進制。0X或0x開頭判斷為十六進制，0開頭判斷為八進制，其他認為是十進制
N在2~36之間，字符串的進制可以大於十六進制，最高為36進制（十個數字+二十六個字母），其中大小寫均可

整數a轉字符串
string str = to_string(a)     轉化為普通字符串，保留符號及小數點
wstring wstr = to_wstring(a)  轉化為「寬字符字符串」，和文字編碼有關

### array   匚艹陣列函數庫

> 所有變量名前面都要統一加std::  除非函數中加了using namespace std;

容器：array<type,n> A，其中type是裡面存貯的數據類型，n為陣列的大小

- #### 遍歷

迭代器：支持八種函數生成隨機訪問迭代器

- #### 大小

字符串a的長度 a.size()    因為是靜態的，所以等價於 a.max_size()  返回整值
字符串a是否為空 a.empty()   返回正誤值

- #### 內容

訪問a的第n位（機器序號） a[n]  或 a.at(n)  
訪問a的第一位（第0位） a.front()  或 a[0]
訪問a的最後一位 a.back()  或 a[a.size()-1]

- #### 指針

返回一個指向數組首個元素的指針 a.data()  
用途：可以像使用傳統的C風格數組那樣訪問和操作array的元素，如訪問某一個的值可以使用* a.data()
當函數的參數列表想要使用「數組退化成的指針」時，可以使用a.data()作為參數傳入

- #### 賦值

為a中所有元素賦相同初始值 a.fill(n)  所有元素賦值為n
支持整個賦值如 a1={1,2,3} array<int, 3> a2 = a1; a2={1,2,3}
這裡必須兩個的類型和大小完全相等，否則不能賦值

- #### 交換  交換兩個陣列/數組的內容 a.swap(b)

### vector  匚艹向量函數庫

> 所有變量名前面都要統一加std::  除非函數中加了using namespace std;

容器：vector<type> XL，其中type是裡面存貯的數據類型

- #### 遍歷

迭代器：支持八種函數生成隨機訪問迭代器

- #### 大小

| 功能	    | 寫法			          | 返回值 | 說明	      |
|--------|----------------|-----|----------|
| 大小	    | `x.size()`	    | 整值  | 		       |
| 是否為空   | `x.empty()`	   | 正誤值 | 		       |
| 目前分配大小 | `x.capacity()` | 整值  | 		       |
| 最大的大小  | `x.max_size()` | 整值  | 數值根據環境而定 |

更改字符串的大小為n x.resize(n)

無返回值，多出來空間的用0填充，少掉的空間將向量截斷
*重載函數：多出來的用指定的數字m填充 x.resize(n, m) 或str.resize(n,16)

預留空間為n x.reserve(n)
不改變向量大小，但是可以避免頻繁地分配內存

- #### 初始化

| 功能			          | 寫法											                                 |
|----------------|-----------------------------------------------|
| 線性向量預設大小	      | `vector<int> XL(n)`						                     |
| 線性向量預填滿		      | `vector<int> XL(n, 0)`						                  |
| 創建平面向量		       | `vector<vector<int>> XL`					                 |
| 平面向量預設大小	      | `vector<vector<int>> XL(n, vector<int>(m))`   |
| 平面向量預填滿		      | `vector<vector<int>> XL(n, vector<int>(m,0))` |
| 讓向量xl1為xl2賦初始值 | `vector<int> xl2(xl1)`						                  |

- #### 內容

| 功能			         | 寫法						                   |
|---------------|----------------------------|
| 訪問第n位機器序號	    | `x[n]`/`x.at(n)`		         |
| 訪問第一位/第0位機器序號 | `x.front()`/`x[0]`		       |
| 訪問最後一位		      | `x.back()`/`x[x.size()-1]` |

- #### 添加/插入/刪除

| 功能		        | 寫法			          |
|-------------|----------------|
| 在向量末尾添加新元素a | x.push_back(a) |
| 插入元素		      | x.insert(it,a) |
| 重複元素插入	     | 				           |
| 範圍插入		      | 				           |
| 使用初始化列表插入   | 				           |
| 刪除單個元素	     | 				           |
| 			         | 				           |
| 			         | 				           |

移除向量末尾的元素 x.pop_back()

刪除
〡 x.erase(it)
刪除x[i] begin()+i 倒數第j個就是end()-j

〢刪除系列元素 x.erase(it1,it2)
開頭保留k個 begin()+k， 結尾
保留l個end()-l

〣清空內容 x.clear()  移除向量中的所有元素

### tuple 匚艹元組函數庫

所有變量名前面都要統一加std::  除非函數中加了using namespace std;
容器：元組 tuple<type1,type2,typeN> YuehBing ，其中type是裡面的類型，可以不一樣，相當於數對的泛化形式，代替實例化的結構體

初始化
使用構造函數 tuple<string,char,int> z("ShuoWen",'Y',13);
使用初始化列表 tuple<string,char,int> x= {"ShuoWen",'Y',13};
使用make_tuple函數 tuple<string,char,int> x= make_tuple("ShuoWen",'Y',13);
使用其他元組初始化 tuple<string,char,int> y(x);

調用元素
get<N>(YB)   索引從0開始

大小
tuple_size<decltype(YB)>::value a為元組的名字返回int值

解綁
tie(a, b, c) = YB 其中a,b,c的類型必須和YB裡面的類型相同，或者可以隱式轉換

### stack  匚艹雲棧堆疊函數庫

- 名稱：CN棧 TW堆疊
- 注意：所有變量名前面都要統一加`std::`  除非函數中加了`using namespace std`;
- 容器：`stack<type> z` 其中`type`是裡面存貯的數據類型，如`int`，也可以是`string` `pair`等非常複雜的數據類型

| 功能	   | 寫法			         | 返回值 | 說明										                              |
|-------|---------------|-----|-------------------------------------------|
| 入棧/壓棧 | `z.push(a)`   | 	   | 使用常量、變量、變量的引用都可以						                    |
| 出棧/彈棧 | `z.pop()`	    | 	   | 										                                |
| 查看棧頂  | `z.top()`	    | 頂端值 | / 註1：出棧並不返回值，查看棧頂也並不會刪除棧頂				             |
| 是否為空  | `z.empty()`   | 正誤值 | \ 註2：在操作之前一定要注意棧是否為空					                 |
| 檢查大小  | `z.size()`	   | 整值  | 										                                |
| 構造入棧  | `z.emplace()` | 	   | `z.emplace(6)` == `int a=6` + `z.push(a)` |
| 交換內容  | `a.swap(b)`   | 	   | 大小不一樣也可以交換								                        |

- #### 使用向量模擬

| 功能	   | 寫法			         |
|-------|---------------|
| 入棧/壓棧 | `push_back()` |
| 出棧/彈棧 | `pop_back()`  |
| 查看棧頂  | `back()`	     |
| 是否為空  | `size()`	     |
| 檢查大小  | `empty()`	    |

- #### 使用數組模擬

```c++
int z[100]; // 很大的時候使用向量，然後在初始化的時候改變大小
int u = 0; // 棧頂指針
void init() { u = 0; }
void push(int x) { z[++u] = x; }
void pop() { z[u--] = 0; } // 是否為空？
int top() { return z[u]; } // 是否為空？
int size() { return u; }
bool empty() { return u <= 0; }
```

### queue 匚艹行伍佇列函數庫

> 所有變量名前面都要統一加std::  除非函數中加了using namespace std;
> 容器：queue<type> d，其中type是裡面存貯的數據類型

| 功能   | 寫法			         | 返回值 | 說明										                              |
|------|---------------|-----|-------------------------------------------|
| 隊尾入隊 | `d.push(a)`   | 	   | 隊首指隊列裡最早添加的元素							                      |
| 隊首出隊 | `d.pop()`	    | 	   | 隊尾指隊列裡最新添加的元素							                      |
| 查看隊首 | `d.front()`   | 	   | 										                                |
| 查看隊尾 | `d.back()`	   | 	   | 										                                |
| 是否為空 | `d.empty()`   | 正誤值 | 										                                |
| 檢查大小 | `d.size()`	   | 整值  | 										                                |
| 構造入隊 | `z.emplace()` | 	   | `d.emplace(6)` == `int a=6` + `d.push(a)` |
| 交換內容 | `a.swap(b)`   | 	   | 大小不一樣也可以交換								                        |

直接構造並入隊列：d.emplace()   裡面的參數就是構造並入隊列中的元素
創建變量和變量入隊二合一 d.emplace(6) int a=6 + d.push(a)
交換兩個隊列的全部內容：a.swap(b)   註：大小不一樣也可以交換

註：堆疊和佇列兩個屬於『半封裝型』數據結構，所以不提供遍歷、清空等操作

- #### 使用數組模擬隊列

```c++
int d[100]; // 很大的時候使用向量，然後在初始化的時候改變大小
int u = 0; // 隊首指針
int w = -1; // 隊尾指針
void init() { u = 0, w = -1; }
void push(int x) { d[++w] = x; }
void pop() { d[u++] = 0; } // 是否為空？
int front() { return d[u]; } // 是否為空？
int back() { return d[w]; } // 是否為空？
int size() { return w - u + 1; }
bool empty() { return u > w; }
```

- #### 限數隊列

在普通隊列的「入隊」操作上加上判斷即可實現，隊列滿是人為的「滿」不是程序的「溢」

```c++
if ( 隊列滿 )  d.pop() 
d.push(x)
```

- #### 循環隊列

和上面那個類似，但是由於是由靜態數組製作的，這個是真的是程序的溢出，

```c++
const int N=100;
int d[N];
int u = 0; int w = -1;

void init() { u = 0; w = -1;}
int size() {
if (w >= u)  return w - u + 1;
else return N - u + w + 1; // 考慮環繞的情况
}
bool empty() { return u == w + 1 || (u == 0 && w == -1); }
void push(int x) {
w = (w + 1) % N; d[w] = x;
if (w == u && size() > 1) u = (u + 1) % N;
}
void pop() { d[u] = 0; u = (u + 1) % N; }
int front() { return d[u]; }
int back() { return d[w]; }
```

優先隊列（堆）
容器：priority_queue<type> d，其中type是裡面存貯的數據類型，元素的出隊順序是根據優先級來決定的，優先級相同時，纔按照入隊順序出隊，這是一個基於堆的數據結構
入隊列 d.push() 元素入隊，並且按照優先級排列；時間複雜度log2n
出隊列 d.pop()  元素出隊，賸餘的重新排列；時間複雜度log2n

檢查 top()   查看優先級最高的元素
不能查看優先級最低的元素，因為實現原理是堆，所以最後一個元素可能並不是優先度最低的，標準庫不提供權限，自己實現的也不應該存取

檢查是否為空 d.empty()    無參數，返回正誤值
檢查大小 d.size()     無參數，返回整值

直接構造並入隊列：d.emplace()   裡面的參數就是構造並入隊列中的元素
交換兩個隊列的全部內容：a.swap(b)

默認情況下，priority_queue 使用std::less<T>排序，隊首是最大的
隊首最小 <functional>  priority_queue<int, vector<int>, greater<int>> d;

求第幾小的數用前面的，求第幾大的數用後面的，因為這個隊列不開放隊尾查詢
使用這個語句更新d.push(i); if (d.size() > dijida)  d.pop();

### deque 匚艹雙相佇列函數庫

- 名稱：CN雙向隊列 TW雙向佇列
- 注意：所有變量名前面都要統一加`std::`  除非函數中加了`using namespace std`;
- 容器：`deque <type> S` 其中`type`是裡面存貯的數據類型，可以存貯複雜的數據類型
- 注意：雙端隊列並不是半封裝數據類型，牠更傾向於向量，衹是提供了更多角度操作

- #### 遍歷

迭代器：支持八種函數生成隨機訪問迭代器

- #### 初始化

隊列預設大小n deque<int> s(n);
預設大小n並填滿值m deque<int> s(n, m);
使用初始化列表 deque<int> s ={1,2,3,4,5};
使用其他隊列 deque<int> ss(s);
使用迭代器範圍 deque<int> s(it1, it2);

- #### 大小

檢查隊列大小 s.size()     返回整值
檢查隊列最大的大小 s.max_size()  返回整值，數值根據環境而定
檢查隊列是否為空 s.empty()    返回正誤值
更改隊列的大小為n s.resize(n)
無返回值，多出來空間的0填充，少掉的空間將字符串截斷
*重載函數：多出來的用指定的元素填充 s.resize(n,a) 或s.resize(n,100)

- #### 內容

訪問第n位（機器序號）s[n]  或 s.at(n)  
訪問第一位（第0位） s.front() 或 s[0]
訪問最後一位 s.back()  或 s[s.size()-1]

- #### 加入/插入

在隊首加入新元素a s.push_front(a)
在隊尾加入新元素a s.push_back(a)

在第n位（機器序號）之前插入元素a s.insert(s.begin()+n,a);
*重載函數：插入y個相同的元素a s.insert(s.begin()+n,y,a);
用迭代器插入一段 s.insert(s.begin()+n,it1,it2);

- #### 構造加入

emplace()  emplace_front()  emplace_back()
自動調用構造函數 s.emplace_back(a, b); s.push_back({a, b});

- #### 刪除/抽出

刪除隊首元素 s.pop_front()
刪除隊尾元素 s.pop_back()

刪除第n位（機器序號）的元素 s.erase(s.begin()+n);
*重載函數：刪除第x位到第y位的元素
清空 s.clear()  移除隊列中的所有元素

- #### 重新賦值

所有的元素都不要，整體更換新的值
重複賦n個相同的值m s.assign(n, m);
使用迭代器賦值 s.assign(it1,it2)  
使用初始化列表 s.assign({1, 2, 3, 4, 5})

- #### 使用數組模擬

- 从開放性上更接近隊列，只開放兩端的權限
- 从實現上沒有辦法在前面加入，否則直接就有這個結構了

```c++
int q[100];	 // 很大的時候使用向量，然後在初始化的時候改變大小
int u = 0;	  // 隊首指針
int w = -1;	 // 隊尾指針
void init() { u = 0, w = -1; }
void push_back(int i) { q[++w] = i; }
void pop_front() { q[u++] = 0; }	   // 操作之前要檢查：是否為空
void pop_back()  { q[w--] = 0; }	   // 操作之前要檢查：是否為空
int front() { return q[u]; }		   // 操作之前要檢查：是否為空
int back()  { return q[w]; }		   // 操作之前要檢查：是否為空
bool empty() { return u > w; }
```

### map / unordered_map  匚艹鍵值對地圖函數庫

變量名稱為map<type1,type2> t  (u)map通用特性 umap無序特有 map有序特有

| 比較	   | map  映射表						                   | unordered_map  無序映射表			         |
|-------|----------------------------------|---------------------------------|
| 底層實現  | 紅黑樹							                       | CN：ㄏㄕ表 TW：散列表				               |
| 時間複雜度 | `O(log n)`  `1e6->20`			         | 平均`O(1)` 最壞 `O(n)`			           |
| 有序性   | 按照鍵的自然順序進行排序<br/>默認情况下按照鍵的升序排列。  | 沒有特定的順序<br/>插入的順序也不會影響鍵值對的存儲順序。 |
| 查找速度  | 當鍵的數量較小或者鍵的比較操作代價較低時較快		         | 大多數情況下較快						                  |
| 選擇	   | 如果需要有序性，或者對元素的順序有要求，需要遍歷的時候衹能用這個 | 无特殊要求，或對插入、删除和查找操作的性能有較高要求	     |

- #### 遍歷

無序：支持四種函數生成隨機訪問迭代器（不支持四種反向迭代器）
有序：支持八種函數生成隨機訪問迭代器
兩種的迭代器不能互相使用，因為底層的實現是不同的

初始化
使用初始化列表  (u)map<string,int> t = {{"ShuoW",613},{"Horng",210}};
使用其他地圖    (u)map<string> tt(t);
使用迭代器範圍  (u)map<int> t(t.begin(), t.end());
註：祇有完全對應才能賦值，vector不能為(u)map賦值，umap和map不能互相賦值
自定義排序規則 map<int, string, decltype(&cmp)> t(cmp);

內容
使用鍵作為索引訪問值，但是不能使用值來查找鍵 t['Yao']  t.at('Yao')
在這裡裡面不存在的鍵也能被找到，但是就是默認元素
這裡的值是可修改的，也就是加入可以直接使用這個方法
使用鍵作為索引直接賦值如果已經有鍵，就修改裡面的值

加入
t.insert({j,z})  把鍵值對{j,z}插入集合，如果鍵已存在，則不會進行任何操作。
如t = {{"s",613},{"h",210}}; t.insert({"s",614}); s的值不會改變
使用數對的構造函數 t.insert(make_pair({j,z}));
直接構造入集合：j.emplace(j,z)
t1.insert(t2.begin(),t2.end()) 可以實現t1 t2合併
刪除
t.erase(i)   刪除值為i的元素，如果沒有找到，則不會進行任何操作。
t.clear()    清空地圖

尋找
t.count(i) 返回 值為i的數的個數，因為不重複，所以有->1，沒有->0
t.find(i)  返回 值為i的數的迭代器，如果沒有找到就返回end()迭代器
一般衹用於找有沒有這個元素，使用如下代碼 if(j.find(i) != j.end()) {/*有*/}

大小
是否為空 t.empty()  返回正誤值
目前大小 t.size()   返回整值
最大大小 t.max_size()  返回整值，值為常數，依照環境而定

交換 交換兩個集合的全部內容：a.swap(b)

不支持使用sort函數排序，因為排序了，如果要排序，可以使用向量接住再排序vector<pair<int,int>> v(t.begin(), t.end())

特有

有序：和比較有關
t.lower_bound(a) t.upper_bound(a) 用法同algorithm庫中的
t.equal_range(a) 返回一個左閉右開的範圍pair<it, it>，表示在這一段裡面鍵為a
key_comp()  比較鍵的前後
value_comp()  實際上還是比較鍵的前後（理論上考慮整個鍵值對）
auto comp = t.key_comp(); comp(key1, key2)
auto comp = t.value_comp()   comp({ }, { })

無序：和桶有關
t.bucket_count()   桶的數量
t.max_bucket_count()  返回最多的數量，依據環境而定
t.bucket_size(i)  返第i號桶裡面的元素個數
t.bucket(Key)   查詢Key的在哪一個桶裡面

set / unordered_set 匚艹數集函數庫
註：set 和 unordered_set 的區別類似于 map 和 unordered_map 的區別

遍歷、刪除、尋找、大小、交換 同上map
初始化
使用初始化列表  (u)set<string> j = { "Yau","Shuo","Wen" };
使用其他集合    (u)set<string> m(j);
使用迭代器範圍  (u)set<int> j(v.begin(), v.end());

加入
j.insert(i)  把i插入集合，如果該元素已存在，則不會進行任何操作。
直接構造 j.emplace()

多重版本：multimap multiset unordered_multimap unordered_multiset
用法幾乎和原來一樣，祇不過存貯的元素是可重複的
單一版本 多重版本
insert 如果元素存在，插入失敗 仍然插入成功
find 找到元素的位置返回迭代器 找到第一個位置就返回
erase 刪除對應的鍵的內容 刪除對應的鍵的所有內容，如果要删除单个内容，find这个元素，用迭代器删除
count 返回值最多為1 返回值最多

## 實用工具

bitset 匚艹逐位操作函數庫
位運算符（這些運算符是計算機編程通用的，而不是這個庫裡面獨有的，但是和這個庫裡面的內容息息相關，所以記錄在這裡）

位與 a & b
a和b的二進制數字里，兩者每一位的0取交集，有0為0
位或 a | b
a和b的二進制數字里，兩者每一位的1取交集，有1為1
位異或 a ^ b
a和b的二進制數字里，兩者每一位相同為1，不同為0
位非  ~ a
a的二進制數字里，每一位取反（取反範圍取決於該數據類型的大小）
註：因为『位非』反转了二进制表示中的每一位，包括符號位，所以结果通常会是一个负数，要避免這個情況就要使用us.char us.int
等無符號類型，這些類型沒有任何一位表示符號，不會被反轉正負。
左移運算符 <<
n << x 把n的二進制所有位向左移指定的位數。右邊空出的位用0填充。
如 5<<2 為00000101→00010100
實際效果是n變為n*2x迭如本例5→5*22=20
在實際位運算的時候2n可以使用1<<n代替
右移運算符 >>
n >> x 把n的二進制所有位向右移指定的位數。左邊空出的位用0填充。
如 20>>2 為 00010100→00000101
實際效果是n變為n÷2x迭如本例20→20/22=5

所有變量和函數名前面都要統一加std::  除非函數中加了using namespace std;
容器：原子串 bitset<n>  大小為n位的位容器，所有位初始為0
可以用以下方法初始化：
〡 bitset<8> b1(42)  通過整數初始化，初始化的值為42的二進制00101010
〢 bitset<8> b2(string("11001010"))  通過字符串初始化
訪問位可以和數組字符串一樣通過訪問索引訪問，如b[2]，但是這裡的索引和數組和字符串的從左至右的索引方式是不同的，對於bitset<8>
來說，最右邊的索引反而是0，最左邊的反而是7，以下的第某為都是索引序號，注意不要混淆

註：C++的特性，下面講把true/false 和 1/0 混為一談，簡化表達
更改
set(i)  設第i位的值為1
*重載函數 set(i,true/false)  設第i位的值為1或0
reset() 設置第i位的值為0
flip()  翻轉第i位的值（1→0 0→1）

檢查
all()  檢查是否所有位都是1，返回正誤值
any()  檢查是否至少一位是1，返回正誤值
none() 檢查是否沒有一位是1，返回正誤值
count() 檢查是1的位的個數，返回整值
size()  檢查位的數量，返回整值
test(n) 檢查第n位（原子串序號）是不是1，返回正誤值

轉換
to_string()  轉化為字符串，用字符串接收
to_ulong()   轉換為無符號長整數型
to_ullong()  轉換為無符號超長整數型

內建函數
__builtin_clz(x): 計算x的二進制表示中，前導的零的個數
__builtin_ctz(x): 計算x的二進制表示中，尾部的零的個數
__builtin_popcount(x): 計算x的二進制表示中，1的個數
__builtin_parity(x): 計算x的二進制表示中，1的個數的奇偶性（0->偶，1->奇）。
__builtin_ia32_ror(x, n): 對x進行循環右移操作
__builtin_ia32_rol(x, n): 對x進行循環左移操作
一些有用的小代碼模板

1.逐一檢查i的二進制的每一位
for (int j = 0; j < n; ++j)
if ((i & (1 << j)) != 0)
{/*一些操作*/}
2.大數壓位
如果題幹這樣說：由于本題數據較大，因此輸出的時候采用特殊的輸出方式：用
0 或 1 代表每個詢問的答案，將每個詢問的答案依次從左到右排列，把得到的串視爲一個二進制數，輸出這個二進制數除以m的餘數。
結果是 hh=1 或者 hh=0
就這樣寫ans = ((ans * 2) + hh) % m;

找到數組里唯一的數字（其他數字成對出現）
把所有的數字全部異或，結果就是答案，（成對出現的都符合a^a=0，剩下的就是答案）
交換兩個數字（不使用臨時變量）
a ^= b; b ^= a; a ^= b;

	int mask = xorResult & (-xorResult); // 找到最低有效位

異或問題
使用常數時間複雜度求出 0⊕1⊕2⊕3⊕…⊕n
// 簡便寫法
ull xor_n(ull n)
{
unsigned t = n & 3;
if (t & 1) return t / 2u ^ 1;
return t / 2u ^ n;
}

algorithm 匚艹通用演算法函數庫
所有變量和函數名前面都要統一加std::  除非函數中加了using namespace std;
比較
● 返回較大值max(a,b)	  
● 返回較小值min(a,b)
最值更新可以使用這樣的方法 maxA=max(maxA,新的比較值) 替代傳統if語句

以下函數可以使用迭代器查詢數組內的最值
● 區域返回最值對minmax( { … } )  
使用初始化列表作為參數，可以返回數對，first是最小值，second是最大值
如果使用兩個迭代器作為參數，那麼返回迭代器/指針，要使用*解引用得到值

排序   
原版：
sort(it1, it2)  從小到大排序123456
註：字符串的是每一位按照十六進制碼排序，數字<-大寫<-小寫  "12Abab"

「重載」函數：穩定排序
stable_sort(it1, it2) （排序且保留相等元素之間的順序關係）
比如114514 排序之後111445

重載函數：關於升序降序
sort(Arr,Arr+6,less<int>())     由小到大，123456
sort(Arr,Arr+6,greater<int>())  由大到小，654321

「重載」函數：部分排序
將序列中的前k個最小元素放在序列的最前面，而其餘元素的順序不確定。
partial_sort(v.begin(),v.begin() + k,v.end());

使用簡化表達式自定義排序規則
sort(開始位置, 結束位置, [](數組中提取出的待比較元素甲乙的引用&){排序規則})
說明：
1.開始位置和結束位置使用的是迭代器如 v.begin()
2.因為要修改數組元素的值，所以必須要引用 const int& a
3.排序規則: 小於號< 升序排序， 大於號> 降序排序
4.使用簡化表達式可以做到比較的對象和排序的元素分離
例如：要對一個vector<pair<int,int>> xl的數對向量按照每個元素數對的後座標升序排序，應該寫成
sort(xl.begin(),xl.end(),[](const pair<int,int>& a, const pair<int,int>& b) {return a.second < b.second;});

按照pair的規則，可以輕鬆地類推到「按照結構體/組 某元素為基準排序」

穩定排序也是可以用簡化表達式的

二分查找
必須先標準排序 題目是單調的也沒什麼損失
● 在it1~it2範圍內第一個不小於c的元素的位置 lower_bound(it1,it2,c)
即c元素第一次出現的位置
● 在it1~it2範圍內第一個大於c的位置 upper_bound(it1,it2,c)
即c元素最後一次出現的位置的後一個位置
● 在it1~it2範圍內是否有c binary_search(it1,it2,c)
返回正誤型變量（實際上是1 0代表的正確與錯誤）

使用簡化表達式重載
不小於-> 不大於 auto it = upper_bound(it1,it2,c)  if (it != it1) --it;
大於->小於 auto it = lower_bound(it1,it2,c)  if (it != it1) --it;
出現的次數就是 upper-lower
迭代器轉索引：減去begin()
不能判斷有無，所以必須在確保有這個元素的情況下才能查找。如果沒有這個元素，這兩個都會指向大於這個元素的第一個元素的位置
不可以使用greater<int> 重載！

批量檢查
批量檢查所有類型為type的元素it1~it2是否滿足condition條件並且對結果……
〡 『與』計算 all_of (it1, it2,[](type x) {return condition;})
〢 『或』計算 any_of (it1, it2,[](type x) {return condition;})
〣 『與非』計算 none_of(it1, it2,[](type x) {return condition;})
返回正誤型變量（實際上是1 0代表的正確與錯誤）
1.這個不是二分查找，所以不用擔心順序的問題，比如『或』計算就可以尋找是否存在某一個元素（但是效率會低一些，時間複雜度為n）
2.如果想要使用定義在簡化表達式外部的局部變量，必須在捕獲列表（擷取清單）中明確指定它。 [=] 表示通過值捕獲的方式，捕獲所有外部作用域中的變量，
比如要和外部變量WayBuh做比較，必須這樣寫
all_of (s.begin(),s.end(),[=](char x){return x==WayBuh;})

批量操作
1.在it1~it2範圍內調轉字符串/數組方向 reverse(a,b)
2.在a~b範圍內把所有字符/數字c轉換為d replace(a,b,'c','d')
3.在a~b範圍內計數字符c/數字c出現的次數 count(a,b,'c')  返回值為整數類型
4.批量對所有元素it1~it2套用Fx函數 for_each(it1,it2,Fx)

例如每一個元素乘以2
for_each(a.begin(), a.end(), [](int& x) {x = x * 2; });

字典序
● 字典序小於 lexicographical_compare(a.it1, a.it2, b.it3, b.it4)
比較的是a在it1~it2範圍內和b在it3~it4範圍內的詞典序大小，如果a的更小，返回true，如果相等或者b的更小，返回false；
如果應用在字符串比較上，可以比較兩個字符串形式的數的大小，字典序等價於大小
● 全排列的下一位 next_permutation(it1,it2)  只在it1~it2中重新排列
如果排到了排列終點，那麼會將數組恢復到排列起點，并返回false
● 全排列的上一位 prev_permutation(it1,it2)  只在it1~it2中重新排列
如果排到了排列起點，那麼會將數組恢復到排列終點，并返回false

註：
〡全排列函數裏提到的排列起點指升序隊列如{1,2,3}，這是字典序最小的排列方式，排列終點指降序隊列如{3,2,1}，這是字典序最大的排序方式
〢返回的false是當函數用在循環條件的時候用來退出循環的
〣如果序列中有重複元素，全排列函數會去重
刪除重複元素
lengths.erase(unique(lengths.begin(), lengths.end()), lengths.end());

堆
堆可以使用向量來表示，這是維持堆排序的函數，默認是最大堆，也就是堆頂是最大的

● 構建堆 make_heap(it1,it2)  O(n)
把無序數組轉化為堆
● 插入元素 push_heap(it1,it2)  O(log n)
將數組末尾元素安排到正確位置，在這個函數之前配合push_back()加入到末尾
● 删除根節點 pop_heap(it1,it2)    O(log2n)
把根節點元素放在數組最後，其他的重新排列，在這個函數之後配合pop_back删除
● 堆排序 sort_heap(it1,it2)   O(nlog n)
比快速排序穩定
● 是否是堆 is_heap(it1,it2)     O(m)
返回正誤型變量
● 從哪個起不是堆的排序 is_heap_until(it1,it2)  本身滿足會返回end()

所有函數都支持使用greater<int>()重載，重載之後變成最小堆，堆頂最小

utility 匚艹效用元件函數庫
所有變量和函數名前面都要統一加std::  除非函數中加了using namespace std;
容器：數對 pair<type1,type2> D ，其中兩個type是裡面的類型，可以不一樣

初始化
使用構造函數 pair<string,int> z(" ",114514);
使用初始化列表 pair<string,int> x= {" ",114514};
使用make_pair函數 pair<string,int> x= make_pair(" ",114514);
使用其他數對初始化 pair<string,int> y(x);

調用元素
D.first D.second 類似於結構體，祇不過元素名稱固定為這兩個
get<0>(D) get<1>(D)  調用出來的東西既可以操作又可以改變

註：不.first或.second也能使用比較運算符，它會首先比較第一個元素，如果第一個元素相等，則再比較第二個元素。

千里之行
// 尋找滿足某特定條件的最左側元素的常用手段，特別是想要找的是"第一個"滿足條件的元素時。
int ZuoChar(int l, int r /*要代入的條件*/)
{
while (l < r)
{
int mid = l + r >> 1;
if (tiaojian(mid))   r = mid; // check()判斷mid是否滿足性質
else l = mid + 1;
}
return l;
}
// 適用于尋找滿足某特定條件的最右側元素，特別是當我們想要找的是"最後一個"滿足條件的元素時。
int YowChar(int l, int r /*要代入的條件*/)
{
while (l < r)
{
int mid = l + r + 1 >> 1;
if (tiaojian(mid))   l = mid;
else r = mid - 1;
}
return l;
}
// 浮點數二分
double FD(double l, double r, /*要代入的條件*/)
{
const double eps = 1e-10; // eps 表示精度，取决于题目对精度的要求
while (r - l > eps)
{
double mid = (l + r) / 2;
if (check(mid)) r = mid;
else l = mid;
}
return l;
} 行伍序齒
『鄰域置換』演算法
// 冒泡算法，時間複雜度n2，不推薦使用
void PX (int Arr[], int size)
{
for (int i = 0; i < size - 1; i++)
for (int j = 0; j < size - 1 - i; j++)
if (Arr[j] > Arr[j + 1])    swap(Arr[j], Arr[j + 1]);
}
『斷杼擇鄰』演算法
// 選擇排序，時間複雜度n2，不推薦使用
void PX(int Arr[], int size)
{
for (int i = 0; i < size - 1; i++)
{
int min = i;
for (int j = i + 1; j < size; j++)
if (Arr[j] < Arr[min])  min = j;
if (min != i)  swap(Arr[min], Arr[i]);
}
}
『同舟共濟』演算法
// 『插入排序』，應用場景為幾乎已經排好序的情況下，在整齊的條件下複雜度為n，但在混亂的條件下複雜度為n2
void PX (int Arr[], int size)
{
for (int i = 1; i < size; i++)
{
int temp = Arr[i];
for (int j = i; j > 0 && Arr[j - 1] > temp; j--)
Arr[j] = Arr[j - 1];
Arr[j] = temp;
}
}
『平分秋色』演算法
// 俗稱『快速排序』，平均時間複雜度為 nlog n，最壞情況下為n2
void PX (int q[], int l, int r)
{
if (l >= r) return;

	int i = l - 1, j = r + 1, x = q[l + r >> 1];
	while (i < j)
	{
		do i++; while (q[i] < x);
		do j--; while (q[j] > x);
		if (i < j) swap(q[i], q[j]);
	}
	PX (q, l, j), PX (q, j + 1, r);

}
應機立斷
// 快速选择算法，找0出數組裏第k小的數（k從1開始）
int HF(vector<int>& arr, int l, int r) // 公用函數：區間劃分函數
{
int jz = arr[r];
int i = l - 1;  
for (int j = l; j < r; j++)
if (arr[j] < jz)  { i++; swap(arr[i], arr[j]); }
swap(arr[i + 1], arr[r]);
return i + 1;  
}
// 找第k小的數的代碼
int KX(vector<int>& arr, int l, int r, int k)
{
if (l == r) return arr[l];
int p = HF(arr, l, r);
int len = p - l + 1;
if (k == len) return arr[p];
else if (k < len)  return KX(arr, l, p - 1, k);
else return KX(arr, p + 1, r, k - len);
}
// 找第k大的數的代碼
int KX(vector<int>& arr, int l, int r, int k)
{
if (l == r) return arr[l];
int p = HF(arr, l, r);
int len = p - l + 1;
int lr = r - p + 1;
if (k == lr) return arr[p];
else if (k < lr) return KX(arr, p + 1, r, k);
else return KX(arr, l, p - 1, k - lr);
}

『殊途同歸』演算法
// 『歸併排序』，時間複雜度為 nlog n，需要額外的內存支持
void PX(vector<int>& q, vector<int>& t, int l, int r)
{
if (l >= r) return;
int mid = (l + r) / 2;
PX(q, t, l, mid);
PX(q, t, mid + 1, r);
int i = l, j = mid + 1, k = 0;
while (i <= mid && j <= r)
{
if (q[i] <= q[j]) t[k++] = q[i++];
else t[k++] = q[j++];
}
while (i <= mid) t[k++] = q[i++];
while (j <= r)   t[k++] = q[j++];
for (int p = 0; p < k; p++) q[l + p] = t[p]; // 將tmp中的元素複製回原數組q中相應的位置
}

天地無用
// 基於歸併排序求逆序對數量，逆序對的數量就是冒泡排序中交換的次數
long long PX(vector<int>& q, vector<int>& t, int l, int r)
{
if (l >= r) return 0;
long long g = 0;
int mid = (l + r) / 2;
g += PX(q, t, l, mid); // 對左半邊進行遞歸
g += PX(q, t, mid + 1, r); // 對右半邊進行遞歸

	// 合並左右兩邊，並計算逆序對數量
	int i = l, j = mid + 1, k = l;
	while (i <= mid && j <= r)
	{
		if (q[i] <= q[j])   t[k++] = q[i++];
		else
		{
			t[k++] = q[j++];
			g += (mid - i + 1); // 統計逆序對數量
		}
	}
	while (i <= mid)  t[k++] = q[i++];
	while (j <= r)	t[k++] = q[j++];
	for (i = l; i <= r; i++)  q[i] = t[i]; // 將臨時數組中的元素複製回原數組
	return g;

}

朝三暮四
// 支持十進制轉為2~無窮進制，只要設置合適的映射參數
string K = "0123456789ABCDEF";// 大於16進制還可以往後加GHI……
string JZ(int n, int j) // 整數-待轉換數字 整數-目標進制
{
if(n==0) return "0";
if (n / j == 0)  return string(1, K[n % j]);
else return JZ(n / j, j) + K[n % j];
}

// 高精度進制轉換程序
string JZ(int a, int b, string Y)// 整數-原來進制 整數-目標進制 字符串-待轉換數字
{
vector<int> n;
for (auto c : Y)
{
if (c >= '0' && c <= '9') n.push_back(c - '0');
else if (c >= 'A' && c <= 'Z') n.push_back(c - 'A' + 10);
else if (c >= 'a' && c <= 'z') n.push_back(c - 'a' + 36);
}
reverse(n.begin(), n.end());
vector<int> res;
while (!n.empty())
{
int r = 0;
for (int i = n.size() - 1; i >= 0; i--)
{ n[i] += r * a; r = n[i] % b; n[i] /= b; }
res.push_back(r);
while (!n.empty() && n.back() == 0) n.pop_back();
}
reverse(res.begin(), res.end());
string Z;
/* 按照原來的映射轉換回去即可 */
return Z;
} 精於律己
以和為貴
string Jia(const string& a, const string& b)
{
int i = a.size() - 1, j = b.size() - 1, jw = 0;
string c = "";

	while (i >= 0 || j >= 0 || jw)
	{
		int sum = jw;
		if (i >= 0)  sum += a[i--] - '0';
		if (j >= 0)  sum += b[j--] - '0';
		jw = sum / 10;
		c += to_string(sum % 10);
	}
	reverse(c.begin(), c.end());
	return c;

}

勤減養德
// 無需負數的字符串減法見高精度除以高精度除法（魚和熊掌）
string Jean(const string& a, const string& b)
{
bool z = true;
string l = a, s = b;
if (a.size() < b.size() || (a.size() == b.size() && a < b))
l = b, s = a, z = false;
string c;
int t = 0, i = l.size() - 1, j = s.size() - 1;
while (i >= 0 || j >= 0 || t)
{
int li = i >= 0 ? l[i--] - '0' : 0;
int si = j >= 0 ? s[j--] - '0' : 0;
t = li - si - t;
if (t < 0)
{ t += 10; c.push_back(t + '0'); t = 1; }
else
{ c.push_back(t + '0'); t = 0; }
}
while (c.size() > 1 && c.back() == '0') c.pop_back();
reverse(c.begin(), c.end());
if (!z) c = "-" + c;

	return c;

}

乘實立身
掃屋企（串整轉串）
string Cherng(string a, int b)
{
if (b == 0) return "0";
int n = a.size();
string c(n, '0');
int jw = 0;
for (int i = n - 1; i >= 0; --i)
{
int w = (a[i] - '0') * b + jw;
c[i] = (w % 10) + '0';
jw = w / 10;
}
if (jw > 0)  c = to_string(jw) + c;
int qdl = c.find_first_not_of('0');
if (qdl != string::npos)
return c.substr(qdl);

	return "0"; 

}

觀天下（雙串轉串）
string Cherng(string a, string b)
{
if (a == "0" || b == "0") return "0";

	vector<int> A(a.rbegin(), a.rend()), B(b.rbegin(), b.rend());
	for (auto& S : A) S -= '0'; 
	for (auto& S : B) S -= '0';

	vector<int> C(A.size() + B.size(), 0);

	for (size_t i = 0; i < A.size(); ++i) 
	{
		for (size_t j = 0; j < B.size(); ++j)
		{
			C[i + j] += A[i] * B[j];
			C[i + j + 1] += C[i + j] / 10; 
			C[i + j] %= 10;
		}
	}
	while (C.size() > 1 && C.back() == 0) C.pop_back();

	string CC(C.size(), '0');
	transform(C.rbegin(), C.rend(), CC.begin(), [](int d) { return d + '0'; });

	return CC;

}

差之毫釐
左右開弓（串整轉串）
pair<string, int> Chwu(string a, int b)
{
vector<int> C;
int r = 0;
for (char num : a)
{
r = r * 10 + (num - '0');
C.push_back(r / b);
r %= b;
}
string ans;
bool lz = true;
for (int num : C)
{
if (num != 0 || !lz)
{
ans.push_back('0' + num);
lz = false;
}
}
if (ans.empty()) ans = "0";
return make_pair(ans, r);
}

魚和熊掌（雙串轉串）
// 無負數的高精度減法程序
string Jean(const string& a, const string& b)
{
string C = a;int Jie = 0;
for (int i = 0; i < C.size(); i++)
{
int A = C [C.size() - 1 - i] - '0';
int B = (i < b.size()) ? (b[b.size() - 1 - i] - '0') : 0;
A -= B + Jie;
if (A < 0)   {A += 10; Jie = 1;}
else Jie = 0;
C[C.size() - 1 - i] = A + '0';
}
size_t it = C.find_first_not_of('0');
if (it != string::npos)   return C.substr(it);

	return "0"; 

}
pair<string, string> Chwu(const string& a, const string& b)
{
string c = ""; string d = "0";
for (char Shuh : a)
{
d = (d == "0") ? string(1, Shuh) : (d + Shuh);
int jw = 0;

		while (d.size() > b.size() || (d.size() == b.size() && d >= b))
		{  d = Jean(d, b);  jw++;  }
		c += (jw + '0'); 
	}

	c = c.find_first_not_of('0') == string::npos ? "0" : c.substr(c.find_first_not_of('0'));
	return { c, d }; 

}

階桺庭花
string JieCheng(int n)
{
if (n == 1)   return "1";
vector<int> res(1, 1);
for (int i = 2; i <= n; ++i)
{
int jw = 0;
for (auto& d: res)
{
int p = d * i + jw;
d = p % 10;
jw = p / 10;
}
while (jw)
{
res.push_back(jw % 10);
jw /= 10;
}
} return vtostr(res); // 將結果從向量轉換為字符串，過程略
}

各有千秋
// 比較兩個『字符串』形式的的數的大小
int bi(string a, string b)
{
if (a.size() != b.size())   return a.size() > b.size() ? 1 : -1;
for (size_t i = 0; i < a.size(); i++)
if (a[i] != b[i])   return a[i] > b[i] ? 1 : -1;
return 0;
}// a<b  -1   a>b 1 a=b 0

雪中送炭
導包：import java.math.BigInteger;
默認參數和返回值類型為大整數，需要特殊注意的數據類型使用->指出
基礎運算
加法 a.add(b)      減法 a.subtract(b)   乘法 a.multiply(b)
除法 a.divide(b)   取餘 a.remainder(b) / a.mod(b)
捆綁商餘 a.divideAndRemainder(b)   返回大整數數組，第0位是商，第1位是餘
絕對值 a.abs()          相反數 a.negate()
求冪 a.pow(b->int)     快速冪 a.modPow(b,m)
較大值 a.max(b)      較小值a.min(b)   比較a.compareTo(b)   -1: a<b 0: a=b 1: a>1
相等 a.equals(b)   返回正誤值 正負 a.signum()   -1:負數 0:零 1:正數

位運算和二進制
左移 a.shiftLeft(n->int)  左移動n位（乘法）
右移 a.shiftRight(n->int) 右移動n位（除法）
按位與 a.and(b)     按位或 a.or(b)     按位异或a.xor(b)
按位與非a.andNot(b)   按位取反 a.not()
指定位清零 a.clearBit(n->int)   指定位設一 a.setBit(n->int)    指定位翻轉 a.flipBit(n->int)
檢查這一位是否為一 a.testBit(n->int) 返回正誤值
二進制補碼 a.toByteArray()  返回字節數組byte[]
補碼中不包括符號位的位數 a.bitLength()   補碼中和符號位不同的位數 a.bitCount()
第一個不為零的索引 a.getLowestSetBit()     散列碼 a.hashCode()

轉換
數字轉大整數 a.valueOf(n->long)  int等的會隱式轉換，所以一個就夠了
轉整數int a.intValue() / a.intValueExact()
轉長整數long a.longValue() / a.longValueExact()
轉短整數short a.shortValueExact()
轉超短整數byte a.byteValueExact()
轉單精度浮點數float a.floatValue()
轉雙精度浮點數double a.doubleValue()
轉字符串數a.toString()  重載函數：a.toString(n->int) 這個字符串數的進制為n（2<=n<=36）

數學知識
最大公因數 a.gcd(b)
質數 a.isProbablePrime(n)  true：可能是質數，false：肯定是合數，參數n為可信度，可以取為100
下一個可能的質數 a.nextProbablePrime()
一個二進制長度為n的可能的質數 probablePrime(n->int , Random rnd)
乘法逆元 a.modInverse(b)     (a * x) % m = 1 返回x

# 千里之行（基礎算法）

尋找滿足某特定條件的最左側元素的常用手段，特別是想要找的是"第一個"滿足條件的元素時。

```c++
int ZuoChar(int l, int r /*要代入的條件*/)
{
	while (l < r)
	{
		int mid = l + r >> 1;
		if (tiaojian(mid))   r = mid; // check()判斷mid是否滿足性質
		else   l = mid + 1;
	}
	return l;
}
```

適用于尋找滿足某特定條件的最右側元素，特別是當我們想要找的是"最後一個"滿足條件的元素時。

```c++
int YowChar(int l, int r /*要代入的條件*/)
{
	while (l < r)
	{
		int mid = l + r + 1 >> 1;
		if (tiaojian(mid))   l = mid;
		else   r = mid - 1;
	}
	return l;
}

```

// 浮點數二分

```c++
double FD(double l, double r, /*要代入的條件*/)
{
	const double eps = 1e-10;   // eps 表示精度，取决于题目对精度的要求
	while (r - l > eps)
	{
		double mid = (l + r) / 2;
		if (check(mid)) r = mid;
		else l = mid;
	}
	return l;
}
```

## 行伍序齒 - 排序

### 鄰域置換

冒泡算法，時間複雜度n2，不推薦使用

```c++
void PX(int Arr[], int size)
{
	for (int i = 0; i < size - 1; i++)
	{
		for (int j = 0; j < size - 1 - i; j++)
		{
			if (Arr[j] > Arr[j + 1]) swap(Arr[j], Arr[j + 1]);
		}
	}
}
```

### 斷杼擇鄰

選擇排序，時間複雜度n2，不推薦使用

```c++
void PX(int Arr[], int size)
{
	for (int i = 0; i < size - 1; i++)
	{
		int min = i;
		for (int j = i + 1; j < size; j++)
			if (Arr[j] < Arr[min]) min = j;
		if (min != i) 
			swap(Arr[min], Arr[i]);
	}
}
```

### 同舟共濟

// 『插入排序』，應用場景為幾乎已經排好序的情況下，在整齊的條件下複雜度為n，但在混亂的條件下複雜度為n2

```c++
void PX(int Arr[], int size)
{
	for (int i = 1; i < size; i++)
	{
		int temp = Arr[i];
		for (int j = i; j > 0 && Arr[j - 1] > temp; j--)
		{
			Arr[j] = Arr[j - 1];
			Arr[j] = temp;
		}
	}
}
```

```
『平分秋色』演算法
// 俗稱『快速排序』，平均時間複雜度為 nlog n，最壞情況下為n2
void PX (int q[], int l, int r)
{
	if (l >= r) return;

	int i = l - 1, j = r + 1, x = q[l + r >> 1];
	while (i < j)
	{
		do i++; while (q[i] < x);
		do j--; while (q[j] > x);
		if (i < j) swap(q[i], q[j]);
	}
	PX (q, l, j), PX (q, j + 1, r);
}
應機立斷
// 快速选择算法，找0出數組裏第k小的數（k從1開始）
int HF(vector<int>& arr, int l, int r) // 公用函數：區間劃分函數
{
	int jz = arr[r]; 
	int i = l - 1;  
	for (int j = l; j < r; j++)
		if (arr[j] < jz)  { i++; swap(arr[i], arr[j]); }
	swap(arr[i + 1], arr[r]); 
	return i + 1;  
}
// 找第k小的數的代碼
int KX(vector<int>& arr, int l, int r, int k)
{
	if (l == r) return arr[l]; 
	int p = HF(arr, l, r); 
	int len = p - l + 1; 
	if (k == len) return arr[p];
	else if (k < len)  return KX(arr, l, p - 1, k);
	else return KX(arr, p + 1, r, k - len); 
}
// 找第k大的數的代碼
int KX(vector<int>& arr, int l, int r, int k)
{
	if (l == r) return arr[l];
	int p = HF(arr, l, r);
	int len = p - l + 1;
	int lr = r - p + 1;
	if (k == lr) return arr[p];
	else if (k < lr) return KX(arr, p + 1, r, k);
	else return KX(arr, l, p - 1, k - lr);
}

『殊途同歸』演算法
// 『歸併排序』，時間複雜度為 nlog n，需要額外的內存支持
void PX(vector<int>& q, vector<int>& t, int l, int r)
{
	if (l >= r) return;
	int mid = (l + r) / 2;
	PX(q, t, l, mid);
	PX(q, t, mid + 1, r);
	int i = l, j = mid + 1, k = 0;
	while (i <= mid && j <= r)
	{
		if (q[i] <= q[j]) t[k++] = q[i++];
		else			  t[k++] = q[j++];
	}
	while (i <= mid) t[k++] = q[i++];
	while (j <= r)   t[k++] = q[j++];
	for (int p = 0; p < k; p++) q[l + p] = t[p]; // 將tmp中的元素複製回原數組q中相應的位置
}

天地無用
// 基於歸併排序求逆序對數量，逆序對的數量就是冒泡排序中交換的次數
long long PX(vector<int>& q, vector<int>& t, int l, int r)
{
	if (l >= r) return 0;
	long long g = 0;
	int mid = (l + r) / 2;
	g += PX(q, t, l, mid);	// 對左半邊進行遞歸
	g += PX(q, t, mid + 1, r); // 對右半邊進行遞歸

	// 合並左右兩邊，並計算逆序對數量
	int i = l, j = mid + 1, k = l;
	while (i <= mid && j <= r)
	{
		if (q[i] <= q[j])   t[k++] = q[i++];
		else
		{
			t[k++] = q[j++];
			g += (mid - i + 1); // 統計逆序對數量
		}
	}
	while (i <= mid)  t[k++] = q[i++];
	while (j <= r)	t[k++] = q[j++];
	for (i = l; i <= r; i++)  q[i] = t[i]; // 將臨時數組中的元素複製回原數組
	return g;
}
```

## 朝三暮四 - 進制轉換

支持十進制轉為2~無窮進制，只要設置合適的映射參數

```c++
string K = "0123456789ABCDEF"; // 大於16進制還可以往後加GHI……
string JZ(int n, int j) // 整數-待轉換數字   整數-目標進制
{
	if (n == 0) return "0";
	if (n / j == 0) return string(1, K[n % j]);
	else return JZ(n / j, j) + K[n % j];
}
```

// 高精度進制轉換程序

```c++
string JZ(int a, int b, string Y) // 整數-原來進制 整數-目標進制  字符串-待轉換數字
{
	vector<int> n;
	for (auto c: Y)
	{
		if (c >= '0' && c <= '9') n.push_back(c - '0');
		else if (c >= 'A' && c <= 'Z') n.push_back(c - 'A' + 10);
		else if (c >= 'a' && c <= 'z') n.push_back(c - 'a' + 36);
	}
	reverse(n.begin(), n.end());
	vector<int> res;
	while (!n.empty())
	{
		int r = 0;
		for (int i = n.size() - 1; i >= 0; i--)
		{
			n[i] += r * a;
			r = n[i] % b;
			n[i] /= b;
		}
		res.push_back(r);
		while (!n.empty() && n.back() == 0) n.pop_back();
	}
	reverse(res.begin(), res.end());
	string Z;
	/* 按照原來的映射轉換回去即可 */
	return Z;
}
```

## 精於律己 - 高精度計算

### 以和為貴 - 加法

```c++
string Jia(const string &a, const string &b)
{
	int i = a.size() - 1, j = b.size() - 1, jw = 0;
	string c = "";

	while (i >= 0 || j >= 0 || jw)
	{
		int sum = jw;
		if (i >= 0) sum += a[i--] - '0';
		if (j >= 0) sum += b[j--] - '0';
		jw = sum / 10;
		c += to_string(sum % 10);
	}
	reverse(c.begin(), c.end());
	return c;
}
```

### 勤減養德 - 減法

```c++
string Jean(const string &a, const string &b)
{
	bool z = true;
	string l = a, s = b;
	if (a.size() < b.size() || (a.size() == b.size() && a < b))
		l = b, s = a, z = false;
	string c;
	int t = 0, i = l.size() - 1, j = s.size() - 1;
	while (i >= 0 || j >= 0 || t)
	{
		int li = i >= 0 ? l[i--] - '0' : 0;
		int si = j >= 0 ? s[j--] - '0' : 0;
		t = li - si - t;
		if (t < 0)
		{
			t += 10;
			c.push_back(t + '0');
			t = 1;
		}
		else
		{
			c.push_back(t + '0');
			t = 0;
		}
	}
	while (c.size() > 1 && c.back() == '0') c.pop_back();
	reverse(c.begin(), c.end());
	if (!z) c = "-" + c;

	return c;
}
```

### 乘實立身 - 乘法

- #### 掃屋企（字符串 × 整數 = 字符串）

```c++
string Cherng(string a, int b)
{
	if (b == 0) return "0"; 
	int n = a.size();
	string c(n, '0'); 
	int jw = 0; 
	for (int i = n - 1; i >= 0; --i)
	{
		int w = (a[i] - '0') * b + jw; 
		c[i] = (w % 10) + '0'; 
		jw = w / 10;
	}
	if (jw > 0)  c = to_string(jw) + c;
	int qdl = c.find_first_not_of('0');
	if (qdl != string::npos) 
		return c.substr(qdl);

	return "0"; 
}
```

- #### 觀天下（字符串 × 字符串 = 字符串）

```c++
string Cherng(string a, string b) 
{
	if (a == "0" || b == "0") return "0"; 

	vector<int> A(a.rbegin(), a.rend()), B(b.rbegin(), b.rend());
	for (auto& S : A) S -= '0'; 
	for (auto& S : B) S -= '0';

	vector<int> C(A.size() + B.size(), 0);

	for (size_t i = 0; i < A.size(); ++i) 
	{
		for (size_t j = 0; j < B.size(); ++j)
		{
			C[i + j] += A[i] * B[j];
			C[i + j + 1] += C[i + j] / 10; 
			C[i + j] %= 10;
		}
	}
	while (C.size() > 1 && C.back() == 0) C.pop_back();

	string CC(C.size(), '0');
	transform(C.rbegin(), C.rend(), CC.begin(), [](int d) { return d + '0'; });

	return CC;
}
```

### 差之毫釐 - 除法

- #### 左右開弓（字符串 ÷ 整數 = 字符串）

```c++
pair<string, int> Chwu(string a, int b)
{
	vector<int> C;
	int r = 0;
	for (char num: a)
	{
		r = r * 10 + (num - '0');
		C.push_back(r / b);
		r %= b;
	}
	string ans;
	bool lz = true;
	for (int num: C)
	{
		if (num != 0 || !lz)
		{
			ans.push_back('0' + num);
			lz = false;
		}
	}
	if (ans.empty()) ans = "0";
	return make_pair(ans, r);
}
```

魚和熊掌（雙串轉串）

```c++
// 無負數的高精度減法程序
string Jean(const string &a, const string &b)
{
	string C = a;
	int Jie = 0;
	for (int i = 0; i < C.size(); i++)
	{
		int A = C[C.size() - 1 - i] - '0';
		int B = (i < b.size()) ? (b[b.size() - 1 - i] - '0') : 0;
		A -= B + Jie;
		if (A < 0)
		{
			A += 10;
			Jie = 1;
		}
		else Jie = 0;
		C[C.size() - 1 - i] = A + '0';
	}
	size_t it = C.find_first_not_of('0');
	if (it != string::npos) return C.substr(it);

	return "0";
}

pair<string, string> Chwu(const string &a, const string &b)
{
	string c = "";
	string d = "0";
	for (char Shuh: a)
	{
		d = (d == "0") ? string(1, Shuh) : (d + Shuh);
		int jw = 0;

		while (d.size() > b.size() || (d.size() == b.size() && d >= b))
		{
			d = Jean(d, b);
			jw++;
		}
		c += (jw + '0');
	}

	c = c.find_first_not_of('0') == string::npos ? "0" : c.substr(c.find_first_not_of('0'));
	return {c, d};
}
```

```c++


```

### 雪中送炭 - 茶語外掛

| 功能   | 寫法						                  | 說明				              |
|------|---------------------------|---------------------|
| 加法   | `a.add(b)`				            | 					               |
| 減法   | `a.subtract(b)`		         | 					               |
| 乘法   | `a.multiply(b)`		         | 					               |
| 除法   | `a.divide(b)`			          | 					               |
| 取餘   | `a.remainder(b)/a.mod(b)` | 					               |
| 捆綁商餘 | `a.divideAndRemainder(b)` | 返回大整數數組，第0位是商，第1位是餘 |
| 絕對值  | `a.abs()`				             | 					               |
| 相反數  | `a.negate()`			           | 					               |
| 求冪   | `a.pow(b)`				            | `b`是整數			           |
| 快速冪  | `a.modPow(b,m)`		         | 					               |
| 較大值  | 						                    | 					               |
| 較大值  | 						                    | 					               |
| 較小值  | 						                    | 					               |
| 比較   | 						                    | 					               |
| 相等   | 						                    | 					               |
| 正負   | 						                    | 					               |
| 	    | 						                    | 					               |

導包：import java.math.BigInteger;
默認參數和返回值類型為大整數，需要特殊注意的數據類型使用->指出

基礎運算

a.max(b) 較小值a.min(b)   比較a.compareTo(b)   -1: a<b 0: a=b 1: a>1
相等 a.equals(b)   返回正誤值 正負 a.signum()   -1:負數 0:零 1:正數

位運算和二進制
左移 a.shiftLeft(n->int)  左移動n位（乘法）
右移 a.shiftRight(n->int) 右移動n位（除法）
按位與 a.and(b)     按位或 a.or(b)     按位异或a.xor(b)
按位與非a.andNot(b)   按位取反 a.not()
指定位清零 a.clearBit(n->int)   指定位設一 a.setBit(n->int)    指定位翻轉 a.flipBit(n->int)
檢查這一位是否為一 a.testBit(n->int) 返回正誤值
二進制補碼 a.toByteArray()  返回字節數組byte[]
補碼中不包括符號位的位數 a.bitLength()   補碼中和符號位不同的位數 a.bitCount()
第一個不為零的索引 a.getLowestSetBit()     散列碼 a.hashCode()

轉換
數字轉大整數 a.valueOf(n->long)  int等的會隱式轉換，所以一個就夠了
轉整數int a.intValue() / a.intValueExact()
轉長整數long a.longValue() / a.longValueExact()
轉短整數short a.shortValueExact()
轉超短整數byte a.byteValueExact()
轉單精度浮點數float a.floatValue()
轉雙精度浮點數double a.doubleValue()
轉字符串數a.toString()  重載函數：a.toString(n->int) 這個字符串數的進制為n（2<=n<=36）

數學知識
最大公因數 a.gcd(b)
質數 a.isProbablePrime(n)  true：可能是質數，false：肯定是合數，參數n為可信度，可以取為100
下一個可能的質數 a.nextProbablePrime()
一個二進制長度為n的可能的質數 probablePrime(n->int , Random rnd)
乘法逆元 a.modInverse(b)     (a * x) % m = 1 返回x

```
差之毫釐
（串整轉串）
pair<string, int> Chwu(string a, int b)
{
	vector<int> C;
	int r = 0;
	for (char num : a)
	{
		r = r * 10 + (num - '0');
		C.push_back(r / b);
		r %= b;
	}
	string ans;
	bool lz = true;
	for (int num : C)
	{
		if (num != 0 || !lz)
		{
			ans.push_back('0' + num);
			lz = false;
		}
	}
	if (ans.empty()) ans = "0";
	return make_pair(ans, r);
}





階桺庭花
string JieCheng(int n) 
{
	if (n == 1)   return "1";
	vector<int> res(1, 1); 
	for (int i = 2; i <= n; ++i) 
	{
		int jw = 0;
		for (auto& d: res)
		{
			int p = d * i + jw;
			d = p % 10;
			jw = p / 10;
		}
		while (jw) 
		{ 
			res.push_back(jw % 10);
			jw /= 10;
		}
	} return vtostr(res); // 將結果從向量轉換為字符串，過程略
}

各有千秋
// 比較兩個『字符串』形式的的數的大小
int bi(string a, string b)
{
	if (a.size() != b.size())   return a.size() > b.size() ? 1 : -1;
	for (size_t i = 0; i < a.size(); i++)
		if (a[i] != b[i])   return a[i] > b[i] ? 1 : -1;
	return 0;
}// a<b  -1   a>b 1   a=b 0

雪中送炭


```

# 海納百川（數論）

### 通用代碼

```c++
//我一個信奧賽的同學把這句話掛在嘴邊上，并用了他大半個生涯對付卡常數
#define ll long long
#define int long long
```

## 步步為營

### 避免溢出的乘法

1. 外掛法
   ```c++
   int cheng(int a, int b, int m) { return (__int128) a * b % m; }
   ```
2. 循環法
   ```c++
   int cheng(int a, int b, int m)
   {
       int c = 0;
       a %= m, b %= m;
       while (b > 0)
       {
           if (b % 2 == 1) c = (c + a) % m;
           a = (a * 2) % m;
           b >>= 1;
       }
       return c;
   }
   ```
3. 遞歸法
   ```c++
   int cheng(int a, int b, int m)
   {
       int r = a * b - m * (int) (1.L / m * a * b);
       return r - m * (r >= m) + m * (r < 0);
   }
   ```

### 快速冪

1. 當循環
   ```c++
   int KSM(int d, int j, int c)
   {
       int y = 1;// 餘數
       d %= c;
       while (j)
       {
           if (j & 1) y = y * d % c;
           d = d * d % c;
           j >>= 1;
       }
       return y;
   }
   ```
2. 次循環
   ```c++
   int KSM(int d, int j, int c)
   {
       int y = 1;
       for (; j; j >>= 1, d = d * d % c)
       {
           if (j & 1) y = y * d % c;
       }
       return y;
   }
   ```

## 黨同伐異

### 最大公因數(Greatest Common Divisor, GCD)

1. 輾轉相除法（循環）
    - 優點：時間複雜度低
    - 缺點：在高精度運算取餘數費時間
   ```c++
   int gys(int a, int b)
   {
       while (b) int t = b, b = a % b, a = t;
       return a;
   }
   ```
2. 輾轉相除法（遞歸）
    - 優點：寫起來極其簡單
    - 缺點：可能會爆棧
   ```c++
   int gys(int a, int b)
   {
       return b ? gys(b, a % b) : a;
   }
   ```
3. 更相減損術
    - 優點：不需要取餘數
    - 缺點：循環次數比前者多很多
   ```c++
   int gys(int a, int b)
   {
       while (a != b)  a > b ? a -= b : b -= a;
       return a;
   }
   ```
4. 內置函數`<algorithm>` 裡的 `__gcd()`

### 最小公倍數(Lowest Common Multiple, LCM)

最小公倍數=兩數乘積/最大公因數

```c++
int gbs(int a, int b)
{
    return (a / gys(a, b)) * b;
}
```

### 擴展結論

1. 多個數的公因數和公倍數可以逐對計算
    - `GCD(a,b,c,d,e,…)=GCD(GCD(GCD(GCD(a,b),c),d),e,…)`
    - `LCM(a,b,c,d,e,…)=LCM(LCM(LCM(LCM(a,b),c),d),e,…)`

2. 已知公因數和公倍數，求兩個數的各種組合
    - 首先要判斷這個所謂的公因數和公倍數合不合法，如果公倍數無法被公因數整除，說明這組數據不合法
    - 設兩個數為a,b， a=gcd*① b=gcd*② 根據公因數的性質，①*②互質，公倍數gcd*①*②
    - 根據等式`a*b=lcm*gcd;`   加上上面的代換，得到等式`①*②=lcm/gcd`
    - 所以衹要嘗試所有滿足這兩個條件的數字：①*②=lcm/gcd ① ②互質，乘以gcd就得到原數

3. 배촉定理
   對於兩數a b，要求兩整數x y滿足條件a*x+b*y最小，則最小值為GCD(|a|,|b|)
   對於一系列數字Ai，要求要求一系列數字Xi滿足∑ Ai*Xi最小，則最小值為Ai多個數的GCD
   绝对值！代码中要取绝对值！

### 通分/約分

分數通分小程序，z1/m1和z2/m2

```c++
int lcm = gbs(m1, m2);
z1 *= lcm / m1;
z2 *= lcm / m2;
m1 = m2 = lcm;
```

分數約分小程序，z/m

```c++
int te = gys(z, m);
z /= te; m /= te;
```

## 數根萬物 - 質數

### 多謀善斷 - 判斷質數

#### 簡單判斷

```c++
bool Zhyh(int n)  // false 合 , true 質
{
	if (n <= 1) return false;
	for (int i = 2; i * i <= n; ++i)
		if (n % i == 0) return false;
	return true;
}
```

#### 經過常數優化的試除法

複雜度係數降為上面的1/3

```c++
bool Zhyh(int n)
{
	if (n < 2) return false;
	if (n == 2 || n == 3) return true;
	if (n % 6 != 1 && n % 6 != 5) return false;
	for (int i = 5, j = n / i; i <= j; i += 6)
		if (n % i == 0 || n % (i + 2) == 0)  return false;
	return true;
}
```

### 差強人意

- 利用素性判斷算法判斷質數（`Miinter-Rabin` 素性测试）  [（例題）](https://www.luogu.com.cn/problem/P10404)
- 時間複雜度為`O(4*log^3(n))`

```c++
int cheng(int a, int b, int m)  大數取餘乘法函數
int KSM(int d, int j, int c)   快速冪

bool MR(int n)
{
	if (n < 3 || n % 2 == 0) return n == 2;// 特判
	int u = n - 1, t = 0;
	while (u % 2 == 0) u /= 2, ++t;
	int ud[] = { 28178, 9780504 };
	for (auto i : ud)
	{
		int v = KSM(i, u, n);
		if (v == 1 || v == n - 1 || v == 0) continue;
		for (int j = 1; j <= t; j++)
		{
			v = cheng(v, v, n);
			if (v == n - 1 && j != t)
			{
				v = 1;
				break;
			}// 出現一個n-1，後面都是1，直接跳出
			if (v == 1) return 0;// 這裏代表前面沒有出現n-1這個解，二次檢驗失敗
		}
		if (v != 1) return 0;// Fermat檢驗
	}
	return 1;
}

// 加上下面這一段，并使用isprime來調用，這樣可以剪枝優化
int Zhyh[28] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107 };
bool isprime(int n)
{
	for (int i = 0; i < 28 && Zhyh[i] * Zhyh[i] <= n; ++i)
		if (n % Zhyh[i] == 0) return false;
	if (!MR(n)) return false;
	return true;
}
```

# 端尺區穴（幾何）

## 精打細算 - 常量和浮點數

定義常量

```c++
const double jd = 1e-8;// 比較精度
const double pi = acos(-1.0);// 圓周率
const double inf = 1e20;
```

浮點數的近似比較大小

```c++
#include <cmath>
int cmp(double x, double y)
{
	if (fabs(x - y) < jd) return 0;
	else return x < y ? -1 : 1;// x<y -1 x>y  1
}
```

浮點數的近似正負零

```c++
#include <cmath>
int cmp(double x)
{
	if (fabs(x) < jd) return 0;
	else return x < 0 ? -1 : 1;// x<0 -1 x>0  1
}
```

浮點數切割

```c++
double cut(double x, int n) // n為保留的小數點後的位數
{
	double m = pow(10.0, n);
	return round(x * m) / m;// 這裡的取整方式可以改變
}
```

## 端 - 點/向量

```c++
struct pnt  // 點和向量共用，因為向量也可以用(x,y)表示
{
	double x, y;
	pnt() {}
	pnt(double x, double y) : x(x), y(y) {}
	// 以下是用點定義的向量的運算，代碼量比較大，用哪些寫哪些
	pnt operator+(pnt b) { return pnt(x + b.x, y + b.y); }
	pnt operator-(pnt b) { return pnt(x - b.x, y - b.y); }
	pnt operator*(double k) { return pnt(x * k, y * k); }
	pnt operator/(double k) { return pnt(x / k, y / k); }
	bool operator==(pnt b) { return cmp(x, b.x) == 0 && cmp(y, b.y) == 0; }
	bool operator<(const pnt& b){return cmp(x, b.x)<0||(cmp(x,b.x)==0 && cmp(y, b.y) < 0);}
};
// 這兩個和上面的<重載用於對點排序，以下兩個不常用，平時不用寫
bool cmpy(pnt a, pnt b) { return cmp(a.y - b.y) < 0; } // 只對 y 座標排序
bool cmpx(pnt a, pnt b) { return cmp(a.x - b.x) < 0; } // 只對 x 座標排序
```

```

端



兩點之間的距離
// 直線距離（勾股定理距離）
double p2pdis(pnt a, pnt b) { return hypot(a.x - b.x, a.y - b.y); }
// 座標軸距离（曼哈頓出租車距離）
double p2pdism(pnt a, pnt b) { return fabs(a.x - b.x) + fabs(a.y - b.y); }
// 單位向量
pnt normal(pnt a) { return pnt(-a.y / len(a), a.x / len(a)); }

向量點積
double dot(pnt a, pnt b) { return a.x * b.x + a.y * b.y; }
// 向量長度
double len(pnt a) { return sqrt(dot(a, a)); }
// 向量長度的平方（减少浮點運算）
double len2(pnt a) { return dot(a, a); }
// 向量A B的夾角
double angle(pnt a, pnt b) { return acos(dot(a, b) / len(a) / len(b)); }

向量叉積
double cross(pnt a, pnt b) { return a.x * b.y - a.y * b.x; }
// ABC和另一個點構成的平行四邊形的面積
double area(pnt a, pnt b, pnt c) 
{ return cross(b - a, c - a); }// abc三點求三角形面積就是/2
// 平行/重合
bool paralel(pnt a, pnt b) { return cmp(cross(a, b)) == 0; 
// 向量A B的夹角(另一種寫法)
double angle_(pnt a, pnt b)
{ return abs(atan2(abs(cross(a, b)), a.x * b.x + a.y * b.y)); }

旋轉
// 向量逆時針旋轉rad
pnt rotate(pnt a, double rad) 
{
	return  pnt(a.x * cos(rad) - a.y * sin(rad), 
a.x * sin(rad) + a.y * cos(rad)); 
}
// a繞b逆时针旋转rad
pnt rotate(pnt a, pnt b, double rad)
{
	return { (a.x - b.x) * cos(rad) - (a.y - b.y) * sin(rad) + b.x,
			(a.x - b.x) * sin(rad) + (a.y - b.y) * cos(rad) + b.y };
}

最近點對
pnt p[N], t[N];
double p2pclose(int l, int r)
{
	double dis = inf;
	if (l == r) return dis;
	if (l + 1 == r) return p2pdis(p[l], p[r]);
	int mid = (l + r) / 2;
	double d1 = p2pclose(l, mid);
	double d2 = p2pclose(mid + 1, r);
	dis = min(d1, d2);
	int k = 0;
	for (int i = l; i <= r; i++) if (fabs(p[mid].x - p[i].x) <= dis)  t[k++] = p[i];
	sort(t, t + k, cmpy);
	for (int i = 0; i < k; i++)
		for (int j = i + 1; j < k; j++)
		{
			if (t[j].y - t[i].y >= dis)  break;
			dis = min(dis, p2pdis(t[i], t[j]));
		}
	return dis;
}
調用前  sort(p, p + n);// 這裡是正常排序：先對x再對y，所以沒有比較函數
調用	p2pclose(0, n - 1)
 
尺
struct line  // 直線和線段公用，在直線中p1p2為兩個普通的點，在線段上為端點
{
public:
	pnt p1, p2;
	line() {}
	line(pnt p1, pnt p2) :p1(p1), p2(p2) {}// 兩點式
	line(pnt p, double angle)// 點斜式
	{
		p1 = p;
		if (cmp(angle, pi / 2) == 0)  p2 = p1 + pnt(0, 1);
		else p2 = p1 + pnt(1, tan(angle));
	}
	line(double a, double b, double c)// 標準式ax+by+c=0
	{
		if (cmp(a) == 0)
		{
			p1 = pnt(0, -c / b); p2 = pnt(1, -c / b);
		}
		else if (cmp(b) == 0)
		{
			p1 = pnt(-c / a, 0); p2 = pnt(-c / a, 1);
		}
		else
		{
			p1 = pnt(0, -c / b); p2 = pnt(1, (-c - a) / b);
		}
	}
};

三點是否共線|點在直線上
bool ppp(pnt a, pnt b, pnt c)
{
	return cmp((a.y - b.y) * (b.x - c.x), (a.x - b.x) * (b.y - c.y)) == 0;
}

點和直線的位置關係
int p2lrea(pnt p, line v)
{
	int c = cmp(cross(p - v.p1, v.p2 - v.p1));
	if (c < 0) return 1;// p在v左側
	if (c > 0) return 2;// p在v右側
	return 0;// p在v上
}

點到直線的距離
double p2ldis(pnt p, line v) 
{ return fabs(cross(p - v.p1, v.p2 - v.p1)) / p2pdis(v.p1, v.p2); }

點在直線上的投影點
pnt p2lpro(pnt p, line v)
{
	double k = dot(v.p2 - v.p1, p - v.p1) / len2(v.p2 - v.p1);;
	return v.p1 + (v.p2 - v.p1) * k;
}

點關於直線的對稱點
pnt plp(pnt p, line v)
{
	pnt q = p2lpro(p, v);
	return pnt(2 * q.x - p.x, 2 * q.y - p.y);
}

兩條直線的位置關係
int llrea(line v1, line v2)
{
	if (cmp(cross(v1.p2 - v1.p1, v2.p2 - v2.p1)) == 0)
		if (p2lrea(v1.p1, v2) == 0) return 1;// 重合
		else return 0;// 平行
	return 2;// 相交
}

兩直線交點
pnt lpl(pnt a, pnt b, pnt c, pnt d) // 前提要保證要相交
{
	double s1 = cross(b - a, c - a);
	double s2 = cross(b - a, d - a);
	return pnt(c.x * s2 - d.x * s1, c.y * s2 - d.y * s1) / (s2 - s1);
}

點和線段的位置關係
int p2srea(pnt p, line v)
{
	return cmp(cross(p - v.p1, v.p2 - v.p1)) == 0 && cmp(dot(p - v.p1, p - v.p2)) <= 0;
}// 0不在線段上  1在線段上

點到線段的距離
// 投影在線段上，就是圖中的直邊框，求點線距離就可以（p2ldis）
// 不在線段上，就是圖中的圓邊框，最短距離就是更靠近的那個端點的距離（p2pdis）
double p2sdis(pnt p, line v) 
{
	if (cmp(dot(p - v.p1, v.p2 - v.p1)) < 0 || cmp(dot(p - v.p2, v.p1 - v.p2)) < 0)
		return min(p2pdis(p, v.p1), p2pdis(p, v.p2));
	return p2ldis(p, v);
}

兩條線段是否相交
bool ssrea(pnt a, pnt b, pnt c, pnt d)
{
	double c1 = cross(b - a, c - a), c2 = cross(b - a, d - a);
	double d1 = cross(d - c, a - c), d2 = cross(d - c, b - c);
	return cmp(c1) * cmp(c2) < 0 && cmp(d1) * cmp(d2) < 0;
}// 1 相交  0不相交

兩條線段的交點
pnt sps(pnt a, pnt b, pnt c, pnt d) // 前提要保證要相交，直接轉化為直線的交點
{  return lpl(a, b, c, d);  }

線段的中垂線
line spl(pnt p1, pnt p2) 
{  pnt h = (p1 + p2) / 2;   return { h, h + rotate(p2 - p1, pi / 2) };  }
 
區
楔
// 三角形重心：三條中線的交點
pnt corcen(pnt p1, pnt p2, pnt p3)
{
	return (p1 + p2 + p3) / 3.0;
}

// 三角形內心：三條角平分線交點，內切圓圓心
pnt incen(pnt p1, pnt p2, pnt p3)
{
	double d1 = len(p2 - p3);
	double d2 = len(p1 - p3);
	double d3 = len(p1 - p2);
	return (p1 * d1 + p2 * d2 + p3 * d3) / (d1 + d2 + d3);
}

// 三角形垂心：三條高的交點
pnt ortcen(pnt p1, pnt p2, pnt p3)// 模擬，通過旋轉找出兩條高，求交點
{
	pnt u = p1 + rotate(p2 - p3, pi / 2);
	pnt v = p2 + rotate(p1 - p3, pi / 2);
	return lpl(p1, u, p2, v);
}

// 外心：三邊垂直平分線交點，外接圓圓心
pnt circen(pnt p1, pnt p2, pnt p3)
{
	pnt h = (p1 + p2) / 2;// 中點
	pnt m = (p2 + p3) / 2;
	pnt u = h + rotate(p2 - p1, pi / 2);// 旋轉得到垂平線
	pnt v = m + rotate(p3 - p2, pi / 2);
	return lpl(h, u, m, v);
}

形
使用切割法求多邊形面積
double poS(vector<pnt> p, int n)
{
	double S = 0;
	for (int i = 0; i < n; i++)
		S += cross(p[i], p[(i + 1) % n]);
	return fabs(S / 2);
}

使用射線法判斷點和多邊形的位置關係
int p2porea(pnt pt, vector<pnt> p, int n)
{
	for (int i = 0; i < n; i++)
		if (p[i] == pt)  return 3;// 3 在頂點上
	for (int i = 0; i < n; i++)
	{
		line v = line(p[i], p[(i + 1) % n]);
		if (p2srea(pt, v)) return 2;// 2 在邊上
	} 
	int num = 0;
	for (int i = 0; i < n; i++)
	{
		int j = (i + 1) % n;
		int c = cmp(cross(pt - p[j], p[i] - p[j]));
		int u = cmp(p[i].y - pt.y);
		int v = cmp(p[j].y - pt.y);
		if (c > 0 && u < 0 && v >= 0) num++;
		if (c < 0 && u >= 0 && v < 0) num--;
	}
	return num != 0;// 1 內部 0外部
}

拓展：判斷線段是否在任意多邊形內部，就判斷線段和多邊形的邊界不相交 ssrea()，並且兩端點都在多邊形內部




// 使用切割法求多邊形重心
pnt pocen(vector<pnt> p, int n)
{
	pnt ans(0, 0);
	double S = poS(p, n);
	if (cmp(S) == 0) return ans;
	for (int i = 0; i < n; i++) 
	{
		ans=ans+(p[i] + p[(i + 1) % n])*cross(p[i], p[(i + 1) % n]);
	}
	return ans / S / 6;
}


判斷四個點能否組成矩形/正方形


// 旋轉卡殼


 
格
格紙定理（Pick定理）：
整點：橫縱座標都是整數的點
當一個多邊形所有的頂點都是整點，
n是多邊形內部的整點數（不包括），s表示多邊形邊界上的整點數（包括頂點） 面積公式：S=n+s/2-1
當一條線段的兩個端點是整點，在線段上的點數為gcd(|x1-x2|,|y1-y2|)+1

int onpo(vector<pnt> p) // 多邊形上點的個數
{ 
	int n = p.size(), ans = 0;
	for (int i = 0; i < n; i++)
	{
		auto a = p[i], b = p[(i + 1) % n];
		ans += gys(fabs(a.x - b.x), fabs(a.y - b.y));
	}
	return ans;
}

int inpo(vector<pnt> p) // 多邊形內點的個數
{ 
	int n = p.size(), ans = 0;
	for (int i = 0; i < n; i++)
	{
		auto a = p[i], b = p[(i + 1) % n], c = p[(i + 2) % n];
		ans += b.y * (a.x - c.x);
	}
	return (abs(ans)- onpo(p)) / 2 + 1;
}
 
圜
struct circle
{
	pnt c;
	double r;
	circle();
	circle(pnt c, double r) :c(c), r(r) {}
	circle(double x, double y, double r) { this->r = r; c = pnt(x, y); }
};

// 點和圓的位置關係
int p2crea(pnt p, circle C)
{
	double dis = p2pdis(p, C.c);
	if (cmp(dis, C.r) == -1) return 0;// 圓內
	if (cmp(dis, C.r) == 0) return 1;// 圓上
	return 2;// 圓外
}

// 直線和圓的位置關係
int l2crea(line l, circle C)
{
	double dis = p2ldis(C.c, l);
	if (cmp(dis, C.r) == -1) return 0;// 相交
	if (cmp(dis, C.r) == 0) return 1;// 相切
	return 2;// 相離
}

// 線段和圓的位置關係
int s2crea(line s,circle C)
{
	double dis = p2sdis(C.c, s);
	if (cmp(dis, C.r) == -1) return 0;// 部分或全部在圓內
	if (cmp(dis, C.r) == 0) return 1;// 相切
	return 2;// 圓外
}

// 直線和圓的交點，交點用引用傳參，返回值為個數
int lpc(line v, circle C, pnt& a, pnt& b)
{
	if (l2crea(v, C) == 2) return 0;// 相離 0
	pnt q = p2lpro(C.c, v);
	double d = p2ldis(C.c, v);
	double k = sqrt(C.r * C.r - d * d);
	if (cmp(k) == 0) { a = q, b = q; return 1; }// 相切 1，返回的兩個點相同
	pnt n = (v.p2 - v.p1) / len(v.p2 - v.p1);
	a = q + n * k, b = q - n * k;
	return 2;// 相交 2
}

// 三點確定的圓心
pnt pppc(pnt a, pnt b, pnt c)
{
	pnt cen;
	double a1 = b.x - a.x, b1 = b.y - a.y, c1 = (a1 * a1 + b1 * b1) / 2;
	double a2 = c.x - a.x, b2 = c.y - a.y, c2 = (a2 * a2 + b2 * b2) / 2;
	double d = a1 * b2 - a2 * b1;
	cen.x = a.x + (c1 * b2 - c2 * b1) / d;
	cen.y = a.y + (a1 * c2 - a2 * c1) / d;
	return cen;
}

拓展：
1.點到圓的最近點，及最短距離
	當他和圓心重合的時候有無數多解；其他情況下，和圓心連線的直線和圓的交點lpc()，計算兩點到點的距離，更小的那一個就是最近點，計算出的答案就是最短距離



// 最小圓覆蓋（基礎款）
#include <algorithm>
#include <random>  // 打亂函數，越亂越快
circle minc(vector<pnt>& p, int n)
{
	pnt c;  double r;
	random_device rd;
	mt19937 g(rd());
	shuffle(p.begin(), p.end(), g);
	c = p[0];  r = 0;
	for (int i = 1; i < n; i++)
	{
		if (cmp(p2pdis(p[i], c), r) == 1)
		{
			c = p[i];  r = 0;
			for (int j = 0; j < i; ++j)
			{
				if (cmp(p2pdis(p[j], c), r) == 1)
				{
					c.x = (p[i].x + p[j].x) / 2;
					c.y = (p[i].y + p[j].y) / 2;
					r = p2pdis(p[j], c);
					for (int k = 0; k < j; ++k)
					{
						if (cmp(p2pdis(p[k], c), r) == 1)
						{
							c = pppc(p[i], p[j], p[k]);
							r = p2pdis(p[i], c);
						}
					}
				}
			}
		}
	}
	return { c, r };
}
```