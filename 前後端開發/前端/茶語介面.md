# 视图设计师里的内容

## 熟悉javafx的左侧选单

1. Containers（容器）
容器用于组织和管理其他 UI 组件。它们可以控制布局、排列和调整组件的显示。

2. Controls（控件）
控件是用户与应用程序交互的组件。

3. Menu（菜单）
菜单用于提供应用程序中的功能选项。

4. Miscellaneous（其他）
这个部分包含一些不属于前面分类的额外组件

5. Shapes（形状）
这个部分用于绘制图形

6. Charts（图表）
用于显示数据的图表组件

7. 3D（例题）
用于创建三维图形和组件的部分，

### 容器

- Accordion（折叠面板）
功能：Accordion 是一个可以包含多个折叠部分的容器。每个部分只有一个可以展开，其他部分会自动折叠。常用于在有限空间中展示不同的内容。
常见用途：设置、选项或导航面板。
- AnchorPane（锚定面板）
功能：AnchorPane 允许你将子组件锚定到父容器的四个边缘（上、下、左、右）。组件的位置和大小可以根据父容器的大小动态调整。
常见用途：当你需要组件跟随父容器变化时使用，比如调整窗口大小时 UI 组件相应调整。
- BorderPane（边界面板）
功能：BorderPane 允许你在五个区域布局组件——顶部（Top）、底部（Bottom）、左侧（Left）、右侧（Right）和中心（Center）。每个区域只能放置一个组件。
常见用途：创建简单的应用程序布局，如在顶部放置菜单栏，中心放置主要内容，底部放置状态栏。
- FlowPane（流动面板）
功能：FlowPane 会根据可用空间自动排列其子组件，按行或按列布局。当空间不足时，会自动换行或换列。
常见用途：图像画廊或动态列表显示。
- GridPane（网格面板）
功能：GridPane 是一个网格布局的容器，可以将组件放置在行和列中。你可以指定每个组件跨越多少行或列。
常见用途：表单布局，带行列结构的内容，如日历或表格。
- HBox（水平盒子）
功能：HBox 是一个水平排列的容器，它会将子组件从左到右水平排列。
常见用途：需要水平排列的内容，如工具栏、按钮组等。
- Pane（基础面板）
功能：Pane 是一个基础的布局容器，允许你通过设置每个组件的 x 和 y 坐标来进行自由布局。
常见用途：用于完全自由布局的场景，或当不需要自动调整组件位置时。
- ScrollPane（滚动面板）
功能：ScrollPane 是一个支持滚动的容器。它允许你放置一个内容较多的组件，超出可视区域的部分可以通过滚动条访问。
常见用途：长列表、图像或其他超出窗口大小的内容。
11. SplitPane (empty)（分隔面板）
功能：SplitPane 是一个可调整大小的分隔面板。你可以在 SplitPane 中放置多个子组件，并通过拖动分隔条调整它们的大小。
12. SplitPane (horizontal)（水平分隔面板）
功能：水平 SplitPane 容器，将组件水平排列，用户可以拖动水平分隔条来调整两部分的相对大小。
13. SplitPane (vertical)（垂直分隔面板）
功能：垂直 SplitPane 容器，将组件垂直排列，用户可以通过拖动垂直分隔条调整上、下部分的相对大小。
- StackPane（堆栈面板）
功能：StackPane 会将所有子组件堆叠在一起，子组件会彼此覆盖。通常是先添加的组件位于底层，后添加的位于上层。
常见用途：当需要重叠布局时，例如背景图片加上文本的情况。
- Tab（标签）
功能：Tab 是 TabPane 容器中的一个单独标签页。每个 Tab 可以显示不同的内容。
常见用途：浏览器风格的多页界面。
- TabPane（标签面板）
功能：TabPane 是一个用于管理多个标签页的容器。用户可以在多个标签页之间切换，每个标签页有独立的内容。
常见用途：复杂应用程序中的多个视图，如设置面板或浏览器界面。
17. TabPane (empty)
功能：初始状态为空的 TabPane，允许你动态添加标签页。
18. TextFlow (FX8)
功能：TextFlow 是一个用于排列和显示文本的容器，可以将不同格式的文本组件（如 Text）排列在一起。与普通的 Label 不同，它支持更复杂的文本布局和格式化。
常见用途：需要显示多段或格式化文本的场景。
19. TilePane（瓦片面板）
功能：TilePane 会将子组件以瓦片（Tile）的形式排列。瓦片的大小可以根据内容动态调整，类似于网格布局，但不需要明确定义行列。
常见用途：图标或图片的自动排列。
20. TitledPane（带标题的折叠面板）
功能：TitledPane 是一个带有标题的折叠面板，用户可以点击标题来展开或折叠内容部分。
常见用途：需要展示/隐藏特定信息的界面，如高级设置。
21. TitledPane (empty)
功能：初始状态为空的 TitledPane，允许你动态添加内容。
22. ToolBar（工具栏）
功能：ToolBar 是一个水平或垂直的容器，通常用于放置工具按钮和控件。
常见用途：放置快捷按钮、菜单或工具。
23. VBox（垂直盒子）
功能：VBox 是一个垂直排列的容器，它会将子组件从上到下垂直排列。
常见用途：表单或垂直排列的内容，如按钮、标签等。


### 控件

1. Button
按钮控件：用于执行某个操作或命令，可以设置文字、图标等属性。点击时触发事件。
2. CheckBox
复选框：允许用户在多个选项中选择一个或多个。用户可以勾选或取消勾选。
3. ChoiceBox
选择框：显示一个下拉列表，用户可以从中选择一个选项。通常用于选择一项内容。
4. ColorPicker
颜色选择器：允许用户选择颜色，通常显示一个颜色选择面板。
5. ComboBox
组合框：结合了文本框和下拉列表，用户可以选择列表中的一个选项或输入自定义值。
6. DatePicker (FX8)
日期选择器：允许用户选择日期，通常会弹出一个日历界面。
7. HTMLEditor
HTML 编辑器：用于编辑 HTML 内容，支持基本的文本格式化和 HTML 标签。
8. Hyperlink
超链接：显示为链接样式的文本，用户点击后可以打开网页或执行某个操作。
9. ImageView
图像视图：用于显示图像文件，可以设置图像的大小、缩放和其他效果。
10. Label
标签控件：用于显示文本，不可编辑。通常用于说明其他控件的功能。
11. ListView
列表视图：显示一个可滚动的项目列表，用户可以选择单个或多个项目。
12. MediaView
媒体视图：用于播放音频和视频内容，支持多种媒体格式。
13. MenuBar
菜单栏：用于显示一组菜单项，通常位于窗口的顶部，提供应用程序的主要功能。
14. MenuButton
菜单按钮：显示一个按钮，点击后显示下拉菜单供用户选择。
15. Pagination
分页控件：用于显示一组内容的分页，方便用户浏览长列表或大量信息。
16. PasswordField
密码输入框：用户输入时文本会被隐藏，适用于需要输入密码的场合。
17. ProgressBar
进度条：用于显示操作的进度，可以是确定的（已知总长度）或不确定的（无限循环）。
18. ProgressIndicator
进度指示器：类似于进度条，用于显示操作的进度，但通常不显示具体的进度数值。
19. RadioButton
单选按钮：用户可以在一组选项中选择一个。选中一个时，其他会自动取消选中。
20. ScrollBar (horizontal/vertical)
滚动条：用于控制内容的可视区域，用户可以通过拖动滚动条来滚动内容。分为水平和垂直两种。
21. Separator (horizontal/vertical)
分隔线：用于分隔控件的视觉元素，帮助提高界面的清晰度和组织性。
22. Slider (horizontal/vertical)
滑块：允许用户在指定范围内选择一个值，分为水平和垂直两种。
23. SplitMenuButton
分隔菜单按钮：类似于菜单按钮，但还可以显示一个默认动作。
24. TableColumn
表格列：用于定义表格视图中的一列，包括列标题和数据类型。
25. TableView
表格视图：用于显示以表格形式组织的数据，支持行选择、排序和编辑。
26. TextArea
文本区域：用于输入多行文本，可以设置自动换行和其他文本格式化选项。
27. TextField
文本框：用于输入单行文本，通常用于表单输入。
28. ToggleButton
切换按钮：类似于按钮，用户点击时可以切换状态（选中和未选中）。
29. TreeTableColumn (FX8)
树形表格列：用于树形表格视图中的一列，支持层次化数据的显示。
30. TreeTableView (FX8)
树形表格视图：类似于表格视图，但支持层次化的数据展示，适用于展示复杂数据结构。



# 智慧金点子的内容


## 写主函数
运行->编辑配置->应用程序->选定要设置为主类的类->修改选项->添加VM选项->

在VM框里面写 `--module-path D:/installer/JavaFxSDK/openjfx-19-ea+9_windows-x64_bin-sdk/javafx-sdk-19/lib --add-modules javafx.controls,javafx.fxml `，
其中前面这个是java和javafx连接用的JDK（软件开发工具包）的下载地址到lib层次位置


## 导入文档
文件->另存为->存为fxml文件->复制到：文件目录/src/main/resource 路径下

在IDEA上找到这个文件，修改GridPane这一句为
```
<GridPane fx:controller="com.company.UI.Converter" maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="400.0" prefWidth="600.0" xmlns:fx="http://javafx.com/fxml/1" xmlns="http://javafx.com/javafx/8">
```
这里主要修改`fx:controller=`列，是为了和控制类`Converter` 建立关系

## 修改参数
构建 `Converter` 类
```java
package com.company.UI;

import javafx.fxml.FXML;

public class Converter
{
    @FXML
    private Button myButton;

    @FXML
    private void initialize()
    {
        // 按钮点击事件
        myButton.setOnAction(event ->
        {
            System.out.println("按钮被点击了！");
        });
    }
}
```
**注意事项和描述**
- 上面写了最重要的一个包，是构建 `Converter` 的关键，其他的按照需求加
- 所有元素都要重写FXML类的内容，仅一例
- 重写FXML类的initialize函数


## 设定事件

### 1. 按钮

FXML
```
<Button fx:id="myButton" mnemonicParsing="false" text="Button" />
```
JAVA
```java
private Button myButton;
myButton.setOnAction(event ->
{
    System.out.println("按钮被点击了！");
});
```

参数：
- `fx:id="myButton"`和`myButton`互相对应，从而将两个文件对应起来
- `mnemonicParsing="false"`表示是否允许使用快捷键，这里是`Alt+`快捷键。false表示禁用这种行为。
如果允许这个行为，就设置为true，在在text前面加上`_`，使得`Alt+B`为快捷键（B是首字母），
但如果使用中文，就无法自动分配快捷键，要自行分配（之后学）
```
<Button fx:id="myButton" mnemonicParsing="true" text="_Button" />
```
- `text="Button"` 设置了按钮上写的什么字，根据上面的的原则，还可能有设定默认快捷键的功能
- `setOnAction` 按钮只有一个事件，就是点击，现在为他设定，只要一点击，就输出

------

### 2. 复选框

FXML
```
<CheckBox fx:id="myCheckBox" mnemonicParsing="false" text="hhh" GridPane.columnIndex="1" />
```
JAVA
```java
private CheckBox myCheckBox;
myCheckBox.selectedProperty().addListener((observable, oldValue, newValue) ->
{
    System.out.println("复选框状态改变: " + newValue);
});
```

参数：
- `fx:id="myCheckBox"`和`myCheckBox`相对应，同上
- `mnemonicParsing`和`text`设定快捷键和标记的字，同上
- `GridPane.columnIndex="1"`指定复选框在网格布局中的列索引，这个参数与按钮功能无关，主要用于布局。
- 设置复选框默认状态为勾选，加上这一句话 `selected="true"`，一般情况下，复选框是未选中的，参数设置为`false`或者直接不写这个参数
- 也可以在java代码中用这一句话（不是在函数范围内）`myCheckBox.setSelected(true);` 设定默认为true

- 函数的参数`(observable, oldValue, newValue)`是状态属性、改变前的参数、改变后的参数，当复选框的状态改变的时候触发状态，输出


------

### 3. 选择框

FXML
```
<ChoiceBox fx:id="myChoiceBox" prefWidth="150.0" GridPane.rowIndex="1" />
```
JAVA
```java
private ChoiceBox<String> myChoiceBox;
myChoiceBox.getItems().addAll("选项1", "选项2", "选项3");
myChoiceBox.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) ->
{
	System.out.println("选中项: " + newValue);
});
```

- `fx:id="myChoiceBox"` 和 `GridPane.rowIndex="1"` 同上
- `prefWidth="150.0"` 设定是选择框的长度，以像素为单位
- 设置选项 `myChoiceBox.getItems().addAll("选项1", "选项2", "选项3");` `ChoiceBox` 默认没有内容，通过调用 `getItems()` 方法可以获取一个 `ObservableList`，然后用 `addAll()` 方法添加多个选项。
- 监听器同上，当选择变化的时候会执行里面的选项
- 设置选择框默认的选项，在设置选项之后加上 `myChoiceBox.setValue("选项1");`
- 设置选择框默认的文字，在设置选项之后加上 `myChoiceBox.setValue("请选择");` 相当于设置了一个虚拟的默认选项，当选择其他的了，就消失
- 结合上面两个，可以把`"请选择"`也当做一个选项，也就是给用户退回没选择的状态的方式，这时候可能要在提交表单的时候做出检查，防止空的就直接交上去了（之后学）


### 4.颜色选择器

FXML
```
<ColorPicker fx:id="myColorPicker" GridPane.columnIndex="1" GridPane.rowIndex="1" />
```
JAVA
```java
private ColorPicker myColorPicker;
myColorPicker.setOnAction(event ->
{
    Color selectedColor = myColorPicker.getValue();
    System.out.println("选中颜色: " + selectedColor);
});
```

比较明了，关于颜色，他会输出一个十六进制数字如 `0x996060ff` ，表示颜色的红色分量是 `0x99` ，绿色是 `0x60`，蓝色是 `0x60`，透明度是 `0xff`。
其中每一个的范围是 `0x00~0xff` ，分量值越大越浓，透明度越大 **越不透明** 


### 5.组合框

FXML
```
<ComboBox fx:id="myComboBox" prefWidth="150.0" GridPane.rowIndex="2" />
```
JAVA
```java
private ComboBox<String> myComboBox;
myComboBox.getItems().addAll("选项A", "选项B", "选项C");
myComboBox.valueProperty().addListener((observable, oldValue, newValue) ->
{
    System.out.println("组合框选中: " + newValue);
});
```
看起来和选择框没有区别，所以设置选项和默认都同（`getItems().addAll()` `setValue()`），但是可以设置参数使得同时接受选择和输入
 ```
 myComboBox.setEditable(true);
 ```
 在这句话设置之后，会变成一个既可以输入也可以选的框

### 6.日期选择器

FXML
```
<DatePicker fx:id="myDatePicker" GridPane.columnIndex="1" GridPane.rowIndex="2" />
```
JAVA
```java
private DatePicker myDatePicker;
myDatePicker.setOnAction(event ->
{
    LocalDate selectedDate = myDatePicker.getValue();
    System.out.println("选中日期: " + selectedDate);
});
```

和颜色选择器类似，集成程度较高，所以操作简单。用户界面可选择输入，也可以在小日历上选择。
输入的时候写作`2024/10/18`，传回的时候显示作`2024-10-18`


### 7.呵忒么勒编辑器



### 8.超链接

FXML
```
<Hyperlink fx:id="myHyperlink" text="Hyperlink" GridPane.rowIndex="3" />
```
JAVA
```java
private Hyperlink myHyperlink;
myHyperlink.setOnAction(event -> 
{
    System.out.println("超链接被点击了！");
});
```

跳转网站的操作（按照编译器的报错增加和网站有关的类）
```java
myHyperlink.setOnAction(event -> 
{
    try 
	{
		Desktop.getDesktop().browse(new URI("http://www.luogu.com"));
    }
	catch (IOException | URISyntaxException e) 
	{
        e.printStackTrace();
    }
});

```

### 9.图像

FXML
```
<ImageView fx:id="myImageView" fitHeight="150.0" fitWidth="200.0" pickOnBounds="true" preserveRatio="true" GridPane.columnIndex="1" GridPane.rowIndex="3" />
```
JAVA
```java
private ImageView myImageView;
Image image = new Image("F:/哏圖/理工/計算機/未來的我.png");
myImageView.setImage(image);
```

作为*基本元素*的图片没有事件，所以没有监听器一类的，但是在格式上比较详细。
- `fitHeight="150.0` `fitWidth="200.0"` 分别表示了图片的宽和高度，单位是像素
- `pickOnBounds="true"` 表示图片是否响应鼠标事件，在之后的开发中很有意义
- `preserveRatio="true"` 锁定宽高比，锁定之后图片不会变形

**注意** 如果同时设置了宽高，也锁定了宽高比，并不会冲突，他会显示一个尽可能大的图像，同时保持宽高比，代价是平面会有留白


### 10.标签

FXML
```
<Label fx:id="myLabel" text="原标签" />
```
JAVA
```java
private Label myLabel;
myLabel.setText("新标签");
```
标签通常用于展示静态的文本信息。可以在FXML文件中定义它，并在Java代码中动态更改它的内容。

标签**不提供交互功能**，所以是不可以复制的，如果要使用可复制的文本内容，可以在后面学习文本框，并把他设置为不可修改.



### 列表视图

FXML
```
<ListView fx:id="myListView" prefHeight="200.0" prefWidth="200.0" GridPane.columnIndex="1" />
```
JAVA
```java
private ListView<String> myListView;
myListView.getItems().addAll("Item 1", "Item 2", "Item 3");
myListView.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) ->
{
    System.out.println("选中项: " + newValue);
});
```
- 他也是一个列表，他和**选择框** 和 **组合框** 的事件响应是类似的，区别是他适合显示大量项。并且可以通过滚动来查看
- 单选和多选，默认是单选，可以使用这一句话来设置 `myListView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);` 其中`SINGLE`和 `MULTPLE` 是状态参数
- 响应双击事件
```java
myListView.setOnMouseClicked(event ->
{
    if (event.getClickCount() == 2)
    {
        String selectedItem = myListView.getSelectionModel().getSelectedItem();
        System.out.println("双击项: " + selectedItem);
    }
});
```

### 媒体视图


### 选单栏

### 分页控件


### 密码框
FXML
```
<PasswordField fx:id="myPasswordField" GridPane.rowIndex="3" />
```
JAVA
```java
myPasswordField.setOnAction(event ->
{
    String password = myPasswordField.getText();
    System.out.println("输入的密码: " + password);
});
```

- 这里默认是按下回车键触发事件，使用如下办法实时监听
```
myPasswordField.textProperty().addListener((observable, oldValue, newValue) -> 
{
    System.out.println("当前输入的密码: " + newValue);
});
```

- 使用如下办法使用确认按钮（要设置一个按钮来确认）
```
myButton.setOnAction(event -> 
{
    String password = myPasswordField.getText();
    System.out.println("点击按钮获取的密码: " + password);
});
```
- 实际情况下，密码要通过加密存贮
- 

这是一个简单的实例，用来实现密码框用一个按键切换可见不可见
```
<VBox spacing="10">
    <PasswordField fx:id="myPasswordField" promptText="请输入密码" />
    <TextField fx:id="myTextField" promptText="请输入密码" visible="false" />
    <Button fx:id="toggleButton" text="显示密码" />
</VBox>
```

```java
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.PasswordField;
import javafx.scene.control.TextField;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

public class PasswordToggleExample extends Application {
    @Override
    public void start(Stage primaryStage) {
        PasswordField myPasswordField = new PasswordField();
        myPasswordField.setPromptText("请输入密码");
        
        TextField myTextField = new TextField();
        myTextField.setPromptText("请输入密码");
        myTextField.setVisible(false); // 初始状态下隐藏
        
        Button toggleButton = new Button("显示密码");
        toggleButton.setOnAction(event -> {
            if (myTextField.isVisible()) {
                // 如果是可见的，切换回密码框
                myTextField.setVisible(false);
                myTextField.setText(""); // 清空文本框
                myPasswordField.setVisible(true);
                toggleButton.setText("显示密码");
            } else {
                // 如果是隐藏的，切换为可见的文本框
                myPasswordField.setVisible(false);
                myTextField.setVisible(true);
                myTextField.setText(myPasswordField.getText()); // 将密码设置到文本框
                toggleButton.setText("隐藏密码");
            }
        });

        VBox vbox = new VBox(myPasswordField, myTextField, toggleButton);
        Scene scene = new Scene(vbox, 300, 200);
        primaryStage.setScene(scene);
        primaryStage.setTitle("密码显示切换示例");
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
```

### 进度条

FXML
```
<ProgressBar fx:id="myProgressBar" prefWidth="200.0" progress="0.5"/>
```
JAVA
```java
new Thread(() ->
{
    try
    {
        for (int i = 0; i <= 10; i++)
        {
            double progress = i * 0.1;
            // 在线程内更新进度
            javafx.application.Platform.runLater(() ->
            {
                myProgressBar.setProgress(progress);
                System.out.println("当前进度: " + (int) (progress * 100) + "%");
            });
            Thread.sleep(500); // 模拟任务延时
        }
    } catch (InterruptedException e)
    {
        e.printStackTrace();
    }
}).start();
```


### 进度指示器

```
<ProgressIndicator fx:id="myProgressIndicator" progress="0.5" GridPane.rowIndex="1" />
```
JAVA
```java
private ProgressIndicator myProgressIndicator;
myProgressIndicator.setProgress(0.75);  // 设置新的进度为75%
```





### 单选按钮

```xhtml
<RadioButton fx:id="myRadioButton1" text="选项1" GridPane.rowIndex="1" />
<RadioButton fx:id="myRadioButton2" text="选项2" GridPane.rowIndex="2" />
<RadioButton fx:id="myRadioButton3" text="选项3" GridPane.rowIndex="3" />
```
JAVA
```java
private RadioButton myRadioButton1;
private RadioButton myRadioButton2;
private RadioButton myRadioButton3;
ToggleGroup group = new ToggleGroup();// 将单选按钮分组
myRadioButton1.setToggleGroup(group);
myRadioButton2.setToggleGroup(group);
myRadioButton3.setToggleGroup(group);

group.selectedToggleProperty().addListener((observable, oldToggle, newToggle) -> {
    if (newToggle != null) {
        RadioButton selected = (RadioButton) newToggle;
        System.out.println("选中的选项是: " + selected.getText());
    }
});
```




### 滚动条


### 分隔线

### 滑块
FXML
```xhtml
<Slider fx:id="horizontalSlider" min="0" max="100" value="50" GridPane.rowIndex="0" />
<Slider fx:id="verticalSlider" orientation="VERTICAL" min="0" max="100" value="50" GridPane.columnIndex="1" GridPane.rowIndex="0" />
```

JAVA
```java
private Slider horizontalSlider;
private Slider verticalSlider;

horizontalSlider.valueProperty().addListener((observable, oldValue, newValue) -> {
    System.out.println("水平滑塊的新值: " + newValue.intValue());
});
verticalSlider.valueProperty().addListener((observable, oldValue, newValue) -> {
    System.out.println("垂直滑塊的新值: " + newValue.intValue());
});

```

- `min` `max` 滑塊的上限下限
- `value` 滑塊的初始值
- `majorTickUnit="10"` 刻度尺度，当你设置 `majorTickUnit="10"` 时，滑块的刻度线每隔 10 个单位就会显示一条主刻度线。
- `showTickMarks="true"` `showTickLabels="true"` 分別設置刻度線和刻度值是否顯示
- `blockIncrement="20"` 這個設置了鍵盤按一下移動的補償
- 上面的會反復監聽很浪費時間，所以我們可以使用一下兩種方法
```java
//按鈕確定
confirmButton.setOnAction(event -> 
{
    double finalValue = mySlider.getValue();
    System.out.println("滑塊的最終值: " + finalValue);
});
//設置鼠標鬆動就更新
mySlider.setOnMouseReleased(event -> {
    double finalValue = mySlider.getValue();
    System.out.println("滑塊的最終值: " + finalValue);
});
//监听滑块的拖动状态变化
mySlider.valueChangingProperty().addListener((observable, wasChanging, isChanging) -> {
    if (isChanging)  System.out.println("开始拖动滑块...");
    else  System.out.println("滑块停止拖动，最终值: " + mySlider.getValue());
});
//停止滑動就輸出（適用于鍵盤）
mySlider.valueProperty().addListener((observable, oldValue, newValue) -> {
    if (!mySlider.isValueChanging()) {
        System.out.println("滑块停止，当前值: " + newValue);
    }
});
```
### 分隔选单按钮

### 表格列

### 

23. SplitMenuButton
分隔菜单按钮：类似于菜单按钮，但还可以显示一个默认动作。
24. TableColumn
表格列：用于定义表格视图中的一列，包括列标题和数据类型。
25. TableView
表格视图：用于显示以表格形式组织的数据，支持行选择、排序和编辑。
26. TextArea
文本区域：用于输入多行文本，可以设置自动换行和其他文本格式化选项。
27. TextField
文本框：用于输入单行文本，通常用于表单输入。
28. ToggleButton
切换按钮：类似于按钮，用户点击时可以切换状态（选中和未选中）。
29. TreeTableColumn (FX8)
树形表格列：用于树形表格视图中的一列，支持层次化数据的显示。
30. TreeTableView (FX8)
树形表格视图：类似于表格视图，但支持层次化的数据展示，适用于展示复杂数据结构。


# 拓展

## 排版

1. 使用javafx排版自动生成的的分布，如`XXX.columnIndex`或者`XXX.rowIndex`，这个不要在IDEA里面修改

### 居中显示控件
 - 在IDEA中设置：

```java
VBox vbox = new VBox();
vbox.setAlignment(Pos.CENTER); // 将 VBox 内所有控件居中
```

 - 在fxml中设置
```
<VBox alignment="CENTER" spacing="10" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
    <!-- 其他控件 -->
</VBox>
```


## 快捷键
- 对于`qrButton`绑定`ENTER`键
```
qrButton.sceneProperty().addListener((observable, oldScene, newScene) ->
{
    if (newScene != null)
    {
        newScene.getAccelerators().put(new KeyCodeCombination(KeyCode.ENTER), qrButton::fire);
    }
});
```