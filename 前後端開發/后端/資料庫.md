# 程序設計

## 註釋

```sql
-- 這是一個單行註釋
/*
這是一個多行註釋，就像C++一樣
*/
```

SSMS里，創建和取消註釋的快捷鍵同`VS`，為 `Ctrl+K+C` `Ctrl+K+U`

## 報錯

⚠️

請注意，在該SSMS中，品紅色等並不代表報錯，可能表達核心關鍵字的渲染色，如`log on`

如果是下劃線，才是是出錯了，但是這個出錯可能也是錯的，比如新建了一個表格，數據庫沒有及時更新，可能會報錯表示這個表「不存在」，最終以
**實際運行** 為准

## 逗號

和C++的每句必分號不同，這裡的逗號是用來分隔的，最後一句話不需要加逗號

```sql
create
database DB
on
(
   /*……*/, --這裡有逗號
   /*……*/  --這裡沒有
), --這裡有逗號
(
    /*……*/
) --這裡沒有
```

## 大小寫

SQL對大小寫不敏感，`create database` 和 `CREATE DATABASE` 沒有區別，為了區分關鍵字和普通文字，一般情況下關鍵字使用全大寫 ~~
但是我不屑，C++、JAVA這麼多年過來的，習慣說改就改？~~

## 基礎語法

- 標識符（C++裡面叫做變量名）
- 英文字符：大小寫不敏感，所以不能同時聲明A、a兩個變量
- 阿拉伯數字：不能作為標識符的第一個字符
- 特殊字符：可以使用特殊字符 _#@$，但@ $不能作為標識符的第一個字符。
- 特殊語系的合法文字：例如中文字符也可以作為標識符的合法字符。
- 如果對象名稱不符合上述規則，只要在名稱的前後加上中括號（[ ]）。（*神經，拿程序的穩定開玩笑*）
- 標識符的長度不能超過128個字符。

## 變量

- 全局變量：由系統定義和維護，用戶只能讀取，不能修改；變量名前加`@@`。
- 局部變量：由用戶定義和使用，變量名前加`@`

局部變量使用範圍:只局限某一個批處理語句或過程體內
**一定要記得@！！** 這是C++里最不順手的一個符號

### 聲明

```sql
DECLARE
@A  CHAR(20)  -- @ 變量名 數據類型   用逗號分割之後可以重複
DECLARE
@f  float, @cn  CHAR(8) = 'aa'  --可以一邊聲明一邊賦值，未賦值不是初始化為0，而是null
```

### 賦值

```sql
DECLARE
@a int = 114514  --在聲明的時候賦值

DECLARE
@b char(30), @c int

SET @b = 'This is my test'  --set一次衹能給一個變量賦值
SET @c = 999

SELECT @b = 'This is my test', @c = 999 --select可以一次性給多個賦值
```

### 輸出

`print`一次只能輸出一個變量的值，以消息的形式輸出；
`select`一次可以輸出多個變量的值，以表格的形式輸出；

## 批處理

在一個批處理中，多個語句是一起提交給數據庫的，所以可以節省系統開銷，在特殊的過程中（如觸發器的定義），一些語句要獨佔一個批處理，這時候必須使用

```sql
USE
xkgl
GO  --一次性處理上面的一句話

PRINT '學生信息如下:'
SELECT *
FROM Student PRINT '學生人數爲:'
SELECT COUNT(*)
           學生人數
FROM Student
    GO --一次性處理上面的四句話
```

## 判斷語句

### 簡單判斷語句

```sql
IF
正誤表達式
BEGIN  --祇有一句的時候BEGIN END可以省略，用法和C++中的大括號完全相同
          /*做些什麼*/
END

ELSE   /*同C++，「另」分支在不必要的時候可以刪除*/
BEGIN
           /*做一些什麼*/
END
--支持嵌套「如」語句，名場面：明知嵌套「如」語句會退化成開關語句，仍然不敢動他
```

搜索判斷語句（只需要IF後面跟著SELECT語句就可以了）

```sql
IF
EXISTS  (             --姚某人對代碼縮進近乎偏執的追求
			SELECT * 
			FROM  /*  */ 
			WHERE /*  */
		  )
           /*做一些什麼*/
ELSE
           /*做一些什麼*/
```

## 開關語句

### 簡單開關語句

```sql
CASE 比較的變量
	WHEN 常量值甲 THEN 結果表達式甲
	WHEN 常量值乙 THEN 結果表達式乙

	[ELSE 其他結果表達式]--default
END --祇有end沒有begin
```

### 搜索開關語句

```sql
CASE 
/*不像C++共用判斷的變量，這裡所有的格致表達式都要是一個完整的正誤表達式*/
	WHEN 格致表達式1 THEN 結果表達式1
	WHEN 格致表達式2 THEN 結果表達式2
	
	[ELSE 其他结果表达式]
END 
```

## 循環語句

```sql
While
條件表達式 -- 不支持次循環，祇有當循環
BEGIN
	/*做一些什麼*/
	BREAK
CONTINUE RETURN --三個終止語句的用法和C++一模一樣
END
```

## 睡眠語句

時間必須爲`datetime`類型數據，延遲時間和時刻均采用`'HH：MM：SS'`格式。

```sql
WAITFOR
DELAY '01:12:13'  --表示延遲1小時12分13秒後程序繼續執行；
WAITFOR TIME '01:12:13'  --表示延遲到淩晨1小時12分13秒後程序繼續執行；
```

## 函數

标量函数、内嵌表值函数和多语句表值函数。

```sql
CREATE FUNCTION 函数名(形式参数名称 [ AS] 数据类型)
    RETURNS 返回值的数据类型 [AS]
BEGIN
		函数体
RETURN 标量表达式
END
```

```sql
CREATE FUNCTION get_name_fn(@stuNo char(12))
    RETURNS char(20)
AS
BEGIN
    DECLARE
@sname char(20)
select @sname = StudentName
from student
where StudentID = @stuNo RETURN @sname
END
```

调用：
```select  dbo.get_name_fn('St0109010001')```
或
```print  dbo.get_name_fn('St0109010001')```

（1）自定义函数必须在当前数据库中定义。
（2）其中参数名必须是以“@”开始的标识符，定义参数时必须指定数据类型，还可以根据需要设置一个默认值，默认值必须是常量。
（3）RETURNS指定返回值的数据类型，RETURN指定返回值，注意两个关键字的区别。
（4）在定义自定义函数时不必指明“所有者名称”，但是在调用自定义函数时必须写出“所有者名称.函数名称”并在圆括号内给出参数。
（5）在用户自定义函数中不能更改数据，仅用于返回信息。

# 資料定義

## 創建/刪除資料庫

- 创建

```sql
CREATE
DATABASE mydb  --總名稱
ON  --主資料文件，數量至少為一
(
    NAME = mydb_data1,           --格致名稱
    FILENAME = 'E:\SQL\mydb_data1.mdf',  --操作系統名：從根目錄開始的所有路徑+格致名稱+後綴
    SIZE = 6MB,           --初始大小，默認單位為百萬字節，至少是五百萬字節
    MAXSIZE = 30MB,       --最大值
    FILEGROWTH = 2MB      --增長幅度：絕對幅度*MB  相對幅度*%
),  --通過逗號分隔，加入不同的表比如class1或者clase2
( /* 假裝還有閑工夫再寫一個 */ ) ,--這裡要有逗號
FILEGROUP Data2 --輔助資料文件同上，數量任意
(     -- 名稱↑用于标识文件组，在建表的時候會用，
    NAME = data2, 
    FILENAME = 'E:\SQL\data2.ndf',  --主義後綴
    SIZE = 50MB, 
    MAXSIZE = UNLIMITED,   --無限制
    FILEGROWTH = 5MB 
) --這裡不要有逗號
LOG ON   --日誌文件同上，數量任意
(
    NAME = mydb_log,
    FILENAME = 'E:\SQL\mydb_log.ldf',
    SIZE = 2MB, 
    MAXSIZE = 10MB,
    FILEGROWTH = 1MB
)     --也可以創建多個日誌文件
```

`size maxsize`和`filegorwth`可以省略，系統會把他設定為預設值；但`name`和`filename`是必須指定的參數

- 删除

```sql
DROP
DATABASE database1 --刪除資料庫
DROP
DATABASE database1,database2
...... --同時刪除多個資料庫
```

## 創建/刪除資料表

資料表用於存貯資料，其中有三大要素需要確定：列名（不重名） 數據類型 約束條件

### 數據類型

- 整數

|     寫法     |  類型  |    大小     | 
|:----------:|:----:|:---------:|
| `  INT   ` |  整數  | 4字節 2^32  |
| `SMALLINT` | 小整數	 | 2字節 65535 |
| `TINYINT ` | 微整數	 |  1字節 255  |
| ` BIGINT ` | 大整數	 | 8字節 2^64  |

- 小數

|    寫法     |  類型  |  
|:---------:|:----:|    
| ` FLOAT ` | 浮點數  |   
| ` REAL  ` | 單精浮點 |
| `DOUBLE ` | 雙精浮點 |
| `DECIMAL` | 定點數	 |
| `NUMERIC` | 定點數	 |

- 日期和時間

|     寫法      |  類型  |          格式           |
|:-----------:|:----:|:---------------------:|
|  ` DATE `   | 浮點數  |     `NNNN-YY-RR`	     |
|  ` TIME  `  | 單精浮點 |     	`SS:FF:MM `      |
| `DATETIME ` | 雙精浮點 | `NNNN-YY-RR SS:FF:MM` |
| `TIMESTAMP` | 定點數	 | `NNNN-YY-RR SS:FF:MM` |

- 二進制

|        寫法         |   類型    |  
|:-----------------:|:-------:|    
|   ` BINARY(n) `   | 固定長度二進制 |   
| ` VARBINARY(n)  ` | 可變長度二進制 |
|     `IMAGE `      |  大型二進制  |

- 制糊串 ：）

|       寫法        |      類型       |    大小     |
|:---------------:|:-------------:|:---------:|
| `  CHAR(n)   `  |     固定長度串     | 4字節 2^32  |
|  `VARCHAR(n)`   |    可變長度串	     | 2字節 65535 |
|     `TEXT `     |    大型文本字段	    |  1字節 255  |
|  ` NCHAR(n) `   | 支持萬國碼的固定長度串	  | 8字節 2^64  |
| ` NVARCHAR(n) ` | 支持萬國碼的可變長度串	  | 8字節 2^64  |
|    ` NTEXT `    | 支持萬國碼的大型文本字段	 | 8字節 2^64  |

註：

1.

在最新版本中`TEXT`被設置為不推薦，理由是缺少靈活的操作支持。推薦的

|       寫法       |  類型  |    大小     | 
|:--------------:|:----:|:---------:|
| `  CHAR(n)   ` |  整數  | 4字節 2^32  |
|  `VARCHAR(n)`  | 小整數	 | 2字節 65535 |
|    `TEXT `     | 微整數	 |  1字節 255  |
|   ` BIGINT `   | 大整數	 | 8字節 2^64  |

- 貨幣

|       寫法        | 類型  |   大小   |
|:---------------:|:---:|:------:|
|    `MONEY `     | 錢數  | 8字節4小數 |
| ` SMALLMONEY  ` | 小錢數 | 4字節4小數 |

- 雜項

|     寫法      |     類型     |  
|:-----------:|:----------:|    
| ` BOOLEAN ` |    正誤值     |   
|  ` JSON  `  | 爪哇腳本對象語言資料 |
|   `XML `    | 可擴展標記語言資料  |

> ### 完整性約束
> - 為空約束     `NOT NULL`
> - 唯一性約束    `UNIQUE`
> - 主索引鍵約束  `PRIMARY KEY`
> - 外索引鍵約束  `FOREIGN KEY`
> - 默認值約束    `DEFAULT`
> - 列值約束      `CHECK`

### 類別

列級約束 跟在一列之後

```sql
CustomerID
int REFERENCES Customers(CustomerID)
```

表級約束 在所有列定義完成後

```sql
CustomerID
int,
    FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
```

我們將數據的引用關係和相關約束推廣到整個數據庫中

```sql
CREATE TABLE Enrollments
(
    EnrollmentID   INT PRIMARY KEY,
    StudentID      INT,
    CourseID       INT,
    EnrollmentDate DATE,
    FOREIGN KEY (StudentID) REFERENCES Students (StudentID),
    FOREIGN KEY (CourseID) REFERENCES Courses (CourseID)
);
```

### 自增編號

在 **mySQL** 中，使用語句`AUTO_INCREMENT`實現編號自增，如

```sql
CREATE TABLE words
(
    id   INT PRIMARY KEY AUTO_INCREMENT,
    word VARCHAR(255) UNIQUE NOT NULL
);
```

在 **SSMS** 中，使用語句`IDENTITY(初始值, 自增)`

```sql
CREATE TABLE Users
(
    ID   INT IDENTITY(1,1) PRIMARY KEY, -- ID 自增，起始1，每次遞增1
    Name NVARCHAR(100) NOT NULL
);

```

## 修改資料表

### 添加新的列

```sql
ALTER TABLE table1
    ADD column1 NVARCHAR(400);
```

### 刪除列

```sql
ALTER TABLE table0 DROP COLUMN column0;
```

### 修改列名稱

从`table1`中的`column1`修改為`column22`

```sql
EXEC sp_rename 'table1.column1', 'column22', 'COLUMN';
```

# 資料操作

## 插入資料

```sql
USE
YeuYanShyue--特定的資料庫
insert into tongzifangan (zi,pinyin,zhuyin,tongzi)--insert into 表名稱 (對應的列)
values ('姚','yáo','ㄧㄠˊ','yau')--對應的值

--如果一一對應的話（正式名稱：完整的資料記錄），可以省略列名
insert into tongzifangan values ('姚','yáo','ㄧㄠˊ','yau')
--默認地，into關鍵字也可以省略
insert tongzifangan values ('姚','yáo','ㄧㄠˊ','yau')
```

在插入的時候沒有提到的格子為空值，但是要是有完整性約束則無法插入

加上逗號可以插入更多信息

```sql
insert into tongzifangan
values ('姚', 'yáo', 'ㄧㄠˊ', 'yau'),
       ('說', 'shuō', 'ㄕㄨㄛ', 'seor'),
       ('文', 'wén', 'ㄨㄣˊ', 'wun')
```

## 修改資料

```sql
UPDATE tongzifangan --特定的資料表
SET tongzi= 'xxxx' --修改的內容，可以修改多個，但是不能多次修改，如 SET tongzi= 'xx',tongzi='?'
WHERE zhuyin = 'ㄕㄨㄛ' --條件，沒有條件就是對全員操作
```

`where` 的條件查詢見後面，後面會做詳細說明

修改列的約束

```
ALTER TABLE tongzifangan alter COLUMN tongzi CHAR(8) NULL;
```

## 刪除資料

```sql
--不加條件：刪庫跑路
DELETE
FROM Department;
```

```sql
delete
from tongzifangan
where zi = '龘'
```

數據完整性

# 資料查詢

## 簡單查詢

模板

```sql
SELECT 去重器 篩選器 字段列表 別名
FROM 表名(可以多個)
WHERE 條件表達式
GROUP BY 字段名
HAVING 條件表達式
ORDER BY 字段名 排序規則
```

### 去重器：`ALL` / `DISTINCT`

`ALL`返回所有滿足條件的結果，`DISTINCT`則返回不重複的結果,這個參數可以省略，按照`ALL`做默認值

### 篩選器：`TOP N` /`TOP N percent`

`TOP N`表示祇返回前`N`行，`TOP N percent`表示祇返回前N%
●在上面兩個限制同時出現的時候，先執行TOP字句，再執行DISTINCT語句，因為後者去重導致的行數減少不補
●並列選項：使用`WITH TIES`關鍵字，如果在篩選的邊界上有多行具有相同篩選字段，`WITH TIES`將會返回所有行

### 字段：行háng

字段列表：哪一些行 字段名：哪一行 所有字段（列）都要的時候使用通配符*
虛列：可以不是資料表里的原始數據，而是通過計算得到，算术表达式、字符串常量和函数均可。

```sql
SELECT StudentName AS     "姓名",
       (YEAR(birth)) + 18 入學時間, --算數表達式
       '畢業' [是否畢業],          --字符串常量
YEAR(GETDATE())-YEAR(birth) [年齡]  --算數表達式+函數
FROM student
```

### 別名

跟在每一列後面，有很多種方法，連接方式可以選擇用AS關鍵字連接，也可以不用任何關鍵字連接；別名的範圍可以使用雙引號、單引號、中括號、或不用任何符號框住

```sql
SELECT --正在發癲
       StudentName AS "姓名",
       StudentName AS '姓名', StudentName AS [姓名],
StudentName AS  姓名,
StudentName    "姓名",
StudentName    '姓名',
StudentName    [姓名], 
StudentName     姓名
FROM student --結構化查詢語言真是一個很自由的語言
```

### 來源FROM

從指定表中獲取信息

### 排序 ORDER BY

對排列結果排序，`ASC`升序 `DESC`降序，默認為升序排列

```sql
SELECT *
FROM student
ORDER BY ClassID DESC, StudentID ASC --表示先按照班級代碼降序，同一班級的按照學號升序
```

### 條件表達式WHERE

- 多重條件查詢

連接符號 `NOT` `AND` `OR` 連接多個條件

比較查詢

`WHERE`的兩個表達式之間 使用比較運算符（終於不是C++裡的==了，還多了幾個<>，！<,!>）

範圍查詢

```sql
SELECT *
FROM Student
WHERE Birth BETWEEN '1990-04-04' AND '1995-05-04'
```

`BETWEEN` 閉區間 `[val1, val2]`

`NOT BETWEEN` 雙開區間` (-inf, val1) U (val2, inf)`

`val1`要小於`val2`，否則表達式不合法，沒有結果

集合查詢

```sql
SELECT *
FROM Teacher
WHERE Profession IN ('講師', '副教授', '教授')
```

`IN` 在範圍內  `NOT IN` 不在範圍內

模糊查詢

`LIKE` 匹配  `NOT LIKE` 排除
通配符：%任意長度字符串  _任意字符 這兩個的區別體現在長度確不確定

```sql
LIKE '姚說文' --等價於 ='姚說文'，因為沒有使用到任何通配符
LIKE '姚_'    --尋找姚某（不找姚某某）
LIKE '姚%' --尋找姚姓人
LIKE '姚%%%%%'--神經病一樣尋找姚姓人
```

字符集：使用中括號[]，一個中括號裡面代表一個字符，不需要加逗號，有以下幾種表達方式
字符集`[abc]`  可以匹配字符集中任何一個字符
否定字符集`[^abc]`   可以匹配除了字符集中的任何一個字符
範圍集合`[a-z]`或者`[0-9]`  匹配區間內的任意符號
轉義字符->  使用\^來表示^字符本身而不是否定 把-放在末尾來表示-字符本身而不是範圍
轉義符號：

```sql
SELECT * -- 查詢以'db_'開頭，且倒數第3個字符爲i的課程的詳細情况。
FROM Course
WHERE CourseName LIKE 'db\_%i__' escape '\' --使用方法：轉義+通配符 在外面聲明轉義
```

- 空值查詢

```sql
SELECT *
FROM Class
WHERE Monitor IS NULL
```

`IS NULL` 為空 `NOT NULL` 不為空
●不能使用` = NULL`，`NULL` 被視為未知的值，因此使用` = NULL `將始終返回`UNKNOWN`，而不是`TRUE`或`FALSE`

- 使用函數查詢

```sql
SELECT StudentName 姓名, STR(YEAR(Birth)) + '年' + LTRIM(STR(MONTH(Birth))) + '月' AS 出生年月
FROM student
WHERE LEFT (StudentName, 1)='張'
```

字符串函數

對`C++`標準模板庫瞭如指掌，所以我用`C++`的概念來說明

| sql函數              | C++函數                                             |     作用      |
|:-------------------|:--------------------------------------------------|:-----------:|
| STR()              | `to_string()`                                     |    轉字符串     |
| LEFT(str,n)        | `str.substr(0,n)`	                                |   取左邊`n`位   |
| RIGHT(str,n)       | `str.substr(str.size()-n,n);`	                    |   取右邊`n`位   |
| SUBSTRING(str,l,n) | `str.substr(l-1,n)`	                              | 從第`l`位起刪除n個 |
| LTRIM()            | `s.erase(0, s.find_first_not_of(" \t\n\r\f\v"));` |   刪除左側空格    |
| RTRIM()            | `s.erase(s.find_last_not_of(" \t\n\r\f\v") + 1);` |   刪除右側空格    |
| CONCAT(a,b)        | `a+=b` 	                                          |    連接字符串    |

**⚠️注意**：SQL的索引從1開始，所以你懂的

- 日期函數

```sql
GETDATE
() --函數以DATETIME 的默認格式返回系統當前的日期和時間
DAY() --函數返回date_expression 中的日期值
MONTH() --函數返回date_expression 中的月份值
YEAR() --函數返回date_expression 中的年份值
DATEDIFF(<datepart> ,<number> ,<date>)
--函數返回兩個指定日期在datepart 方面的不同之處
select datediff(year,sbirthday, getdate())
from student
```

統計查詢

```sql
SELECT [ALL | DISTINCT] 字段列表|聚合函數
FROM 表名
WHERE 條件表達式
GROUP BY 字段名
HAVING 條件表達式
WITH ROLLUP 
```

篩選器的區別

- `WHERE` 子句：用于在分組和聚合之前過濾普通的數據行。它在查詢開始時應用，以篩選出符合條件的記錄。
- `HAVING` 子句：用于在分組和聚合之後過濾聚合函數的結果。它在查詢的聚合部分完成後應用，以篩選出符合條件的分組結果。

聚合函數
`COUNT(*)`    功能：忽略空值地返回行數
COUNT(列名) SUM(列名) AVG(列名)  MAX(列名)     MIN(列名)  STEDV(列名)  VAR(列名)
返回指定列中非空值的 行數 / 之和 / 平均值 / 最大值 / 最小值 / 偏差 / 方差

### 去重器DISTINCT / ALL

對於 count
all|默認 ：返回非空行數，對於非null列，這個結果和求行數(*)沒有區別
distinct ：返回去重之後的非空行數，有點像存進了std::unordered_set再求size
對於max min
去重與否不影響結果，所以不支持
對於sum avg stedv var
all|默認 ：除了濾過空值，不影響其他的，像加權平均數
distinct ：所有的數據都只用一遍，

## 分組查詢

上面的聚合函數衹能單獨使用或者和其他函數一起使用，不能和非聚合列一起使用

```
SELECT Profession ,COUNT(*)  --錯誤示範
FROM teacher  --因為Profession行沒有聚合是多條數據，所以沒法和聚合函數的單條數據合在一起
```

可以使用group by把非聚合列聚合，這樣聚合函數也變成了這一個小組的聚合結果

```sql
SELECT Profession, COUNT(*) AS 人數
FROM teacher
GROUP BY Profession --查詢每一個職稱的人數
```

有了它，我們就能自由組合聚合函數和列了

```sql
SELECT CourseID   AS 課程編號,
       MAX(grade) AS 最高分,
       MIN(grade) AS 最低分,
       AVG(grade) AS 平均分,
       COUNT(*)   AS 人數
FROM Grade
GROUP BY CourseID --查詢每一門課的有關信息
```

請注意，為了不再出現上面的錯誤，所有非聚合列都要放在group by 裡面，所以語法規定group
by里可以有多個語句，表示按多個字段分組。結果先對前面的分組，再對後面的分組，但是后分組的反而更整齊一些
SELECT product, region, SUM(amount) AS total_sales
FROM sales
GROUP BY product, region;
若用于分組的列中包含有`NULL`值，則`NULL`將作爲一個單獨的分組返回；若該列中存在多個`NULL`值，則將這些`NULL`值所在的行分爲一組。

- 過濾器HAVING

`HAVING`子句和`WHERE` 子句相似，都用于條件的篩選。幷且`HAVING`子句支持WHERE子句中所有的操作符和語法
流程：
使用`WHERE`檢查行的信息，去掉不符合要求的行，分組打包；
使用`HAVING`語句檢查分組的信息（一般由聚合函數提供），去掉不符合要求的分組
`HAVING`子句是在數據分組後進行過濾，`WHERE`子句會在數據分組前進行過濾，`WHERE`子句排除的行不包含在分組中，所以在`WHERE`
的時候還沒有分組，所以`WHERE`不能使用聚合函數作為篩選條件

- 彙總函數

WITH ROLLUP加在最後面，把所有聚合函數的值做一個彙總，其他的列為NULL

## 連接查詢

有點像兩張表對齊，前提是兩張表有相同的欄目，切兩張表有信息互為需要

### 種類

> ### 種類和區別
>
> 主要區別：不匹配的部分如何處理，就比如兩張表「對齊」可能有對不上的部分
>
> - #### 內連接`INNER JOIN` / `JOIN`

    >    兩張表的不匹配的部分全部丟棄，祇有滿足連接條件，才提取數據並組合成新的記錄

> - #### 左外連接 `LEFT JOIN`

    >   左表為主表，左表匹配不上的部分保留，在應該對應右表的部分填充NULL，右表不匹配的丟棄

> - #### 右外連接 `RIGHT JOIN`
> - #### 全外連接 `FULL JOIN`
> - #### 交叉連接 `CROSS JOIN`
>
> 如上兩張表“對齊”，可能有對齊不上的部分。
> 1. 內連接
> 2. 左外連接
> 3. 右外連接 相反，右表保留，左表丟棄
> 4. 全外連接 都保留，空著的地方都填充NULL

內連接

等值連接
在連接條件中使用等號(=)運算符比較被連接列的列值，其查詢結果中列出被連接表中的任何列，包括其中的重複列。
例：使用等值連接列出professional表和department表中各系部的專業情况(代碼10)
不等值連接
在連接條件使用除等于運算符以外的其他比較運算符比較被連接的列的列值。這些運算符包括`>`、`>=`、`<=`、`<`、`!>`、`!<`和`<>`。
自然連接
自然連接是等值連接的一種特殊情况，即在連接條件中使用等于(=)運算符比較被連接列的列值，但它使用選擇列表指出查詢結果集合中所包括的列，幷删除連接表中的重複列。
例：使用自然連接列出professional和department表中各系部的專業情况。
自連接
自己和自己進行連接，即一個表與其自身進行連接

一種語法格式

```sql
SELECT CourseID, grade
FROM Student
         INNER JOIN Grade --連接表
                    ON Student.StudentID = Grade.StudentID --連接條件
WHERE StudentName = '張宏' --限定條件
```

另一種語法格式

```sql
SELECT Grade.CourseID, Grade.grade
FROM Student,
     Grade --直接使用逗號連接表
WHERE Student.StudentID = Grade.StudentID
  AND Student.StudentName = '張宏'; --因為鏈接條件佔用了WHERE，所以這裡要用一個AND連接
```

多表查詢時，任何子句中引用同名屬性時，都必須加表名前綴。引用唯一屬性名時可以加也可以省略表名前綴。例如`Student.StudentID`
表示學生表中的學號，`Grade.StudentID`
表示選課表中的學號。
爲了增加書寫便利及代碼的可讀性，可以使用表的別名（直接跟在表後）。但要注意一旦使用了別名代替某個表名，則在查詢時必須用表的別名，不能再用表的原名。

自連接

```sql
SELECT *--G2.StudentID
FROM Grade G1
         JOIN Grade G2 ON G1.StudentID = G2.StudentID --把它用學生連接起來
WHERE G1.CourseID = 'Dp010001'
  AND G2.CourseID = 'Dp010003'
```

在不篩選之前，這個的連接可能會產生，假設說文選了1、2、4們課

`(G1|G2): (1 1) (1 2) (1 4) (2 1) (2 2) (2 4) (4 1) (4 2) (4 4)`

篩選的時候就取1 3一種，這解釋了為什麼能“恰好“選取左1又3的情況

外連接

交叉連接
交叉連接就是不帶連接條件的查詢，返回被連接的兩個表所有數據行的所有組合。即用左表中的每一行與右表中的每一行分別進行連接。因此，結果集中的行數是左表的行數乘以右表的行數。
交叉連接沒有實際意思，通常用于測試所有可能的情况。

```sql
SELECT *
FROM Student
         CROSS JOIN Course --Student 22 Course7 最後是154行
```

嵌套查詢

# 資料控制

## 視圖

## 函數

## 存儲過程

事務控制
存貯過程
將多次重複執行的實現特定功能的代碼段編寫成一個“過程”，經編譯後存儲在數據庫中的SQL程序，幷由SQL
Server服務器通過其過程名來進行調用，這樣的“過程”就叫做存儲過程。

不帶參數的存貯過程

帶參數的存貯過程

創建帶輸出參數的存貯過程

創建具有更新功能的存貯過程

觸發器
使用場景
1.操作數據前，需要執行安全性或合法性檢查時（數據的完整性和一致性）
2.當一個數據操作行爲的發生會激活另一個動作時（關聯數據）
3.修改數據之後，將這條數據進行一個備份，作為操作日誌

觸發器(trigger)是一類特殊的存儲過程，觸發器基于一個表創建，但可以操作多個表。他的特殊性體現在：
1.針對特定的表；
2.不能接收和傳遞參數；
3.只能被動響應，不能主動觸發；

創建觸發器（觸發器的要素）

```sql
USE
xkgl
GO
--Create Trigger必須是批處理中僅有的操作，所以GO不能省
Create Trigger tri_After
    ON Teacher AFTER INSERT 
AS
     Print '成功添加' --多句話begin end
```

修改觸發器

```sql
ALTER
TRIGGER triggerA   --有則改之，無則創建的寫法：CREATE OR ALTER TRIGGER triggerA 
ON table_name  --新的觸發對象
AFTER INSERT  --新的觸發時間和事件
AS /*新的觸發器動作*/
```

刪除觸發器

```sql
DROP TRIGGER trigger_example;
```

類型
資料定義語句觸發器 DDL：Create、Alter和Drop等操作触发的触发器。
資料操作語句觸發器 DML：如INSERT、DELET和UPDATE等操作触发的触发器。

修改操作 inserted表 deleted表
增加(INSERT)记录 存放新增的记录 ------
删除(DELETE)记录 ------ 存放被删除的记录
修改(UPDATE)记录 存放修改后的记录 存放修改前的记录
1.DML觸發器觸發的時候系統自動創建deleted表或inserted表（英語單詞過去式），只讀，觸發器執行完成之後自動銷毀
2.每個UPDATE、INSERT和DELETE語句最多可以定義一個INSTEAD OF觸發器。

```sql
--展示臨時表的作用
Create Trigger tri_After --創建AFTER觸發器
    ON Class AFTER INSERT --插入之後的觸發器
AS
SELECT *
FROM Class --會展示一整個插入數據的表格
SELECT *
FROM inserted --會展示剛才插入的那一條數據
--之後的某一段時間觸發觸發器
    INSERT
INTO Class
VALUES ('Cs011108', '12網絡工程', '張三', 29, 'Dp01')
```

前後觸發器
前觸發器：關鍵字`instead of`，满足條件衹執行觸發器，不再執行觸發事件
後觸發器：關鍵字`for`或者`after`，先執行觸發事件，再執行觸發器
對于數據庫表，三種類型的觸發器都可以使用。而對于視圖，只有`INSTEAD OF`觸發器是可用的。

使用後觸發器檢查數據合法性

```sql
CREATE TRIGGER tri_grade
    ON Grade AFTER INSERT,
UPDATE
    AS
        IF exists (SELECT * FROM inserted where grade<0 or grade>100)
BEGIN
    PRINT
'輸入的分數應該在0-100分之間，請確認輸入的考試分數！'
    ROLLBACK        --回滾，撤銷當前事務中的所有操作，使數據庫恢復到事務開始時的狀態。
END
ELSE
    PRINT '修改成功!'
```

使用前觸發器檢查數據合法性

```sql
CREATE TRIGGER tri_grade
    ON Grade INSTEAD OF INSERT,
UPDATE
    AS
BEGIN
    IF
exists (SELECT * FROM inserted where grade<0 or grade>100)
BEGIN
        PRINT
'輸入的分數應該在0-100分之間，請確認輸入的考試分數！'
END

ELSE
BEGIN
        PRINT
'修改成功!'
        IF EXISTS (SELECT * FROM deleted)--在删除表中發現了數據，說明是更新
BEGIN
            -- 更新操作
UPDATE Grade
SET grade = inserted.grade FROM inserted
WHERE Grade.id = inserted.id;
END

ELSE --沒有發現數據，所以是添加
BEGIN
INSERT INTO Grade (id, student_id, course_id, grade)
SELECT id, student_id, course_id, grade
FROM inserted;
END
END
END
```

額外功能
利用前觸發器的截斷特性，可以設置阻止某一種形式的任意的數據修改，甚至可以加上一句嘲諷
利用后觸發器的特性，可以維護冗餘數據，比如在加入某一個教師的，在另外一張表上修改教師總數

# 資料庫設計

關係規範化理論

如果一个关系模式R的所有属性都是不可分割的基本数据项，则`R∈1NF`。
第一范式是对关系模式的最起码的要求。不满足第一范式的数据库模式不能称为关系数据库。

- 不滿足：`進貨數量和單價` 改成：`進貨數量|進貨單價`
- 不滿足：`高三一班` 改成：`高三|一班`

---

# 數據庫的指令

## 資料庫狀態

1. 打開資料庫：輸入用戶名和密碼

```
mysql -u root -p
BuDou&123
```

2. 幫助：三種

```
help    \h     ?
```

3. 退出資料庫：三種

```
exit  quit  \q 
```

## 資料庫

1. 查看有哪一些資料庫，并進入

```
SHOW DATABASES;
USE db1;
```

查看某一個資料庫有什麼表格

```
SHOW TABLES;
```

4. 查看某一個表的結構

# 數據庫的資料結構

## 邊及樹（`B tree`）

### 定義：一種平衡多叉樹，旨在處理大規模數據。

### 用處

當數據較多的時候，不可能都存在內存裡，所以要通過硬盤來調取。與二叉樹相比，這種資料結構的每一個節點可以儲存多個元素，從而降低樹的高度，減少硬盤的訪問次數。

### 特點

1. 平衡：絕對平衡，樹的所有葉子節點都在同一層。
2. 有序：左子樹都小於它，右子樹都大於它。（忽略相同元素，有相同元素的時候，`=`可以加在`<`或者`>`的任何一個上）
3. 多路：

- 幾階樹就是表示幾叉樹。每一個節點通過自身`k`個值決定下面`k+1`個分支。
- 判斷規則類似於`if-elseif-else`語句中`k`個條件分支和`1`個默認分支。 如節點`A B C D`

```javascript
if (i < A) {
} else if (i < B) {
} else if (i < C) {
} else if (i < D) {
} else {
}
```

- 對於`m`階樹而言
    - 最多：每一個節點最多`m`個分枝，這些分支是由`m-1`個元素區分開的。
    - 最少：根節點最少`1`個元素分成`2`個分支，其他節點是一半：`⌈m/2⌉-1`個元素分成`⌈m/2⌉`個分支。

### 查找

1. 從根節點開始尋找
2. 在節點內，可以使用**順序查找**或者**二分查找**，找到第一個大於查找值的元素，或者找不到
3. 如果找到大於的元素，走這個元素的左枝；如果沒有找到，走唯一那個右枝
4. 成功：如果出現等於，匹配完成
5. 失敗：叶節點仍然匹配不上，會滑入失敗空節點，判定沒有

### 插入/構建

1. 插入只在葉節點上進行
2. 先尋找應該插入的位置，在葉節點處不滑入失敗節點
3. 插入元素，重複進行下面4~6
4. 對於`m`階樹而言，每一個節點`m-1`元素，多出稱作上溢出
5. 上溢出處理方式
   > ### 中間元素的判定：
   > - 奇數個元素為中間元素： `..*..`
   > - 偶數個元素為中間偏左元素`.*..`
   > - 當索引從`0`開始的時候，計算方式為`⌈m/2⌉`
   > - 中間元素上推：中間元素推入幹節點有序的那個位置，中間元素左右元素分裂兩個分枝，連在原來的位置
6. 元素上推可以控制元素數量，但是可能導致幹節點同樣溢出，所以要重複進行。當根節點也溢出的時候，將會在原來根節點上新增一層，同時根節點也可以上推和分裂

### 刪除

1. 刪除衹在葉節點上進行。
2. 先尋找應該刪除的位置
   > #### 如果要刪除的元素是葉節點：直接刪除
   > #### 如果不是：
   > 1. 尋找他在葉節點上的直接前驅或者後繼
   > 2. 替換這個節點和找到的葉節點（葉節點替換到刪除元素的位置）
   > 3. 刪除葉節點
3. 對於`m`階樹而言，每一個節點`⌈m/2⌉-1`元素，少於稱作下溢出
4. 下溢出處理方式

查看是否可以「借用」
如果左右幹節點借用一個元素不會下溢出

```
51         65       74          90
|          |        |        |        \
47 50   53 57 60   72    76 83 86    92 98
```

## 懸垂邊及樹（`B+ tree`）

特點

|         分類          |            特點             |
|:-------------------:|:-------------------------:|
| 所有關鍵字的所有元素都有直接對應的指針 | 所有關鍵字的所有元素都有直接對應的指針，衹能有一個 |
|        唯一索引         |     避免同一個表中某數據列中的值重複	     |
|        常規索引         |         快速定位特定數據	         |
|        全文索引         |  快速尋找文本中的關鍵詞，而不是比較索引的值	   |

---

# 索引

## 概述

> ### 定義
> 幫助 **高效獲取資料** 的 **有序** 的 **資料結構**
>
> ### 重要性
> 如果沒有索引，查詢的時候都必須遍歷全表（全表掃描）
>
> ### 特點
> - ✅ 提高資料的查詢和排序效率
> - ❌ 索引列需要佔用空間，且維護索引需要額外耗時（完全可以忽略）
>
> ### 資料結構
>
> 1. 懸垂邊及樹（`B+ tree`）
> 2. 散列表（`hash`）

## 分類

### 1. 根據性質分類

|  分類  |           特點           |   關鍵字    | 
|:----:|:----------------------:|:--------:|
| 主鍵索引 |  在創建主鍵的時候默認自動創建，衹能有一個  | PRIMARY  |
| 唯一索引 |   避免同一個表中某數據列中的值重複	    |  UNIQUE  |
| 常規索引 |       快速定位特定數據	        |    -     |
| 全文索引 | 快速尋找文本中的關鍵詞，而不是比較索引的值	 | FULLTEXT |

### 2. 根據存儲形式分類

|           分類            |                特點                |  關鍵字   | 
|:-----------------------:|:--------------------------------:|:------:|
| 聚集索引（`Clustered Index`） |       數據和索引放到了一起，葉節點保存了行數據       | 有且祇有一個 |
| 二級索引（`Secondary Index`） | 數據和索引分開存，葉節點關聯的是對應行的主鍵         	 | 可以有多個  |

> ### 聚集索引選取規則
> - 如果有主鍵，主鍵就是聚集索引
> - 否則將使用第一個唯一索引作為聚集索引
> - 否則會自動生成一個自增的類作為隱藏的聚集索引

### 3. 根據選取的列的數量

- 單列索引：基於單個字段
- 聯合索引（組合索引）：基於多個字段

## 使用

### 基礎用法

> ### 1. 創建索引
> ```sql
> CREATE [UNIQUE|FULLTEXT] INDEX index1 ON table1 (col1...);
> ```
> ### 2. 查看索引
> ```sql
> -- MySQL
> SHOW INDEX FROM table1
> 
> -- SSMS
> EXEC sp_helpindex 'table_name';
> SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID('table_name');
> ```
> ### 3. 刪除索引
> ```sql
> DROP INDEX index1 ON table1 --MySQL
> 
> DROP INDEX table1.index1    --SSMS
> ```

## 性能分析工具

## 使用規則

### 1. 聯合索引：最左前綴法則   `Leftmost Prefix Rule`

**定義：當資料庫使用複合索引時，查詢中必須符合索引的最左邊欄位的條件，才能有效利用該索引。**

解讀：索引的有序性是最左前綴法則生效的基礎。右側是否可以篩選取決於是否已經按照左側篩選，所以即使包含了左側的列，如果沒有正確的順序，也無法利用

> 例子：當複合索引的順序是`(A, B, C)`
>
> - 充分利用的情況：完全按照順序利用各個列篩選
> ```sql
> WHERE A = ? AND B = ? AND C = ?
> ```
>
> - 能利用的情況：完全按照順序篩選，但沒有用上所有列
> ```sql
> WHERE A = ?
> WHERE A = ? AND B = ?
> ```
>
> - 效率不高的利用：沒有完全按照順序篩選，導致部分索引失效
> ```sql
> -- 部分不遵循「最左前綴法則」
> WHERE A = ? AND C = ? -- 沒有用上B篩選，C就會失效，但是A仍然可以使用
> ```
>
> - 無法利用的情況：沒有按照順序篩選，導致索引完全失效
> ```sql
> -- 完全不遵循「最左前綴法則」，前面的沒有用上，後面的就用不了
> WHERE C = ? 
> WHERE B = ? AND C = ?
> ```

> ### 範圍查詢
>
> - 聯合索引中出現範圍查詢`>` `<`，右側的索引失效
>
> ```sql
> WHERE A > ? AND B = ? -- B 索引失效
> ```
> 規避方法：在條件允許的情況下，使用`>=` `<=`
> ```sql
> WHERE A >= ? AND B = ? -- 不會失效
> ```

### 2. 模糊查詢確定頭部

等效於「最左前綴法則」的原理，字符串的篩選相當于一整個的聯合索引，左側模糊，右側無法使用

```sql
SELECT *
FROM student
WHERE major = '軟件%' -- 索引正常

SELECT *
FROM student
WHERE major = '%工程' -- 索引失效
```

### 3. 索引列避免修改

> - 不要數學運算
>
> ```sql
> SELECT *
> FROM users
> WHERE age - 18 = 30
> ```
>
> - 不要函數運算
> ```sql
> SELECT *
> FROM TIMES
> WHERE YEAR (date_column) = 2024
> ```
>
> - 不要觸發隱式轉換
>
> ```sql
> -- 是字符串的不要忘引號（假設手機號為字符串）
> SELECT *
> FROM users
> WHERE phone = 13600000001 -- 數字->字串
> -- 不是字符串的不要加引號
> SELECT *
> FROM users
> WHERE age = '24' -- 字串->數字
> ```

### 4. `OR`運算符的正確使用

用`or`分割開的條件，如果任意一個中沒有索引，那麼涉及的索引全部都不會用到

```sql
-- 索引有A沒有B
WHERE A = ? OR B = ? -- 都用不上了
```

### 5. 平臺放棄索引

- 如果平臺評估使用索引比全表更慢，則不使用索引
- 即：如果查詢的條件過於寬泛，沒有有效 **篩選** 出數據，那麼索引的使用反而會帶來額外的性能開銷，因此資料庫會選擇放棄索引，使用全表掃描來查詢

```sql
SELECT *
FROM student
WHERE age < 100 /*當大部分數據都是，放棄使用索引*/
```

### 6. 手動提示

### 7. 覆蓋索引

在不需要所有數據的時候，減少`*`的使用，而是使用覆蓋索引：查詢用上了索引，並且需要返回的列都是這個索引的一部分

```sql
-- 當複合索引的順序是(A, B, C)，要通過 A 的篩選尋找(A B)
-- ❌
SELECT *
FROM users
WHERE A = ?
-- ✅
SELECT A, B
FROM users
WHERE A = ?
```

> ### 原理
>
> 對於二級索引而言，樹上是 **關鍵字** ，葉子上的是對應數據的 **主鍵**
>
> 回表查詢：一般的步驟是，通過關鍵字尋找到主鍵，回到聚集索引使用主鍵查找
> 索引覆蓋：當需要的數據都在關鍵字里的時候，篩選到關鍵字就得到了數據，無需回表

### 8. 前綴索引

過長的字串可能會讓索引變得笨重，只將一部分前綴建立索引可以節約索引空間

- 建立

```sql
-- 對 table1 的 col1 的前 n 个字符建立索引
CREATE INDEX index1 ON table1 (col1(n));
```

- 效率和長度分析

> 選擇性：不重複的索引數/總數，索引選擇性越高查詢效率越高，唯一索引的選擇性是`100%`，效率最好，但字串更長
> ```sql
> SELECT 
> COUNT(DISTINCT SUBSTRING(bolg, 1, 5) / COUNT(*) FROM table1
> ```

- 查詢原理

由於索引選擇性很難完全達到`100%`，所以必然有對重複前綴的索引。

1. 用字串篩選時，首先按照要求截取
2. 這裡查找樹可以正確查找重複元素，首先尋找第一個等於截取串的元素
3. 根據葉節點的主鍵找到該列，檢查兩串是否 **完全相等** ，相等即返回
4. 隨著鏈表繼續遍歷，重複步驟`3`，直到截取串不等於鏈表元素

流程

### 9.

## 設計原則

1. 選表：選數據量大，查詢比較頻繁的表
2. 選字段：選經常做篩選`WHERE` 排序`ORDER BY` 分組`GROUP BY`的
3. 選列：選擇區分度高的列作為索引，儘量建立唯一索引，區分度越高，使用索引的效率越高
   >
4. 如果是較長的字符串，建議·建立前綴索引
5. 儘量使用聯合索引，減少單列索引，查詢的時候，聯合索引很多時候可以避免回表查詢
6. 控制索引的數量，索引太多會拖慢**增刪改**的效率
7. 如果索引不允許`NULL`值，請添加非空約束，可以使得優化器更好判斷更高效的索引

# 語句優化

## 插入數據

### 1.多條語句合併成一條語句

不要寫成多次插入的形式，儘量放在一個語句里

```sql
insert into table1
values (1, 'a'),
       (2, 'b'),
       (3, 'c');
```

> 提昇效率最好的範圍在一條語句插入`1000`以下的數據，也就是說，當數據大於`1000`的時候

### 2. 手動提交事務

```sql
-- mySQL
START TRANSACTION;
COMMIT;

-- SSMS
BEGIN
TRANSACTION;
COMMIT;
```

### 3. 主鍵順序插入

### 4. 大批次插入數據

load

## 主鍵

設計原則

1. 在滿足業務需求的情況下，儘量降低主鍵的長度
2. 插入數據的時候，儘量選擇順序插入，也可以使用選擇使用自增主鍵`AUTO_INCREMENT`
3. 不要使用唯一識別碼（`Universally`）

## 排序（ORDER BY）

### 執行方式

- 使用文件排序（`USING FILESORT`）
- 使用索引（`USING INDEX`）

## 更新（UPDATE）

## 聚合（GROUP BY）

# 存貯過程

# 觸發器

---------------------------

# 併發運行

## 事務（Transaction）

### 定義

> 一系列連續的操作，為了保證這些是完整的，這裡面要麼全部執行，要麼全部不執行。

### 特性：簡稱 `ACID`

> ### 1. 原子性 `Atomicity`
>
> 事務中的所有操作要麼全部執行，要麼全部不執行。這意味著如果事務中任何操作失敗都會回滾到事務開始之前的狀態，而不能部分成功並留下中間狀態。
>
> ### 2. 一致性 `Consistency`
>
> 事務開始之前和事務結束之後，資料庫都處於一致的狀態。例如，一些約束（如外鍵約束、唯一性約束等）都必須保持原狀。
>
> ### 3. 隔離性 `Isolation`
>
> 事務在執行過程中不會被其他事務干擾，也就是說在一個事務未完成之前，其他事務無法看到它的中間狀態。
> 多個事務並行執行時，隔離性確保最終的結果與事務順序執行的結果一致。即使有並發操作，也不會導致資料的不一致。
>
> ### 4. 持久性 `Durability`
>
> 一旦事務成功提交，對資料的修改將永久保存在資料庫中。即使系統發生故障也不會丟失。

## 資料不一致

> ### ↩️ 髒讀
>
> 定義：英文原名 `Dirty Read`，一個事務讀取了另一個事務尚未提交的資料。一旦回滾或者再次修改，就會查到錯誤的資料
>
> ### 🔄 變讀
> 定義：英文原名 `Non-repeatable Read` ，標準譯名叫做 **不可重複讀** ， 同一事務先後讀取同一資料時，因為另一個事件提交修改，資料的值不一致。
> ### ✨ 幻讀
>
> 定義：英文 `Phantom Read` ， 同一事務先後讀取同一資料集合時，因為另一個時間提交資料，資料的行數不一致。

## 事務隔離等級

###     

- `!` 表示有這個的風險， `×` 表示這個風險可以完全被規避
- 從上到下，隔離等級越來越高，更加能保證資料一致性，但是會更消耗資源

| 分類                        | 髒讀 | 變讀 | 幻讀 |
|:--------------------------|:--:|:--:|:--:|
| 讀未提交 `(Read Uncommitted)` | !  | !  | !  |
| 讀已提交 `(Read Committed)`   | ×  | !  | !  |
| 可重複讀 `(Repeatable Read)`  | ×  | ×  | !  |
| 串行化 `(Serializable)`	     | ×  | ×  | ×  |

# 鎖🔒

> ### 📖 定義
>
> 用于管理數據庫併發訪問的一種機制，通过控制多个事務同時操作的的先後順序，確保多個事務在併發執行時不會產生衝突

## 鎖模式

### 😀 樂觀鎖

>
> ### 📖 概念
> 樂觀鎖假設數據衝突較少，允許多個事務同時讀取數據，但在更新時檢查是否發生變更，若數據已被修改則取消操作。
>
> ### 🔑 特點
> - ✅ 提高系統的並發能力，避免鎖的開銷。
> - ✅ 不會影響其他事務的讀取操作，適合讀多寫少的場景。
> - ❌ 需要額外的版本管理機制，開發成本較高。
> - ❌ 若衝突頻繁，可能會導致大量事務失敗，影響用戶體驗。
>
> ### 🛠️ 場景
> - 讀取頻繁、寫入較少的場景（如社交媒體、商品瀏覽系統）。
> - 可以容忍一定程度的更新失敗（如用戶資料修改）。
>

### 🙁 悲觀鎖

>
> ### 📖 概念
> 悲觀鎖假設數據衝突會 **頻繁發生** ，因此在讀取或修改數據前，就先加鎖，防止其他事務對數據進行操作。
> 一旦某個事務獲取了悲觀鎖，其他事務必須等該鎖釋放後才能存取相同的數據。
>
> ### 🔑 特點
> - ✅ 避免了並發衝突的發生，確保數據一致性。
> - ❌ 會影響並發度，可能導致其他事務長時間等待，影響系統性能。
> - ❌ 需要較高的鎖管理成本，容易造成死鎖。
>
> ### 🛠️ 場景
> - 高並發環境，且競爭激烈的情境（如銀行轉帳、庫存管理）。
> - 數據極其重要，不能發生衝突的應用場景（如訂單系統、財務系統）。

## 鎖粒度

### 🌐 全局鎖

> 英文名 `Global Lock` ，對整個資料庫加锁，加鎖之後就處於只讀狀態，後續語句將會被阻塞
>
> ### 🛠️ 場景
> 數據庫備份，保證數據庫完整性
>
> ### 🖥️ 代碼
> ```sql
> --mySQL
> FLUSH TABLES WITH READ LOCK;  -- 開啟
> UNLOCK TABLES;                -- 關閉
> ```

### 2. 表級鎖

>
> ## 1 表鎖
>
>
> 讀鎖：
> 阻塞所有客戶端的數據修改，但允許所有客戶端讀數據
>
> 寫鎖：
> 只允許加鎖一段
>
>
> ## 2.2 元數據鎖（MetaData Lock,MDL）
>
>
> ## 2.3 自增锁

## 鎖範圍

> ## 1. 記錄鎖（Record）
>
>
>
>
>
>
>

## 死鎖

### 📖 定義

> 在資料庫系統中，一個以上的事務在執行的過程中。請求鎖定對方佔用的資源無果而互相等待的狀態。如果不干預，將會導致系統鎖死

### 🛠️ 條件

死鎖有四個必要條件，必須同時滿足，否則不會導致死鎖。

- ### 互斥條件

> 📖 確保資源是排他性使用的，即每個資源在任何時候只能被一個事務所占用。當某一事務占用某資源時，其他事務必須等待
>
> 💡 如果資源是共享的，那麼即使有事務在等待，不會有事務被完全阻塞，資源可以被多個事務並行使用，不會形成死鎖。

- ### 不可搶佔條件

> 📖 確保了事務所獲得的資源只能由該事務自行釋放，其他事務無法強制回收這些資源。
>
> 💡 如果系統允許資源被搶佔，那麼當有事務等待資源時，系統可以將其他事務的資源強制回收並分配給等待的事務，從而避免死鎖的發生。

- ### 請求與保持條件

> 📖 確保事務在持有至少一個資源的情況下，仍然可以請求其他資源，且不釋放已持有的資源。
>
> 💡 如果事務在請求新資源時，先釋放已擁有的資源，或事務只有在獲得所有所需資源後才開始執行操作，那麼事務不會進入阻塞狀態，也就不會發生死鎖。

- ### 循環等待條件

>
> 📖 存在一個事務等待鏈，如 `T1->T2->...->Tn->T1`有這樣一條資源等待循環閉環。這樣的循環等待關係會導致所有事務都處於等待狀態，無法繼續執行，最終形成死鎖。
>
> 💡 如果事務之間沒有形成循環等待關係，即使事務處於等待狀態，只要有其他事務能夠完成並釋放資源，資源會逐步被釋放並分配給其他事務，從而避免死鎖。

### 🔍 案例分析

- ### 加鎖順序

> ### 🛠️ 場景：併發互相轉賬
>
> ### 事務描述
> - 事務一：賬戶一給賬戶二轉錢
> - 事務二：賬戶二給賬戶一轉錢
>
> ### 過程
> - 事務一 ：賬戶1扣錢 → 賬戶1🔒
> - 事務二 ：賬戶2扣錢 → 賬戶2🔒
> - 事務一 ：賬戶2加錢 → 賬戶2⛔
> - 事務二 ：賬戶1加錢 → 賬戶1⛔
> - 死鎖：互相等待對方解除行鎖 ❌
>
> ### 關鍵點
>
> 按照一定不同的順序佔用都需要的資源

- ### 間隙鎖

> ### 🛠️ 場景：併發插入相同索引
>
> ### 事務描述
> - 事務一、二、三：插入索引互相相同的數據
>
> ### 過程
> - 事務一：插入數據，成功，加行鎖🔒
> - 事務二、三：插入數據，被行鎖阻塞⛔，加間隙鎖🔒
> - 事務一：事務完成，行鎖解除✅
> - 事務二、三：阻塞「結束」，準備關閉間隙鎖✅加行鎖🔒
> - 死鎖：互相等待對方解除間隙鎖❌
>
>

# 數據庫平臺原理

# 運維



