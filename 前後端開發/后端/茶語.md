# 對茶語的理解 ☕


1. （語言層面） JAVA 是**面向對象**的強類型語言，三大特徵封裝、繼承、多態，提供了垃圾回收機制，不用手動釋放內存
2. （平臺特性） JAVA 依靠`JVM`實現**一次編寫，到處運行**，擁有豐富的標準庫和完善的多線程和併發支持
3. （應用特性） JAVA 有成熟的生態和框架，適合企業級引用，是後端開發廣泛流行的原因

## JAVA和GO的區別
語言定位：

Java 側重於 面向對象，生態龐大，跨平台能力強。

Go 側重於 並發、高效、簡潔，常用於雲原生、基礎設施。

性能與併發：

Java 基於 JVM，GC 機制成熟，性能不錯，但併發主要靠多線程，重量級。

Go 編譯為原生二進制，Goroutine + Channel 提供輕量併發，併發模型更簡單。

開發效率：

Java 生態完整（Spring、Hadoop…），但語法偏冗長，上手成本較高。

Go 語法簡潔，標準庫完善，快速上手，適合中小團隊高效交付。

典型應用場景：

Java：企業級應用、金融系統、大型分布式平台。

Go：雲原生（Docker、K8s）、微服務、網路服務。

👉 精煉收尾句：
「簡單來說，Java 更適合複雜業務系統，Go 更適合高併發、基礎設施和雲原生場景。」

# 併發隊列

## 有界阻塞隊列 · 數組 (ArrayBlockingQueue)

### 定義

- 實現：數組
- 鎖：添加和刪除使用同一把鎖

```java
public static void main(String[] args)
{
    BlockingQueue<String> queue = new ArrayBlockingQueue<>(5);//容量为5的有界队列
    Random rand = new Random();

    Thread producer = new Thread(() ->
    {
        int count = 0;
        try
        {
            while (true)
            {
                queue.put(++count);  // 阻塞式插入
                print(queue.size()); // 實現的可視化的大小
                Thread.sleep(rand.nextInt(200));
            }
        } catch (InterruptedException e)
        {
            Thread.currentThread().interrupt();
        }
    });
    Thread consumer = new Thread(() ->
    {
        try
        {
            while (true)
            {
                String item = queue.take(); // 阻塞式取出
                print(queue.size());
                Thread.sleep(rand.nextInt(200));
            }
        } catch (InterruptedException e)
        {
            Thread.currentThread().interrupt();
        }
    });
    producer.start();
    consumer.start();
}
```
> ## 執行結果
> 在執行緒中，生產者消費者互相運行，從概率上看相等，有如下三個穩定狀態互相轉換
> ### 1. 大部分空的時候
> 
> ```
> 1 0 1 0 1 0 1 0 1 0...
> ```
> - 在運行的時候消費者隨機出的時間較短，隊列幾乎為空，衹要生產一個，就消費掉。
> - 隊列的作用在於在 **隊列為空** 的時候阻塞 **消費者** 執行緒
> 
> ### 2. 大部分滿的時候
> 
> ```
> 4 5 4 5 4 5 4 5 4 5...
> ```
> - 在運行的時候生產者隨機出的時間較短，隊列幾乎為滿，衹要消費一個，就生產出來
> - 隊列的作用在於在 **隊列為滿** 的時候阻塞 **生產者** 執行緒
> - 
> ### 3. 中間狀態
> 
> ```
> 2 3 4 3 4 3 2 3 2 1...
> ```
> - 生產者和消費者的序列保持平衡
> - 隊列並沒有阻塞什麼





## 有界阻塞隊列 · 鏈表 (LinkedBlockingQueue)

### 定義
- 實現：鏈表
- 鎖：添加和刪除使用獨立的鎖

### 特點

- 不設置大小的時候是`Integer.MAX_VALUE`幾乎等於無窮





## 同步握手隊列 (SynchronousQueue)

```java
public static void main(String[] args)
{
    SynchronousQueue<String> queue = new SynchronousQueue<>();
    Random rand = new Random();
    Thread producer = new Thread(() ->
    {
        int count = 0;
        try
        {
            while (true)
            {
                String data = String.valueOf(++count);
                System.out.println("+ ");
                queue.put(data);  // 阻塞式插入
                System.out.println("放入" + data);
                System.out.println("放入大小："+queue.size());
                Thread.sleep(rand.nextInt(300)); // 模擬隨機生產速度
            }
        } catch (InterruptedException e)
        {
            Thread.currentThread().interrupt();
        }
    });
    Thread consumer = new Thread(() ->
    {
        try
        {
            while (true)
            {
                System.out.println("- ");
                String item = queue.take();  // 阻塞式取出
                System.out.println("取出" + item+" ");
                System.out.println("取出大小："+queue.size());
                Thread.sleep(rand.nextInt(300)); // 模擬隨機消費速度
            }
        } catch (InterruptedException e)
        {
            Thread.currentThread().interrupt();
        }
    });
    producer.start();
    consumer.start();
}
```



## 無鎖隊列

### 優勢
在多線程併發中，如果使用傳統阻塞隊列內部需要锁來保護併發訪問
問題
- 多線程搶鎖，上下文切換，開銷大
- 所釋放還會帶來內存屏障


### 普通隊列
> 
> 理論是`2000`，但是因為插入函數不是原子性的，導致每一個結果都不一樣且大概率小於`2000`
> 1. 節點覆蓋
> 2. 指標丟失
> 

```java
public static void main(String[] args) throws InterruptedException
{
    Queue<Integer> queue = new LinkedList<>();
    // 兩個線程同時向隊列添加元素（非線程安全）
    Runnable producer = () ->
    {
        for (int i = 0; i < 1000; i++) queue.offer(i);
    };
    Thread t1 = new Thread(producer);
    Thread t2 = new Thread(producer);
    t1.start();
    t2.start();
    t1.join();
    t2.join();
    System.out.println("隊列大小: " + queue.size()); // 理論應該是 2000，但結果會小於且不穩定
}
```









# 鎖

ReentrantLock 



<br><br><br><br><br>

# 罯屑回收 ♻️ Garbage Colletcion

## 📖 定義

垃圾回收是茶語虛擬機**自動管理內存的機制**，負責回收程序中不在使用的對象锁佔用的內存，這些不在使用的對象就是「垃圾」


## 需要回收

1. 虛擬機堆疊或本地函數棧

## 檢測方法

### 1️⃣ 引用計數法

> ### 💡 核心思想
> 一個對象被引用的次數決定了他是否存活
> 
> ### 🔍 原理
> 1. 每一個對象都關聯一個引用計數器`i=1`
> 2. 當有一個新的引用對象只想對象的時候，`i++`
> 3. 當引用失效的時候（超過範圍，設置為空）`i--`
> 4. 如果一個對象的引用計數器為0，意味著不在需要，可以立刻回收
> 
> ### ✅ 優點
> 1. 判斷流程非常簡單
> 2. 判別不需要暫停程序來遍歷
> 
> ### ❌缺點
> 
> **循環引用，兩個以上對象互相引用，形成一個環，及時已經沒有，但是互相引用導致計數器不為0，導致內存洩漏**
> 

### 2️⃣ 可達性分析


> ### 💡 核心思想
> 一個對象被引用的次數決定了他是否存活
>
> 
> ### 🔍 原理
> 
>
> ### ✅ 優點
> 
> 
> ### ❌缺點
>
> 
> 
>

### 2️⃣➕ 罯屑回收根節點 GC Roots

> ### 📖 定義
> 可達性就是一種搜索，搜索的起點就是這批根節點，它們是一組必須存活的絕對可靠的引用
> 1. 目前在使用的
> 2. 生命週期很長的
>
> ### 選取
> 1. 虛擬機棧或者本地方法棧引用的對象 <p>這一類正在執行，肯定是在被使用的，他們引用的對象不可以回收，所以為根，方法結束之後不再為根</p>
> 2. 靜態成員引用的對象：`private static Object staticObject = new Object();`<p>靜態變量屬於類，而類的生命週期很長</p>
> 3. 常量引用的對象：`private static final String CONSTANT_STRING = "I am a constant";`<p>和靜態變量類似，生命週期很長</p>
>
>

## 回收時間

###

## 回收過程





<br><br><br><br>

# 散列表 🍂 HashMap & HashSet

## 特點
線程不安全

## 🏗️ 結構

桶的數組下掛的要麼是鏈表，要麼是紅黑樹
```
□□□□□□□□□□□□□□□□□□
  ↓    ↓    ↓ 
  □   null   □
  □        ↙  ↘
  □       □    □
  □      ↙↘   ↙↘
 null   □  □  □  □
```
JDK8開始使用紅黑樹：在之前版本里使用數組加鏈表，但數據不均勻的時候會導致長度過長

## 流程

### 查詢：`get()`
> ### 1. 計算雜湊值
> 
> ```javascript
> h = (key == null) ? 0 : key.hashCode();
> h = h^(h>>>16)//高位低位混合運算提高隨機性
> ```
> 
> ### 2. 獲得下標
> 在大小為`2^n` 的時候
> - 計算桶的時候的`hash & (length-1)` 是和 `hash % length`等價的，位運算比求餘數效率更高。
> - 此時`length-1`就全為1，和他做按位與就是取低位，如果不是全1，在0的那些位置上按位與無法區分開
> 
> ### 3. 依次判斷 首節點 和 頷節點
> - 首節點為null，則找不到
> - 首節點匹配，則返回
> - 首節點不匹配，同樣的方法判斷下一個節點
> 
> ### 4. 仍然不匹配，則判斷節點類型
> - 如果是紅黑樹，使用O(log2)查找
> - 如果是鏈表，使用O(n) 查找



### 添加：`put()`
> ### 1. 初始化擴容
> - `capacity` 容量：數組長度，默認`16`
> - `loadFactor` 負載因子：默認`0.75`
> - `threshold` 閾值：`閾值=容量*加載因子`，默認`12`
> 
> ### 2. 計算雜湊值，獲得下標
> 同上
> 
> ### 3. 判斷首節點
> - 首節點為null，直接插入
> - 首節點鍵相同，直接覆蓋
> - 首節點不相同，判斷節點類型，插入鏈表或者樹中
> 
> ### 4. 整理
> - 鏈表長度≥8，則轉化為紅黑樹
> - 鍵值對數量大於閾值則擴容


# 緩存異常

## 🗡️ 緩存穿透

### 定義

花期過濾器

## ❄️ 緩存雪崩

## 

----
# 內存異常

## 💥 記憶體溢出


## 記憶體洩露
### 定義
> 在申請的時候，沒有足夠空間使用，`out of memory`

### 場景和解決






內存洩露：動態分配之後沒有正確釋放不在使用的內容，導致無法被使用。長期會導致內存耗盡

## 典型場景


# 死鎖



