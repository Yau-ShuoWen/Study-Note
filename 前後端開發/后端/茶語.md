# 併發隊列

## 有界阻塞隊列

`ArrayBlockingQueue`
固定容量

```java
public static void main(String[] args)
{
    BlockingQueue<String> queue = new ArrayBlockingQueue<>(5);//容量为5的有界队列
    Random rand = new Random();

    Thread producer = new Thread(() ->
    {
        int count = 0;
        try
        {
            while (true)
            {
                queue.put(++count);  // 阻塞式插入
                print(queue.size()); // 實現的可視化的大小
                Thread.sleep(rand.nextInt(200));
            }
        } catch (InterruptedException e)
        {
            Thread.currentThread().interrupt();
        }
    });
    Thread consumer = new Thread(() ->
    {
        try
        {
            while (true)
            {
                String item = queue.take(); // 阻塞式取出
                print(queue.size());
                Thread.sleep(rand.nextInt(200));
            }
        } catch (InterruptedException e)
        {
            Thread.currentThread().interrupt();
        }
    });
    producer.start();
    consumer.start();
}
```
> ## 執行結果
> 在執行緒中，生產者消費者互相運行，從概率上看相等，有如下三個穩定狀態互相轉換
> ### 1. 大部分空的時候
> 
> ```
> 1 0 1 0 1 0 1 0 1 0...
> ```
> - 在運行的時候消費者隨機出的時間較短，隊列幾乎為空，衹要生產一個，就消費掉。
> - 隊列的作用在於在 **隊列為空** 的時候阻塞 **消費者** 執行緒
> 
> ### 2. 大部分滿的時候
> 
> ```
> 4 5 4 5 4 5 4 5 4 5...
> ```
> - 在運行的時候生產者隨機出的時間較短，隊列幾乎為滿，衹要消費一個，就生產出來
> - 隊列的作用在於在 **隊列為滿** 的時候阻塞 **生產者** 執行緒
> - 
> ### 3. 中間狀態
> 
> ```
> 2 3 4 3 4 3 2 3 2 1...
> ```
> - 生產者和消費者的序列保持平衡
> - 隊列並沒有阻塞什麼

### 補充說明

```java
public static void main(String[] args)
{
    SynchronousQueue<String> queue = new SynchronousQueue<>();
    Random rand = new Random();
    Thread producer = new Thread(() ->
    {
        int count = 0;
        try
        {
            while (true)
            {
                String data = String.valueOf(++count);
                System.out.println("+ ");
                queue.put(data);  // 阻塞式插入
                System.out.println("放入" + data);
                System.out.println("放入大小："+queue.size());
                Thread.sleep(rand.nextInt(300)); // 模擬隨機生產速度
            }
        } catch (InterruptedException e)
        {
            Thread.currentThread().interrupt();
        }
    });
    Thread consumer = new Thread(() ->
    {
        try
        {
            while (true)
            {
                System.out.println("- ");
                String item = queue.take();  // 阻塞式取出
                System.out.println("取出" + item+" ");
                System.out.println("取出大小："+queue.size());
                Thread.sleep(rand.nextInt(300)); // 模擬隨機消費速度
            }
        } catch (InterruptedException e)
        {
            Thread.currentThread().interrupt();
        }
    });
    producer.start();
    consumer.start();
}
```

## 無鎖隊列


### 普通隊列
> 
> 理論是`2000`，但是因為插入函數不是原子性的，導致每一個結果都不一樣且大概率小於`2000`
> 1. 節點覆蓋
> 2. 指標丟失
> 

```java
public static void main(String[] args) throws InterruptedException
{
    Queue<Integer> queue = new LinkedList<>();
    // 兩個線程同時向隊列添加元素（非線程安全）
    Runnable producer = () ->
    {
        for (int i = 0; i < 1000; i++) queue.offer(i);
    };
    Thread t1 = new Thread(producer);
    Thread t2 = new Thread(producer);
    t1.start();
    t2.start();
    t1.join();
    t2.join();
    System.out.println("隊列大小: " + queue.size()); // 理論應該是 2000，但結果會小於且不穩定
}
```



# 悪屑回收

## 可以最為回收的物件

1. 虛擬機堆疊或本地函數棧



----


# 散列表底層原理

## 特點


## 形狀

桶的數組下掛的要麼是鏈表，要麼是紅黑樹
```
□□□□□□□□□□□□□□□□□□
  ↓    ↓    ↓ 
  □   null   □
  □        ↙  ↘
  □       □    □
  □      ↙↘   ↙↘
 null   □  □  □  □
```

### 查詢流程：`get()`
> ### 1. 計算雜湊值
> 
> ```javascript
> key == null ? 0 : h=key.hashCode();
> ```
> 
> ### 2. 獲得下標
> 在大小為`2^n` 的時候
> - 計算桶的時候的`hash & (length-1)` 是和 `hash % length`等價的，位運算比求餘數效率更高。
> - 此時`length-1`就全為1，和他做按位與就是取低位，如果不是全1，在0的那些位置上按位與無法區分開
> 
> ### 3. 依次判斷首節點和頷和節點
> - 如果首節點為null，則找不到
> - 如果首節點匹配，則返回
> - 如果首節點不匹配，同樣的方法判斷下一個節點
> 
> ### 4. 仍然不匹配，則判斷節點類型
> - 如果是紅黑樹，使用O(log2)查找
> - 如果是鏈表，使用O(n) 查找



### 添加流程：`set()`
> ### 1. 擴容
1. 數組為空第一次擴容
2. 計算雜湊值，獲得下標





## 擴容相關

> ### 參數
> - `capacity` 容量：數組長度，默認`16`
> - `loadFactor` 負載因子：默認`0.75`
> - `threshold` 閾值：`閾值=容量*加載因子`，默認`12`

### 兩倍擴容



