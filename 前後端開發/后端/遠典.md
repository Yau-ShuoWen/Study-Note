# 📢 介紹 Redis

## ⚖️ 對比

| 對比   | Redis | Memcache |
|------|-------|----------|
| 資料類型 | 支持五種  | 只支持字符串   |
| 持久化  | 支持兩種  | 不支持      |
| 可用性  | 原生支持  | 要使用客戶端   |
| 線程   | 單線程   | 多線程      |

## 🚀 速度快

原因

1. Redis是一個鍵值對內存資料庫
2. 使用IO多路複用技術
3. 非CPU密集型任務，對大key進行非常數時間複雜度的操作會阻塞的後續請求，快的前提是不會出現類似情況
4. 單線程的優勢：避免多線程上下文切換以及共享資源加鎖的性能消耗

## 適用場景

1. 分佈式緩存
2. 分佈式鎖
3. 計數器
4. 排行榜
5. 附近的人
6. 共同好友
7. 會話管理

# 🖥️ 基本語法

## 一、字串

### 基本操作

> ### 🖥️ 指令
>
>
> | 操作類型 | 指令                        | 說明         |
> |------|---------------------------|------------|
> | 設定   | `SET 鍵 值`                 | 設定單個       |
> | 批量設定 | `MSET 鍵1 值1 鍵2 值2 ...`    | 同時設定多個     |
> | 取得   | `GET 鍵`                   | 取得指定       |
> | 批量取得 | `MGET 鍵1 鍵2 ...`          | 同時取得       |
> | 刪除   | `DEL 鍵` 或 `DEL 鍵1 鍵2 ...` | 刪除指定、可一次多個 |
> | 不覆蓋  | `SETNX 鍵 值`               | 只有鍵不存在時才設定 |
> | 批量勿覆 | `MSETNX 鍵1 值1 鍵2 值2 ...`  | 不覆蓋已存在鍵    |
> | 限時鍵  | `SETEX 鍵 失效秒數 值`          | 秒數         |
> | 限時鍵  | `PSETEX 鍵 失效毫秒數 值`        | 毫秒數        |
> ### ⚠️ 注意
> 1. 這裡的字符串可以不用加引號，如果裡面有特殊符號（如空格）則必須使用引號
> 2. 這個語言的字符串大小寫敏感，雖然指令大小寫均可，但是鍵值對敏感，
>

### 字串

> ### 📖 字串索引
> - 當i>=0，為正向索引，同其他語言，从零開始
> - 當i<0，為反向索引，同JS，最後一位-1，以此類推
>
>
> ### 🖥️ 指令
>
>
> | 操作     | 指令                     | 說明        |
> |--------|------------------------|-----------|
> | 附加字串   | `APPEND 鍵 值`           | `+=`      |
> | 取得字串長度 | `STRLEN 鍵`             | `.size()` |
> | 截取字串   | `GETRANGE 鍵 開始索引 結束索引` | 包括兩端的字符   |
> | 覆蓋字串   | `SETRANGE 鍵 開始索引 值`    | 覆蓋或擴展字串   |

### 數字

> ### 📖 數字範圍
> - 整數範圍  `[ -2^63 , 2^63-1 ]`
> - 浮點數範圍`[±5e-324,±1.8e308]`
>
> ### 🖥️ 指令
> | 操作    | 指令                  | 說明   |
> |-------|---------------------|------|
> | 自增    | `INCR 鍵`            | `++` |
> | 指定增量  | `INCRBY 鍵 增量`       | `+=` |
> | 自減    | `DECR 鍵`            | `--` |
> | 指定減量  | `DECRBY 鍵 減量`       | `-=` |
> | 浮點數自增 | `INCRBYFLOAT 鍵 浮點數` | `+=` |
>
> ### ⚠️ 注意
> 1. 嘗試超過範圍，要麼溢出，要麼報錯無法運行
> 2. 如果嘗試對一個非數字字串操作則報錯
> 3. 如果是整數，則可以調用上面所有指令，如果已經儲存為浮點數，衹能調用最後一條
> 4. 支持增量和減量為負數，就是簡單的加減互換，所以其實浮點數一個指令也夠用

## 二、列表

類似於雙端列表和

### 鏈表操作

>
> ### 🖥️ 指令
>
>
>

- 端點

1. 左入 `LPUSH 鍵 值`
2. 右入 `RPUSH 鍵 值`
3. 左出 `LPOP 鍵`
4. 右出 `RPOP 鍵`
5. 長度 `LLEN 鍵`

- 區間

1. 取區間 `LRANGE 鍵 左索引 右索引`
2. 留區間 `LTRIM 鍵 左索引 右索引`

- 數組

1. 刪除指定元素 `LREM 鍵 數量 值`
2. 返回指定元素 `LINDEX 鍵 索引`
3. 修改指定元素 `LSET 鍵 索引 值`
4.

## 三、集合

基本操作

| 操作     | 指令                   | 說明       |
|--------|----------------------|----------|
| 添加     | `SADD 名 值1 值2...`    | 可以一次添加多個 |
| 刪除     | `SREM 名 值`           |          |
| 個數     | `SCARD 名`            |          |
| 檢查存在   | `SISMEMBER 名 值`      | 返回0 1    |
| 返回所有   | `SMEMBERS 名`         |          |
| 隨機獲取   | `SRANDMEMBER 名 [數量]` | 數量不寫為1   |
| 隨機獲取刪除 | `SPOP  名`            |          |

關係運算

| 操作 | 指令                | 說明  |
|----|-------------------|-----|
| 交集 | `SINTER 名1 名2...` | A∩B |
| 並集 | `SUNION 名1 名2...` | A∪B |
| 差集 | `SDIFF 名1 名2...`  | A-B |

## 四、有序集合

<br><br><br><br>

# 🗃️ 資料結構

## 整數集合`IntSet`

### 適用情況

- ✅ 極高的內存效率和訪問速度
- 集合中所有元素都是整數值
- 集合中的元素不超過配置的閾值（默認512，用`set-max-intset-entries`設置）
- ❌ 如果任意條件不滿足，就會轉化為普通散列表

### 對比

| 操作   | 整數集合           | 散列表          |
|------|----------------|--------------|
| 內存佔用 | ✅ 極低：額外祇有兩個整數  | ❌ 高：額外指針和桶   |
| 檢查存在 | ✅ 很快：充分利用緩存    | ❌ 快：相對普通查找而言 |
| 增加刪除 | ❌ 中等：升級和頭部操作不好 | ✅  快         | 
| 順序迭代 | ✅ 極快：順序掃描      | ❌ 中等：遍歷桶     |

| 消耗資源 | 整數集合         | 散列表          |
|------|--------------|--------------|
| 使用場景 | 查詢多、數量少、都是整數 | 一般情況下的方案     |
| 優化策略 | 小用例下的常數因子優化  | 一般情況下的方案     |
| 內存訪問 | ✅ 順序訪問       | ❌ 隨機訪問       |
| 具體計算 | ✅ 整數比較和內存賦值  | ❌ 雜湊值計算，衝突解決 |
| 內存分配 | ✅ 單次、連續分配    | ❌ 多次分配：節點、表  |
| 指令數量 | ✅ 少          | ❌ 多          |

### 代碼

```c
typedef struct intset 
{
    uint32_t encoding;  // 编码方式
    uint32_t length;    // 集合包含的元素数量
    int8_t contents[];  // 保存元素的柔性数组
} intset
```

1. `encoding`決定了數組中元素的類型
    - `INTSET_ENC_INT16` 是 `int16_t`，佔用2字節
    - `INTSET_ENC_INT32` 是 `int32_t`，佔用4字節
    - `INTSET_ENC_INT64` 是 `int64_t`，佔用8字節
2. `length` 長度
3. `contents[]`有序的、伸縮的數組，按照升序排列

### 操作

> #### 查找
>
> 因為數組是有序的，所以只用二分查找就可以，**對數複雜度**
>
> #### 添加
>
> - 如果超過編碼範圍，就升級
> - 查找插入位置，然後移動後面的元素，插入新的元素，**線性複雜度**
>
> #### 刪除
>
> - 查找刪除位置，然後抵用後面的元素，覆蓋掉當前元素，**線性複雜度**
>
> #### 🌟 升級
>
> 1. 根據新的元素類型和當前長度，計算擴容之後的內存大小
> 2. 從尾部開始（防止錯誤覆蓋），類型轉換並且放進新的位置
> 3. 完成之前的插入操作
> 4. 更新`encoding`
> 5. 在範圍重新縮小之後不會降級

<br><br><br><br>

## 跳表

請輸入文本

# 🕑 數據長期管理

## 一、🕑 數據持久化

### 原因

Redis是內存資料庫，服務器崩潰會導致資料丟失

### ⚖️ 對比

| 對比條件 | RDB                | AOF                       |
|------|--------------------|---------------------------|
| 數據格式 | 二進制壓縮格式            | Redis命令                   |
| 流程本質 | 💾 物理數據的備份         | 🔄 過程的重建                  |
| 磁盤讀寫 | ✅ 開銷小              | ❌ 磁盤輸入輸出開銷大               |
| 恢復速度 | ✅ 恢復速度快，直接讀入内存     | ❌ 數據恢復相對較慢，相當于重建          |
| 數據同步 | ❌ 快照文件生成間隔長        | ✅ 同步實時                    |
| 數據丟失 | ❌ 丟失最後一次快照後的所有修改   | ✅ 數據丟失少，設置每秒同步之後，甚至只丟失一秒鐘 |
| 文件損壞 | ❌ 生成過程或者本身損壞都無效    | ✅ 尾部損壞還可以恢復前面的            |
| 可讀性  | ❌ 二進制文件，不可閱讀       | ✅ 可以使用工具查看，甚至可以閱讀         |
| 版本兼容 | ❌ 存在舊版本無法兼容新版RDB格式 | ✅ 兼容性好                    |

### 💾 RDB 持久化

> #### 🏷️ 名稱
>
> - 英文原名：`Redis Database`
> - 中文譯名：快照持久化
>
> #### 🔍 原理
>
> - 將`Redis`內存快照保存到硬盤上，可以通過`RDB`文件還原資料庫當時的狀態。
> - `SAVE`方式：阻塞`Redis`服務進程，直至生成`RDB`文件
> - `BGSAVE`方式：復刻一個子進程創建`RDB`文件

### 🔄 AOF 持久化

> #### 🏷️ 名稱
>
> - 英文原名：`Append-Only File`
> - 中文譯名：追加日誌持久化
>
> #### ➡️ 流程
>
> 1. 命令追加：寫命令追加到緩衝區
> 2. 文件持久化：緩衝區根據對應的策略寫入文件
> 3. 重寫：隨著命令持續寫入，文件越來越大，重寫文件壓縮
> 4. 數據恢復：當數據庫重啟的時候加載文件恢復
>
> #### 🗂️ 重寫
>
>  原理：从数据库中讀取鍵并用一條命令記錄鍵值對，代替多條命令
>

<br><br>

## 二、♻️ 過期刪除

### 🕑 定時刪除 / 立即刪除

> #### 🔍 原理
>
> 在設置過期時間的同時，創建一個定時器，當倒計時結束的時候，立刻刪除
>
> #### ⚖️ 特點和應用
>
> - ✅ 內存管理最優，可以立即釋放過期鍵的內存，沒有任何延遲，對內存最友好
> - ❌ 如果有大量會過期的鍵，管理定時器創建銷毀會消耗處理器時間
> - ❌ 過期的時候，刪除可能密集發生，對處理器造成壓力
> - ❌ 定時器的管理也需要開銷，如內存和數據結構（時間輪）
> - ❌ 服務器負載高，定時器可能無法準時出發，導致刪除有延遲，違背立即刪除
> - 📅 因為缺點太明顯，所以**基本不會使用**。

### 😴 惰性刪除

> #### 🔍 原理
>
> 只用嘗試訪問的時候，才會檢查是否過期，如果過期會刪除，返回nil
>
> #### ⚖️ 特點和應用
>
> - ✅ 對處理器友好，操作只會在訪問時發生，不會消耗性能掃描其他鍵
> - ❌ 對內存不友好，如果已經過期，但是永遠沒有訪問了，那麼無法被釋放，相當於**內存洩漏**
> - 📅 需要「定期刪除」做補充

### ⏳ 定期刪除

> #### 🔍 原理
>
> 1. 週期性（默認100ms/次）的隨機抽取部分設置了過期的鍵，檢查是否過期，並刪除過期的
> 2. 如果在抽查的時候，過期數量比例過大（默認25%），那麼說明過期的很多，立即重複抽取，直到比例低於閾值
>
> #### ⚖️ 特點和應用
>
> - ✅ 通過主動清理，可以釋放無人訪問的過期內容，補足惰性刪除的不足
> - ❌ 抽查的太頻繁或者太多，會佔用處理器性能，但是可以配置
> - 📅 和「惰性刪除」一起使用，是主流的結果

## 三、💼 事務

### 🖥️ 語法

1. 事務開啟：`MULTI`
2. 命令入隊：不會被立即執行，而是被放在事務隊列中
3. 提交或放棄：`EXEC`會被執行，`DISCARD`命令將事務丟棄。

### 事務的屬性（ACID）

- 基本保證：當提交事務之後，所有命令會按照**順序**、**一次性**、**持續**地執行完畢

> #### 原子性 🤔
>
> 衹保證命令的不可拆分，不保證命令執行失敗後回滾
> - 命令語法錯誤**✅符合原子性**：入隊的時候如果有語法錯誤，所有事務都不執行。
> - 運行時錯誤**❌不符合原子性**：提交之後，某一條命令執行失敗，不會回滾，仍然運行其他數據。
> 
> #### 一致性 🛑
> 
> - 無關：因為本身沒有複雜的數據約束（如外鍵）
> 
> #### 隔離性 ⭐️
> 
> - 完美隔離：具有最高的隔離等級「串行化」（TW：可序列化）
> - 實現機制：因為是單線程的（TW：單執行緒），所以所有命令連續執行，不會被任何客戶端命令打斷
> 
> #### 持久性 🛑
> 
> - 無關：取決於數據持久化的方案，和數據庫本身無關，如果不做持久化，不能保證長期存在。

### 🔒 鎖

- 缺陷：在開始事務的時候不會阻塞事務，所以在**寫入命令隊列**的時候，別的客戶端的修改是無法阻止的。
- 樂觀鎖：`WATCH`命令，可以監控任意个鍵，如果在提交之前，有任何其他客戶端修改了對應的，整個事務就會被放棄，返回nil

<br><br><br><br>

# 🔗 數據庫集群

## 一、💬 『流言』協議

英文原名：Redis Gossip

### 核心命令

> ### 乒 `PING`
>
> 目的：檢測和信息交換
>
> 1. 每一個節點隨機嚮節點發送「乒」消息
> 2. 消息體中包含了該節點視角下的集群元數據
>
> ### 乓 `PONG`
>
> 目的：對「乒」的響應，或者主動廣播信息
>
> - 作為對「乒」的標準回復，也攜帶自身的集群元數據
> - 當節點需要主動提醒所有節點重要事件（晉升），會主動廣播信息
>
> ### 覓 `MEET`
>
> 目的：邀請一個節點加入集群
>
> 1. 客戶端會指示集群某個節點嚮新節點發送「覓」消息
> 2. 新節點在收到消息之後會把發送方加入節點列表，並且開始和其他節點通信
>
> ### 廢 `FAIL`
>
> 目的：廣播某個節點確定下線
>
> 1. 當一個節點多次乒另一個節點超時，會標記為 `PEAIL`
> 2. 節點通過協議發現大多數主節點也都認為那個節點處於 `PEAIL`，那麼會講他的狀態升級為`FAIL`
> 3. 這時候，該節點會向所有節點廣播 `PEAIL` 信息
> 4. 如果某一個主節點被確認下線，從節點會開始選新的主節點

## 二、 🪣 ㄏㄕ槽

### 🏷️ 定義

可以理解為數據分區，講這個數據集動態映射到`16384(2^14)`個桶里

- 集群中的每一個節點負責一部分槽
- 集群中所有槽都要被分配
- 計算鍵的`CRC16`值，對16384取餘數，來決定屬於哪一個槽，從而決定存在哪一個

### 設計

## 三、🔄 重定向

當請求的內容不屬於

### MOVED

### ASK

## 四、🧠 集群腦裂

### 🏷️ 定義

- 英語：Split-Brain
- 在集群模式下，由於網絡分區或節點故障導致集群中的一部分節點失去與其他節點的連接，從而出現多個孤立的子集群，每一個子集群有主節點，且各自認為自己是獨立的主集群，每一個子集群都對客戶端提供寫入服務。

### 🚨 危害

- **數據不一致**:不同的子集群可能對相同的鍵進行不同的寫操作
- **數據丟失**:新選出來的主節點會像所有從節點通知，所有子節點會全量同步，如果正在做主從同步，在恢復之後被降級并「被要求」重新同步，那麼原主庫的命令可能會被清空，導致數據丟失
- **服務中斷**：在腦裂發生的時候，為了盡力維護數據一致性和防止數據丟失，系統會限制從庫寫

<br><br><br><br>

# 📈 特殊數據

## 🔥 熱點鍵值對

### 🏷️ 定義

單個鍵值對訪問數量太高（一般是大於千次每秒），而且對服務產生不利影響，就可以被視為熱點

### 🚨 危害

- **訪問傾斜**：熱點可能會導致某個數據分片被大量訪問，其他處於空閒，分片失去意義。
- **緩存擊穿**：當請求壓力超過承受能力的時候，在緩存過期的時候容易擊穿，大量請求直接發送到數據庫，導致數據庫崩潰
- **讀寫瓶頸**：當某一個熱點在請求某一個節點的主機超過流量上線，會導致其他服務無法正常進行。

### 📹 監控和發現

- 根據業務場景和規劃，可以預測，比如搶購商品的信息一般就是熱點鍵值對
- 業務層可以進行數據統計和異步上報
- 利用自帶的工具

### 🪛 解决方法

- **使用本地缓存**：發現熱點之後，可以加載到系統的本地緩存中，不會再直接請求
- **將熱點拆分**：可以將熱點緩存到不同的節點上，這樣不會請求到同一個鍵值對
- **一致性問題**：如果會更新並且要求強一致，必須考慮一致性

## 🏔️ 大鍵值對

### 🏷️ 定義

單個鍵值對訪問數量太高（一般是大於千次每秒），而且對服務產生不利影響，就可以被視為熱點

### 🪛 解决方法

- **拆分**：對於大列表或者散列表，可以拆分多個小的，使用散列表存儲
- **壓縮數據**： 如果值是可以壓縮字符串類型，那麼可以使用壓縮算法（LZF、Snappy）；或者先壓縮存儲，再讀取后解壓縮
- **設置過期**： 對於臨時或緩存數據，可以設置過期時間，避免長期佔用內存

<br><br><br><br>

# 目錄

1. Redis的5种基本数据类型及对应底层实现
2. ~~Redis为什么这么快~~
3. ~~Redis持久化之RDB与AOF~~
4. Redis实现分布式锁的关键点
5. Redis与Memcache的区别
6. Redis主从复制原理之SYNC与PSYNC
7. ~~过期删除策略~~
8. Redis哈希槽
9. Redis Gossip协议
10. 重定向moved与ask
11. Pipeline有什么好处
12. Redis大Key的识别与解决
13. ~~Redis热点Key的危害与解决~~
14. ~~Redis事务~~
15. LUA脚本能保证原子性吗
16. Redis脑裂
17. Redis适用场景
18. Redis重定向Moved&Ask
19. ~~Redis 底层实现整数集合~~