1 2 3 4  5
6 7 8 9 10
11 12 13 14 15
16 17 18 19 20
21 22 23 24 25



平均时间复杂度
好：
快速：nlogn（递归深度logn，每一层n）
归并：nlogn（递归深度logn，每一层n）
堆：nlogn（构建堆n，每去取出一个并重新排序logn，共有n个元素）

中：
计数：n+k（k是数据范围，其中表达式虽不随着数据而变化，但结果会改变）
基数：n*k （k是数据位数，其中表达式虽不随着数据而变化，但结果会改变）
桶：nlog(n/k)  （k是桶的数量）

坏：
冒泡：n2
插入：n2（平均n2/2次比较和移动）
选择：n2（无论什么情况）


最优时间复杂度
好：
冒泡：n （在有序的情况下，没有发生交换会提前结束）
插入：n  （在有序的情况下，不怎么需要插入）
计数：n+k （当k较小的时候复杂度趋向于n）
基数：n*k （当k较小的时候复杂度趋向于n）
桶    n   （数据分布均匀，k接近于n，趋向于n）

中：
快速：nlogn（平均即最优）
归并：nlogn（平均即最优）
堆：nlogn（平均即最优）

坏：
选择排序：n2（无论是否有序，算法都会完整扫描）


最差时间复杂度

好：
归并：nlogn（完全不会收到输入数据的影响）
堆：nlogn（完全不会收到输入数据的影响）

坏：
冒泡：n2 （完全逆序）
插入：n2 （完全逆序）
选择：n2 （无论什么情况）
快速：n2 （每次都基准元素都是数组的的最值，导致分区效果不明显，要分n个而不是logn次）
计数：n+k （当k较大的时候，复杂度趋向于k）
基数：n*k （当k较大的时候，复杂度趋向于n*k）
桶：n2（当数据嫉妒不均匀，退化为常规排序，）

空间复杂度
好：
冒泡：1 原地排序
插入：1 原地排序
选择：1 原地排序
堆 ：1 原地排序

中：
快速：logn 递归栈空间

坏：
归并：n 的空间存临时数组
计数：n+k  用来存储每一个可能值的出现次数（k）和排序后的结果（n）
基数：n+k  用来存储数值的位数长度（k）和排序后的结果（n）
桶：n+k   用来存储桶（k）和元素（n）

稳定性
有：
冒泡：如果两个元素相等，冒泡排序不会交换它们。
插入：如果元素相等，插入排序会将新元素插入到相等元素的后面。
归并：
计数：计数排序通常是从按照一定顺序依次放置元素。这样，相等的元素按它们原有的顺序被放置在排序结果中。
基数：基数排序是通过逐位排序的方式进行排序的。每一位排序使用稳定的排序算法（通常是计数排序）
桶：桶排序是按照顺序分配桶的，当然必须

无：
选择：选择排序每次从未排序部分选择一个最小或最大的元素并与当前元素交换位置，不能包扎鞥
快速：
堆：在构建堆的时候，相同的元素甚至不能保证在邻近的位置，所以并没有办法保证相对位置
